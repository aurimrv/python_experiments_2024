[34m[*][0m Start mutation process:
[36m   -[0m targets: binarySearchTree3.py
[36m   -[0m tests: ./MIO
[34m[*][0m 50 tests passed:
[36m   -[0m test_binarySearchTree3_MIO [0.35378 s]
[34m[*][0m Start mutants generation and execution:
[36m   -[0m [#   1] AOR binarySearchTree3: 
--------------------------------------------------------------------------------
  302:         
  303:         leftbranch = 0 if not (tree.left) else tree.left.height
  304:         rightbranch = 0 if not (tree.right) else tree.right.height
  305:         
[34m- 306:         return leftbranch - rightbranch[0m
[32m+ 306:         return leftbranch + rightbranch[0m
  307:     
  308:     def pre_order(self, node='root'):
  309:         '''Depth first pre-order traversal of tree.'''
  310:         if node == 'root':
--------------------------------------------------------------------------------
[0.20728 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_0 = bst_0.balance()
>       assert var_0 == -1
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:258: AssertionError
[36m   -[0m [#   2] ASR binarySearchTree3: 
--------------------------------------------------------------------------------
   45:         if old_head:
   46:             old_head.prev = self.head
   47:         if not (self.tail):
   48:             self.tail = self.head
[34m-  49:         self._length += 1[0m
[32m+  49:         self._length -= 1[0m
   50:     
   51:     def pop(self):
   52:         '''Remove the val from the head of the list.'''
   53:         to_return = self.head
--------------------------------------------------------------------------------
[0.18807 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_4

def test_case_4():
        str_0 = 'aX}B^sw\x0cA!<Uq;!!D9'
        queue_0 = module_0.Queue(str_0)
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.dequeue()

MIO/test_binarySearchTree3_MIO.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:143: in dequeue
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b985037c0>

>   ???
E   IndexError: Cannot pop from an empty list.

binarySearchTree3:55: IndexError
[36m   -[0m [#   3] ASR binarySearchTree3: 
--------------------------------------------------------------------------------
   57:         new_head = self.head.next
   58:         if new_head:
   59:             new_head.prev = None
   60:         self.head = new_head
[34m-  61:         self._length -= 1[0m
[32m+  61:         self._length += 1[0m
   62:         if self._length < 1:
   63:             self.tail = None
   64:         return to_return.data
   65:     
--------------------------------------------------------------------------------
[0.19708 s] [31msurvived[0m
[36m   -[0m [#   4] ASR binarySearchTree3: 
--------------------------------------------------------------------------------
   70:         if old_tail:
   71:             old_tail.next = self.tail
   72:         if self._length < 1:
   73:             self.head = self.tail
[34m-  74:         self._length += 1[0m
[32m+  74:         self._length -= 1[0m
   75:     
   76:     def shift(self):
   77:         '''Remove the val from the tail of the list.'''
   78:         to_return = self.tail
--------------------------------------------------------------------------------
[0.19860 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_12

def test_case_12():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.append(double_linked_list_0)
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_1 = double_linked_list_0.remove(double_linked_list_0)

MIO/test_binarySearchTree3_MIO.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98aa38b0>
val = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98aa38b0>

>   ???
E   AttributeError: 'NoneType' object has no attribute 'prev'

binarySearchTree3:101: AttributeError
[36m   -[0m [#   5] ASR binarySearchTree3: 
--------------------------------------------------------------------------------
   82:         new_tail = self.tail.prev
   83:         if new_tail:
   84:             new_tail.next = None
   85:         self.tail = new_tail
[34m-  86:         self._length -= 1[0m
[32m+  86:         self._length += 1[0m
   87:         if self._length < 1:
   88:             self.tail = None
   89:         return to_return.data
   90:     
--------------------------------------------------------------------------------
[0.18914 s] [31msurvived[0m
[36m   -[0m [#   6] ASR binarySearchTree3: 
--------------------------------------------------------------------------------
  100:                 elif curr is self.head:
  101:                     (self.head, curr.next.prev) = (curr.next, None)
  102:                 elif curr is self.tail:
  103:                     (self.tail, curr.prev.next) = (curr.prev, None)
[34m- 104:                 self._length -= 1[0m
[32m+ 104:                 self._length += 1[0m
  105:                 return
  106:             curr = curr.next
  107:         
  108:         raise ValueError('{} is not in the list'.format(val))
--------------------------------------------------------------------------------
[0.19139 s] [31msurvived[0m
[36m   -[0m [#   7] ASR binarySearchTree3: 
--------------------------------------------------------------------------------
  237:     def insert(self, val):
  238:         '''Insert val into BST. If val is already present will be ignored.'''
  239:         if not (self.root):
  240:             self.root = Node(val)
[34m- 241:             self._size += 1[0m
[32m+ 241:             self._size -= 1[0m
  242:         else:
  243:             self._step(val, self.root)
  244:     
  245:     def _step(self, val, curr):
--------------------------------------------------------------------------------
[0.21040 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_1 = bst_0.delete(bst_0)
>       assert bst_0.root is None
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:179: AssertionError
[36m   -[0m [#   8] ASR binarySearchTree3: 
--------------------------------------------------------------------------------
  255:         child = getattr(curr, side)
  256:         if child:
  257:             count = self._step(val, child)
  258:             if curr.height <= count:
[34m- 259:                 curr.height += 1[0m
[32m+ 259:                 curr.height -= 1[0m
  260:         else:
  261:             setattr(curr, side, Node(val, curr))
  262:             self._size += 1
  263:             if curr.height == 1:
--------------------------------------------------------------------------------
[0.31241 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_0 = bst_0.balance()
>       assert var_0 == -1
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:258: AssertionError
[36m   -[0m [#   9] ASR binarySearchTree3: 
--------------------------------------------------------------------------------
  258:             if curr.height <= count:
  259:                 curr.height += 1
  260:         else:
  261:             setattr(curr, side, Node(val, curr))
[34m- 262:             self._size += 1[0m
[32m+ 262:             self._size -= 1[0m
  263:             if curr.height == 1:
  264:                 curr.height += 1
  265:         return curr
  266:     
--------------------------------------------------------------------------------
[0.17985 s] [31msurvived[0m
[36m   -[0m [#  10] ASR binarySearchTree3: 
--------------------------------------------------------------------------------
  260:         else:
  261:             setattr(curr, side, Node(val, curr))
  262:             self._size += 1
  263:             if curr.height == 1:
[34m- 264:                 curr.height += 1[0m
[32m+ 264:                 curr.height -= 1[0m
  265:         return curr
  266:     
  267:     def search(self, val):
  268:         '''Return the node containing val.'''
--------------------------------------------------------------------------------
[0.19867 s] [31msurvived[0m
[36m   -[0m [#  11] ASR binarySearchTree3: 
--------------------------------------------------------------------------------
  374:                 self.root = None
  375:         
  376:         elif node._is_interior():
  377:             next_node = self._find_replacement(node)
[34m- 378:             self._size += 1[0m
[32m+ 378:             self._size -= 1[0m
  379:             self.delete(next_node.val)
  380:             node.val = next_node.val
  381:         else:
  382:             
--------------------------------------------------------------------------------
[0.19186 s] [31msurvived[0m
[36m   -[0m [#  12] ASR binarySearchTree3: 
--------------------------------------------------------------------------------
  386:                 setattr(node.parent, node._side(), child)
  387:             else:
  388:                 self.root = child
  389:         
[34m- 390:         self._size -= 1[0m
[32m+ 390:         self._size += 1[0m
  391:     
  392:     def _find_replacement(self, node):
  393:         '''Find left most node of right subtree.'''
  394:         if node.right:
--------------------------------------------------------------------------------
[0.19573 s] [31msurvived[0m
[36m   -[0m [#  13] BCR binarySearchTree3: 
--------------------------------------------------------------------------------
  114:             try:
  115:                 popped_data = self.pop()
  116:                 l.append(popped_data)
  117:             except IndexError:
[34m- 118:                 break[0m
[32m+ 118:                 continue[0m
  119:         return l
  120: 
  121: class Queue(object):
  122:     '''Implementation of Queue.
--------------------------------------------------------------------------------
[0.19649 s] [31msurvived[0m
[36m   -[0m [#  14] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
    2: 
    3: class NodeDLL(object):
    4:     '''Node class for data storage.'''
    5:     
[34m-   6:     def __init__(self, data=None, next_node=None, prev=None):[0m
[34m-   7:         '''Initialize Node.'''[0m
[34m-   8:         self.data = data[0m
[34m-   9:         self.next = next_node[0m
[34m-  10:         self.prev = prev[0m
[34m-  11:     [0m
[32m+   6:     @classmethod[0m
[32m+   7:     def __init__(self, data=None, next_node=None, prev=None):[0m
[32m+   8:         '''Initialize Node.'''[0m
[32m+   9:         self.data = data[0m
[32m+  10:         self.next = next_node[0m
[32m+  11:         self.prev = prev[0m
   12:     def __repr__(self):
   13:         '''String representation.'''
   14:         return 'Value: {}'.format(self.data)
   15: 
--------------------------------------------------------------------------------
[0.20513 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_9

def test_case_9():
        bytes_0 = b'@\x95\xef|X\x9c\x0b\xbd\x9d\xbd\x9d)\x19\xa9'
        double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
        assert f'{type(double_linked_list_0.tail).__module__}.{type(double_linked_list_0.tail).__qualname__}' == 'binarySearchTree3.NodeDLL'
        var_0 = double_linked_list_0.shift()
>       assert var_0 == 64
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:74: AssertionError
[36m   -[0m [#  15] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
    8:         self.data = data
    9:         self.next = next_node
   10:         self.prev = prev
   11:     
[34m-  12:     def __repr__(self):[0m
[34m-  13:         '''String representation.'''[0m
[34m-  14:         return 'Value: {}'.format(self.data)[0m
[34m-  15: [0m
[32m+  12:     @classmethod[0m
[32m+  13:     def __repr__(self):[0m
[32m+  14:         '''String representation.'''[0m
[32m+  15:         return 'Value: {}'.format(self.data)[0m
   16: 
   17: class DoubleLinkedList(object):
   18:     '''Double linked list impplementation.
   19: 
--------------------------------------------------------------------------------
[0.23759 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_45

def test_case_45():
        node_d_l_l_0 = module_0.NodeDLL()
>       var_0 = node_d_l_l_0.__repr__()

MIO/test_binarySearchTree3_MIO.py:369: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree3.NodeDLL'>

>   ???
E   AttributeError: type object 'NodeDLL' has no attribute 'data'

binarySearchTree3:15: AttributeError
[36m   -[0m [#  16] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
   25:     remove(val) - will remove the first instance of (val) found in the list,
   26:     starting from the head.
   27:     '''
   28:     
[34m-  29:     def __init__(self, data=None):[0m
[34m-  30:         '''Initialize list.'''[0m
[34m-  31:         self.head = None[0m
[34m-  32:         self.tail = None[0m
[34m-  33:         self._length = 0[0m
[34m-  34:         try:[0m
[34m-  35:             for val in data:[0m
[34m-  36:                 self.push(val)[0m
[34m-  37:         except TypeError:[0m
[34m-  38:             if data:[0m
[34m-  39:                 self.push(data)[0m
[34m-  40:     [0m
[32m+  29:     @classmethod[0m
[32m+  30:     def __init__(self, data=None):[0m
[32m+  31:         '''Initialize list.'''[0m
[32m+  32:         self.head = None[0m
[32m+  33:         self.tail = None[0m
[32m+  34:         self._length = 0[0m
[32m+  35:         try:[0m
[32m+  36:             for val in data:[0m
[32m+  37:                 self.push(val)[0m
[32m+  38:         except TypeError:[0m
[32m+  39:             if data:[0m
[32m+  40:                 self.push(data)[0m
   41:     def push(self, val):
   42:         '''Add val to the head of the list.'''
   43:         old_head = self.head
   44:         self.head = NodeDLL(val, next_node=old_head)
--------------------------------------------------------------------------------
[0.30329 s] [36mincompetent[0m

TypeError: binarySearchTree3:40: TypeError: DoubleLinkedList.push() missing 1 required positional argument: 'val'

[36m   -[0m [#  17] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
   37:         except TypeError:
   38:             if data:
   39:                 self.push(data)
   40:     
[34m-  41:     def push(self, val):[0m
[34m-  42:         '''Add val to the head of the list.'''[0m
[34m-  43:         old_head = self.head[0m
[34m-  44:         self.head = NodeDLL(val, next_node=old_head)[0m
[34m-  45:         if old_head:[0m
[34m-  46:             old_head.prev = self.head[0m
[34m-  47:         if not (self.tail):[0m
[34m-  48:             self.tail = self.head[0m
[34m-  49:         self._length += 1[0m
[34m-  50:     [0m
[32m+  41:     @classmethod[0m
[32m+  42:     def push(self, val):[0m
[32m+  43:         '''Add val to the head of the list.'''[0m
[32m+  44:         old_head = self.head[0m
[32m+  45:         self.head = NodeDLL(val, next_node=old_head)[0m
[32m+  46:         if old_head:[0m
[32m+  47:             old_head.prev = self.head[0m
[32m+  48:         if not (self.tail):[0m
[32m+  49:             self.tail = self.head[0m
[32m+  50:         self._length += 1[0m
   51:     def pop(self):
   52:         '''Remove the val from the head of the list.'''
   53:         to_return = self.head
   54:         if self._length < 1:
--------------------------------------------------------------------------------
[0.19301 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_0

def test_case_0():
        bytes_0 = b'E\x9c\xce\xc8G'
>       double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)

MIO/test_binarySearchTree3_MIO.py:7: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:36: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree3.DoubleLinkedList'>, val = 69

>   ???
E   AttributeError: type object 'DoubleLinkedList' has no attribute 'head'

binarySearchTree3:44: AttributeError
[36m   -[0m [#  18] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
   47:         if not (self.tail):
   48:             self.tail = self.head
   49:         self._length += 1
   50:     
[34m-  51:     def pop(self):[0m
[34m-  52:         '''Remove the val from the head of the list.'''[0m
[34m-  53:         to_return = self.head[0m
[34m-  54:         if self._length < 1:[0m
[34m-  55:             raise IndexError('Cannot pop from an empty list.')[0m
[34m-  56:         [0m
[34m-  57:         new_head = self.head.next[0m
[34m-  58:         if new_head:[0m
[34m-  59:             new_head.prev = None[0m
[34m-  60:         self.head = new_head[0m
[34m-  61:         self._length -= 1[0m
[34m-  62:         if self._length < 1:[0m
[34m-  63:             self.tail = None[0m
[34m-  64:         return to_return.data[0m
[34m-  65:     [0m
[32m+  51:     @classmethod[0m
[32m+  52:     def pop(self):[0m
[32m+  53:         '''Remove the val from the head of the list.'''[0m
[32m+  54:         to_return = self.head[0m
[32m+  55:         if self._length < 1:[0m
[32m+  56:             raise IndexError('Cannot pop from an empty list.')[0m
[32m+  57:         [0m
[32m+  58:         new_head = self.head.next[0m
[32m+  59:         if new_head:[0m
[32m+  60:             new_head.prev = None[0m
[32m+  61:         self.head = new_head[0m
[32m+  62:         self._length -= 1[0m
[32m+  63:         if self._length < 1:[0m
[32m+  64:             self.tail = None[0m
[32m+  65:         return to_return.data[0m
   66:     def append(self, val):
   67:         '''Add val to the tail of the list.'''
   68:         old_tail = self.tail
   69:         self.tail = NodeDLL(val, prev=old_tail)
--------------------------------------------------------------------------------
[0.19731 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_4

def test_case_4():
        str_0 = 'aX}B^sw\x0cA!<Uq;!!D9'
        queue_0 = module_0.Queue(str_0)
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.dequeue()

MIO/test_binarySearchTree3_MIO.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:143: in dequeue
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree3.DoubleLinkedList'>

>   ???
E   AttributeError: type object 'DoubleLinkedList' has no attribute 'head'

binarySearchTree3:54: AttributeError
[36m   -[0m [#  19] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
   62:         if self._length < 1:
   63:             self.tail = None
   64:         return to_return.data
   65:     
[34m-  66:     def append(self, val):[0m
[34m-  67:         '''Add val to the tail of the list.'''[0m
[34m-  68:         old_tail = self.tail[0m
[34m-  69:         self.tail = NodeDLL(val, prev=old_tail)[0m
[34m-  70:         if old_tail:[0m
[34m-  71:             old_tail.next = self.tail[0m
[34m-  72:         if self._length < 1:[0m
[34m-  73:             self.head = self.tail[0m
[34m-  74:         self._length += 1[0m
[34m-  75:     [0m
[32m+  66:     @classmethod[0m
[32m+  67:     def append(self, val):[0m
[32m+  68:         '''Add val to the tail of the list.'''[0m
[32m+  69:         old_tail = self.tail[0m
[32m+  70:         self.tail = NodeDLL(val, prev=old_tail)[0m
[32m+  71:         if old_tail:[0m
[32m+  72:             old_tail.next = self.tail[0m
[32m+  73:         if self._length < 1:[0m
[32m+  74:             self.head = self.tail[0m
[32m+  75:         self._length += 1[0m
   76:     def shift(self):
   77:         '''Remove the val from the tail of the list.'''
   78:         to_return = self.tail
   79:         if self._length < 1:
--------------------------------------------------------------------------------
[0.20528 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_7

def test_case_7():
        queue_0 = module_0.Queue()
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.enqueue(queue_0)

MIO/test_binarySearchTree3_MIO.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:139: in enqueue
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree3.DoubleLinkedList'>
val = <binarySearchTree3.Queue object at 0x7f9b98d05f90>

>   ???
E   AttributeError: type object 'DoubleLinkedList' has no attribute 'tail'

binarySearchTree3:69: AttributeError
[36m   -[0m [#  20] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
   72:         if self._length < 1:
   73:             self.head = self.tail
   74:         self._length += 1
   75:     
[34m-  76:     def shift(self):[0m
[34m-  77:         '''Remove the val from the tail of the list.'''[0m
[34m-  78:         to_return = self.tail[0m
[34m-  79:         if self._length < 1:[0m
[34m-  80:             raise IndexError('Cannot shift from an empty list.')[0m
[34m-  81:         [0m
[34m-  82:         new_tail = self.tail.prev[0m
[34m-  83:         if new_tail:[0m
[34m-  84:             new_tail.next = None[0m
[34m-  85:         self.tail = new_tail[0m
[34m-  86:         self._length -= 1[0m
[34m-  87:         if self._length < 1:[0m
[34m-  88:             self.tail = None[0m
[34m-  89:         return to_return.data[0m
[34m-  90:     [0m
[32m+  76:     @classmethod[0m
[32m+  77:     def shift(self):[0m
[32m+  78:         '''Remove the val from the tail of the list.'''[0m
[32m+  79:         to_return = self.tail[0m
[32m+  80:         if self._length < 1:[0m
[32m+  81:             raise IndexError('Cannot shift from an empty list.')[0m
[32m+  82:         [0m
[32m+  83:         new_tail = self.tail.prev[0m
[32m+  84:         if new_tail:[0m
[32m+  85:             new_tail.next = None[0m
[32m+  86:         self.tail = new_tail[0m
[32m+  87:         self._length -= 1[0m
[32m+  88:         if self._length < 1:[0m
[32m+  89:             self.tail = None[0m
[32m+  90:         return to_return.data[0m
   91:     def remove(self, val):
   92:         '''Remove first occurance of val from list.'''
   93:         curr = self.head
   94:         while curr:
--------------------------------------------------------------------------------
[0.20361 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_9

def test_case_9():
        bytes_0 = b'@\x95\xef|X\x9c\x0b\xbd\x9d\xbd\x9d)\x19\xa9'
        double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
        assert f'{type(double_linked_list_0.tail).__module__}.{type(double_linked_list_0.tail).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_0 = double_linked_list_0.shift()

MIO/test_binarySearchTree3_MIO.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree3.DoubleLinkedList'>

>   ???
E   AttributeError: type object 'DoubleLinkedList' has no attribute 'tail'

binarySearchTree3:79: AttributeError
[36m   -[0m [#  21] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
   87:         if self._length < 1:
   88:             self.tail = None
   89:         return to_return.data
   90:     
[34m-  91:     def remove(self, val):[0m
[34m-  92:         '''Remove first occurance of val from list.'''[0m
[34m-  93:         curr = self.head[0m
[34m-  94:         while curr:[0m
[34m-  95:             if curr.data is val:[0m
[34m-  96:                 if self._length == 1:[0m
[34m-  97:                     (self.head, self.tail) = (None, None)[0m
[34m-  98:                 elif (curr is not self.head and curr is not self.tail):[0m
[34m-  99:                     (curr.next.prev, curr.prev.next) = (curr.prev, curr.next)[0m
[34m- 100:                 elif curr is self.head:[0m
[34m- 101:                     (self.head, curr.next.prev) = (curr.next, None)[0m
[34m- 102:                 elif curr is self.tail:[0m
[34m- 103:                     (self.tail, curr.prev.next) = (curr.prev, None)[0m
[34m- 104:                 self._length -= 1[0m
[34m- 105:                 return[0m
[34m- 106:             curr = curr.next[0m
[34m- 107:         [0m
[34m- 108:         raise ValueError('{} is not in the list'.format(val))[0m
[34m- 109:     [0m
[32m+  91:     @classmethod[0m
[32m+  92:     def remove(self, val):[0m
[32m+  93:         '''Remove first occurance of val from list.'''[0m
[32m+  94:         curr = self.head[0m
[32m+  95:         while curr:[0m
[32m+  96:             if curr.data is val:[0m
[32m+  97:                 if self._length == 1:[0m
[32m+  98:                     (self.head, self.tail) = (None, None)[0m
[32m+  99:                 elif (curr is not self.head and curr is not self.tail):[0m
[32m+ 100:                     (curr.next.prev, curr.prev.next) = (curr.prev, curr.next)[0m
[32m+ 101:                 elif curr is self.head:[0m
[32m+ 102:                     (self.head, curr.next.prev) = (curr.next, None)[0m
[32m+ 103:                 elif curr is self.tail:[0m
[32m+ 104:                     (self.tail, curr.prev.next) = (curr.prev, None)[0m
[32m+ 105:                 self._length -= 1[0m
[32m+ 106:                 return[0m
[32m+ 107:             curr = curr.next[0m
[32m+ 108:         [0m
[32m+ 109:         raise ValueError('{} is not in the list'.format(val))[0m
  110:     def _repr(self):
  111:         '''Return list representation of dll.'''
  112:         l = []
  113:         while True:
--------------------------------------------------------------------------------
[0.30171 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_12

def test_case_12():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.append(double_linked_list_0)
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_1 = double_linked_list_0.remove(double_linked_list_0)

MIO/test_binarySearchTree3_MIO.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree3.DoubleLinkedList'>
val = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98b39990>

>   ???
E   AttributeError: type object 'DoubleLinkedList' has no attribute 'head'

binarySearchTree3:94: AttributeError
[36m   -[0m [#  22] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  106:             curr = curr.next
  107:         
  108:         raise ValueError('{} is not in the list'.format(val))
  109:     
[34m- 110:     def _repr(self):[0m
[34m- 111:         '''Return list representation of dll.'''[0m
[34m- 112:         l = [][0m
[34m- 113:         while True:[0m
[34m- 114:             try:[0m
[34m- 115:                 popped_data = self.pop()[0m
[34m- 116:                 l.append(popped_data)[0m
[34m- 117:             except IndexError:[0m
[34m- 118:                 break[0m
[34m- 119:         return l[0m
[34m- 120: [0m
[32m+ 110:     @classmethod[0m
[32m+ 111:     def _repr(self):[0m
[32m+ 112:         '''Return list representation of dll.'''[0m
[32m+ 113:         l = [][0m
[32m+ 114:         while True:[0m
[32m+ 115:             try:[0m
[32m+ 116:                 popped_data = self.pop()[0m
[32m+ 117:                 l.append(popped_data)[0m
[32m+ 118:             except IndexError:[0m
[32m+ 119:                 break[0m
[32m+ 120:         return l[0m
  121: class Queue(object):
  122:     '''Implementation of Queue.
  123: 
  124:     This implementation supports the following public methods:
--------------------------------------------------------------------------------
[0.19777 s] [31msurvived[0m
[36m   -[0m [#  23] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  129:     If the queue is empty, returns None
  130:     size(): return the size of the queue. Returns 0 if the queue is empty.
  131:     '''
  132:     
[34m- 133:     def __init__(self, data=None):[0m
[34m- 134:         '''Initialize queue data structure.'''[0m
[34m- 135:         self._container = DoubleLinkedList(data)[0m
[34m- 136:     [0m
[32m+ 133:     @classmethod[0m
[32m+ 134:     def __init__(self, data=None):[0m
[32m+ 135:         '''Initialize queue data structure.'''[0m
[32m+ 136:         self._container = DoubleLinkedList(data)[0m
  137:     def enqueue(self, val):
  138:         '''Add a value to the queue.'''
  139:         self._container.append(val)
  140:     
--------------------------------------------------------------------------------
[0.19775 s] [31msurvived[0m
[36m   -[0m [#  24] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  133:     def __init__(self, data=None):
  134:         '''Initialize queue data structure.'''
  135:         self._container = DoubleLinkedList(data)
  136:     
[34m- 137:     def enqueue(self, val):[0m
[34m- 138:         '''Add a value to the queue.'''[0m
[34m- 139:         self._container.append(val)[0m
[34m- 140:     [0m
[32m+ 137:     @classmethod[0m
[32m+ 138:     def enqueue(self, val):[0m
[32m+ 139:         '''Add a value to the queue.'''[0m
[32m+ 140:         self._container.append(val)[0m
  141:     def dequeue(self):
  142:         '''Remove a value from the front of the queue.'''
  143:         return self._container.pop()
  144:     
--------------------------------------------------------------------------------
[0.20420 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_7

def test_case_7():
        queue_0 = module_0.Queue()
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.enqueue(queue_0)

MIO/test_binarySearchTree3_MIO.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree3.Queue'>
val = <binarySearchTree3.Queue object at 0x7f9b9835cd30>

>   ???
E   AttributeError: type object 'Queue' has no attribute '_container'

binarySearchTree3:140: AttributeError
[36m   -[0m [#  25] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  137:     def enqueue(self, val):
  138:         '''Add a value to the queue.'''
  139:         self._container.append(val)
  140:     
[34m- 141:     def dequeue(self):[0m
[34m- 142:         '''Remove a value from the front of the queue.'''[0m
[34m- 143:         return self._container.pop()[0m
[34m- 144:     [0m
[32m+ 141:     @classmethod[0m
[32m+ 142:     def dequeue(self):[0m
[32m+ 143:         '''Remove a value from the front of the queue.'''[0m
[32m+ 144:         return self._container.pop()[0m
  145:     def peek(self):
  146:         '''Return the next value in the queue without dequing it.'''
  147:         try:
  148:             return self._container.head.data
--------------------------------------------------------------------------------
[0.20081 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_4

def test_case_4():
        str_0 = 'aX}B^sw\x0cA!<Uq;!!D9'
        queue_0 = module_0.Queue(str_0)
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.dequeue()

MIO/test_binarySearchTree3_MIO.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree3.Queue'>

>   ???
E   AttributeError: type object 'Queue' has no attribute '_container'

binarySearchTree3:144: AttributeError
[36m   -[0m [#  26] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  141:     def dequeue(self):
  142:         '''Remove a value from the front of the queue.'''
  143:         return self._container.pop()
  144:     
[34m- 145:     def peek(self):[0m
[34m- 146:         '''Return the next value in the queue without dequing it.'''[0m
[34m- 147:         try:[0m
[34m- 148:             return self._container.head.data[0m
[34m- 149:         except AttributeError:[0m
[34m- 150:             return None[0m
[34m- 151:     [0m
[32m+ 145:     @classmethod[0m
[32m+ 146:     def peek(self):[0m
[32m+ 147:         '''Return the next value in the queue without dequing it.'''[0m
[32m+ 148:         try:[0m
[32m+ 149:             return self._container.head.data[0m
[32m+ 150:         except AttributeError:[0m
[32m+ 151:             return None[0m
  152:     def size(self):
  153:         '''Return the size of the queue.'''
  154:         return self._container._length
  155: 
--------------------------------------------------------------------------------
[0.23341 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_41

def test_case_41():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.delete(bst_0)
        var_1 = bst_0.insert(var_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_2 = bst_0.breadth_first()
        double_linked_list_0 = module_0.DoubleLinkedList(var_2)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
>       assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:345: AssertionError
[36m   -[0m [#  27] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  148:             return self._container.head.data
  149:         except AttributeError:
  150:             return None
  151:     
[34m- 152:     def size(self):[0m
[34m- 153:         '''Return the size of the queue.'''[0m
[34m- 154:         return self._container._length[0m
[34m- 155: [0m
[32m+ 152:     @classmethod[0m
[32m+ 153:     def size(self):[0m
[32m+ 154:         '''Return the size of the queue.'''[0m
[32m+ 155:         return self._container._length[0m
  156: class Node(object):
  157:     '''Node, or leaf of the BST.'''
  158:     
  159:     def __init__(self, val=None, parent=None):
--------------------------------------------------------------------------------
[0.24273 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_47

def test_case_47():
        queue_0 = module_0.Queue()
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.size()

MIO/test_binarySearchTree3_MIO.py:379: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree3.Queue'>

>   ???
E   AttributeError: type object 'Queue' has no attribute '_container'

binarySearchTree3:155: AttributeError
[36m   -[0m [#  28] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  155: 
  156: class Node(object):
  157:     '''Node, or leaf of the BST.'''
  158:     
[34m- 159:     def __init__(self, val=None, parent=None):[0m
[34m- 160:         '''Create node object.'''[0m
[34m- 161:         self.val = val[0m
[34m- 162:         self.right = None[0m
[34m- 163:         self.left = None[0m
[34m- 164:         self.parent = parent[0m
[34m- 165:         self.height = 1[0m
[34m- 166:     [0m
[32m+ 159:     @classmethod[0m
[32m+ 160:     def __init__(self, val=None, parent=None):[0m
[32m+ 161:         '''Create node object.'''[0m
[32m+ 162:         self.val = val[0m
[32m+ 163:         self.right = None[0m
[32m+ 164:         self.left = None[0m
[32m+ 165:         self.parent = parent[0m
[32m+ 166:         self.height = 1[0m
  167:     def _is_leaf(self):
  168:         '''Return true if a leaf.'''
  169:         return not ((self.right or self.left))
  170:     
--------------------------------------------------------------------------------
[0.23105 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_0 = bst_0.balance()
>       assert var_0 == -1
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:258: AssertionError
[36m   -[0m [#  29] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  163:         self.left = None
  164:         self.parent = parent
  165:         self.height = 1
  166:     
[34m- 167:     def _is_leaf(self):[0m
[34m- 168:         '''Return true if a leaf.'''[0m
[34m- 169:         return not ((self.right or self.left))[0m
[34m- 170:     [0m
[32m+ 167:     @classmethod[0m
[32m+ 168:     def _is_leaf(self):[0m
[32m+ 169:         '''Return true if a leaf.'''[0m
[32m+ 170:         return not ((self.right or self.left))[0m
  171:     def _is_interior(self):
  172:         '''Return true if a interior node.'''
  173:         return (self.right and self.left)
  174:     
--------------------------------------------------------------------------------
[0.30492 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_1 = bst_0.delete(bst_0)

MIO/test_binarySearchTree3_MIO.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:370: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree3.Node'>

>   ???
E   AttributeError: type object 'Node' has no attribute 'right'

binarySearchTree3:170: AttributeError
[36m   -[0m [#  30] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  167:     def _is_leaf(self):
  168:         '''Return true if a leaf.'''
  169:         return not ((self.right or self.left))
  170:     
[34m- 171:     def _is_interior(self):[0m
[34m- 172:         '''Return true if a interior node.'''[0m
[34m- 173:         return (self.right and self.left)[0m
[34m- 174:     [0m
[32m+ 171:     @classmethod[0m
[32m+ 172:     def _is_interior(self):[0m
[32m+ 173:         '''Return true if a interior node.'''[0m
[32m+ 174:         return (self.right and self.left)[0m
  175:     def _onlychild(self):
  176:         '''Return string depending on children.'''
  177:         if (self.left and not (self.right)):
  178:             return 'left'
--------------------------------------------------------------------------------
[0.19056 s] [31msurvived[0m
[36m   -[0m [#  31] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  171:     def _is_interior(self):
  172:         '''Return true if a interior node.'''
  173:         return (self.right and self.left)
  174:     
[34m- 175:     def _onlychild(self):[0m
[34m- 176:         '''Return string depending on children.'''[0m
[34m- 177:         if (self.left and not (self.right)):[0m
[34m- 178:             return 'left'[0m
[34m- 179:         if (self.right and not (self.left)):[0m
[34m- 180:             return 'right'[0m
[34m- 181:     [0m
[32m+ 175:     @classmethod[0m
[32m+ 176:     def _onlychild(self):[0m
[32m+ 177:         '''Return string depending on children.'''[0m
[32m+ 178:         if (self.left and not (self.right)):[0m
[32m+ 179:             return 'left'[0m
[32m+ 180:         if (self.right and not (self.left)):[0m
[32m+ 181:             return 'right'[0m
  182:     def _side(self):
  183:         '''Return if left or right child of parent.'''
  184:         if self.parent:
  185:             return 'left' if self.parent.left == self else 'right'
--------------------------------------------------------------------------------
[0.19688 s] [31msurvived[0m
[36m   -[0m [#  32] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  178:             return 'left'
  179:         if (self.right and not (self.left)):
  180:             return 'right'
  181:     
[34m- 182:     def _side(self):[0m
[34m- 183:         '''Return if left or right child of parent.'''[0m
[34m- 184:         if self.parent:[0m
[34m- 185:             return 'left' if self.parent.left == self else 'right'[0m
[34m- 186: [0m
[32m+ 182:     @classmethod[0m
[32m+ 183:     def _side(self):[0m
[32m+ 184:         '''Return if left or right child of parent.'''[0m
[32m+ 185:         if self.parent:[0m
[32m+ 186:             return 'left' if self.parent.left == self else 'right'[0m
  187: 
  188: class Bst(object):
  189:     '''Binary Search Tree.
  190: 
--------------------------------------------------------------------------------
[0.17740 s] [31msurvived[0m
[36m   -[0m [#  33] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  224:     using breadth frist traversal, one at a time.
  225: 
  226:     '''
  227:     
[34m- 228:     def __init__(self, data=None):[0m
[34m- 229:         '''Initialize tree.'''[0m
[34m- 230:         self._size = 0[0m
[34m- 231:         self.root = None[0m
[34m- 232:         [0m
[34m- 233:         if data:[0m
[34m- 234:             for i in data:[0m
[34m- 235:                 self.insert(i)[0m
[34m- 236:     [0m
[32m+ 228:     @classmethod[0m
[32m+ 229:     def __init__(self, data=None):[0m
[32m+ 230:         '''Initialize tree.'''[0m
[32m+ 231:         self._size = 0[0m
[32m+ 232:         self.root = None[0m
[32m+ 233:         [0m
[32m+ 234:         if data:[0m
[32m+ 235:             for i in data:[0m
[32m+ 236:                 self.insert(i)[0m
  237:     def insert(self, val):
  238:         '''Insert val into BST. If val is already present will be ignored.'''
  239:         if not (self.root):
  240:             self.root = Node(val)
--------------------------------------------------------------------------------
[0.20806 s] [36mincompetent[0m

TypeError: binarySearchTree3:236: TypeError: Bst.insert() missing 1 required positional argument: 'val'

[36m   -[0m [#  34] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  233:         if data:
  234:             for i in data:
  235:                 self.insert(i)
  236:     
[34m- 237:     def insert(self, val):[0m
[34m- 238:         '''Insert val into BST. If val is already present will be ignored.'''[0m
[34m- 239:         if not (self.root):[0m
[34m- 240:             self.root = Node(val)[0m
[34m- 241:             self._size += 1[0m
[34m- 242:         else:[0m
[34m- 243:             self._step(val, self.root)[0m
[34m- 244:     [0m
[32m+ 237:     @classmethod[0m
[32m+ 238:     def insert(self, val):[0m
[32m+ 239:         '''Insert val into BST. If val is already present will be ignored.'''[0m
[32m+ 240:         if not (self.root):[0m
[32m+ 241:             self.root = Node(val)[0m
[32m+ 242:             self._size += 1[0m
[32m+ 243:         else:[0m
[32m+ 244:             self._step(val, self.root)[0m
  245:     def _step(self, val, curr):
  246:         '''Decide left or right and returns height.'''
  247:         if val < curr.val:
  248:             curr = self._set_child(curr, 'left', val)
--------------------------------------------------------------------------------
[0.20228 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
>       var_0 = bst_0.insert(bst_0)

MIO/test_binarySearchTree3_MIO.py:176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree3.Bst'>
val = <binarySearchTree3.Bst object at 0x7f9b98ab7f40>

>   ???
E   AttributeError: type object 'Bst' has no attribute 'root'

binarySearchTree3:240: AttributeError
[36m   -[0m [#  35] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  241:             self._size += 1
  242:         else:
  243:             self._step(val, self.root)
  244:     
[34m- 245:     def _step(self, val, curr):[0m
[34m- 246:         '''Decide left or right and returns height.'''[0m
[34m- 247:         if val < curr.val:[0m
[34m- 248:             curr = self._set_child(curr, 'left', val)[0m
[34m- 249:         elif val > curr.val:[0m
[34m- 250:             curr = self._set_child(curr, 'right', val)[0m
[34m- 251:         return curr.height[0m
[34m- 252:     [0m
[32m+ 245:     @classmethod[0m
[32m+ 246:     def _step(self, val, curr):[0m
[32m+ 247:         '''Decide left or right and returns height.'''[0m
[32m+ 248:         if val < curr.val:[0m
[32m+ 249:             curr = self._set_child(curr, 'left', val)[0m
[32m+ 250:         elif val > curr.val:[0m
[32m+ 251:             curr = self._set_child(curr, 'right', val)[0m
[32m+ 252:         return curr.height[0m
  253:     def _set_child(self, curr, side, val):
  254:         '''Helping.'''
  255:         child = getattr(curr, side)
  256:         if child:
--------------------------------------------------------------------------------
[0.20772 s] [36mincompetent[0m

TypeError: binarySearchTree3:251: TypeError: Bst._set_child() missing 1 required positional argument: 'val'

[36m   -[0m [#  36] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  249:         elif val > curr.val:
  250:             curr = self._set_child(curr, 'right', val)
  251:         return curr.height
  252:     
[34m- 253:     def _set_child(self, curr, side, val):[0m
[34m- 254:         '''Helping.'''[0m
[34m- 255:         child = getattr(curr, side)[0m
[34m- 256:         if child:[0m
[34m- 257:             count = self._step(val, child)[0m
[34m- 258:             if curr.height <= count:[0m
[34m- 259:                 curr.height += 1[0m
[34m- 260:         else:[0m
[34m- 261:             setattr(curr, side, Node(val, curr))[0m
[34m- 262:             self._size += 1[0m
[34m- 263:             if curr.height == 1:[0m
[34m- 264:                 curr.height += 1[0m
[34m- 265:         return curr[0m
[34m- 266:     [0m
[32m+ 253:     @classmethod[0m
[32m+ 254:     def _set_child(self, curr, side, val):[0m
[32m+ 255:         '''Helping.'''[0m
[32m+ 256:         child = getattr(curr, side)[0m
[32m+ 257:         if child:[0m
[32m+ 258:             count = self._step(val, child)[0m
[32m+ 259:             if curr.height <= count:[0m
[32m+ 260:                 curr.height += 1[0m
[32m+ 261:         else:[0m
[32m+ 262:             setattr(curr, side, Node(val, curr))[0m
[32m+ 263:             self._size += 1[0m
[32m+ 264:             if curr.height == 1:[0m
[32m+ 265:                 curr.height += 1[0m
[32m+ 266:         return curr[0m
  267:     def search(self, val):
  268:         '''Return the node containing val.'''
  269:         curr = self.root
  270:         while curr:
--------------------------------------------------------------------------------
[0.20918 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_21

def test_case_21():
        bytes_0 = b'z\xc7'
>       bst_0 = module_0.Bst(bytes_0)

MIO/test_binarySearchTree3_MIO.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:235: in __init__
    ???
binarySearchTree3:243: in insert
    ???
binarySearchTree3:250: in _step
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree3.Bst'>
curr = <binarySearchTree3.Node object at 0x7f9b987f5570>, side = 'right'
val = 199

>   ???
E   AttributeError: type object 'Bst' has no attribute '_size'

binarySearchTree3:263: AttributeError
[36m   -[0m [#  37] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  263:             if curr.height == 1:
  264:                 curr.height += 1
  265:         return curr
  266:     
[34m- 267:     def search(self, val):[0m
[34m- 268:         '''Return the node containing val.'''[0m
[34m- 269:         curr = self.root[0m
[34m- 270:         while curr:[0m
[34m- 271:             if curr.val == val:[0m
[34m- 272:                 return curr[0m
[34m- 273:             elif val < curr.val:[0m
[34m- 274:                 curr = curr.left[0m
[34m- 275:             else:[0m
[34m- 276:                 curr = curr.right[0m
[34m- 277:     [0m
[32m+ 267:     @classmethod[0m
[32m+ 268:     def search(self, val):[0m
[32m+ 269:         '''Return the node containing val.'''[0m
[32m+ 270:         curr = self.root[0m
[32m+ 271:         while curr:[0m
[32m+ 272:             if curr.val == val:[0m
[32m+ 273:                 return curr[0m
[32m+ 274:             elif val < curr.val:[0m
[32m+ 275:                 curr = curr.left[0m
[32m+ 276:             else:[0m
[32m+ 277:                 curr = curr.right[0m
  278:     def size(self):
  279:         '''Return the size of the BST.'''
  280:         return self._size
  281:     
--------------------------------------------------------------------------------
[0.31794 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_1 = bst_0.delete(bst_0)

MIO/test_binarySearchTree3_MIO.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:365: in delete
    ???
binarySearchTree3:288: in contains
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree3.Bst'>
val = <binarySearchTree3.Bst object at 0x7f9b98ab0670>

>   ???
E   AttributeError: type object 'Bst' has no attribute 'root'

binarySearchTree3:270: AttributeError
[36m   -[0m [#  38] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  274:                 curr = curr.left
  275:             else:
  276:                 curr = curr.right
  277:     
[34m- 278:     def size(self):[0m
[34m- 279:         '''Return the size of the BST.'''[0m
[34m- 280:         return self._size[0m
[34m- 281:     [0m
[32m+ 278:     @classmethod[0m
[32m+ 279:     def size(self):[0m
[32m+ 280:         '''Return the size of the BST.'''[0m
[32m+ 281:         return self._size[0m
  282:     def depth(self):
  283:         '''Return depth of the BST, representing total levels.'''
  284:         return 0 if not (self.root) else self.root.height
  285:     
--------------------------------------------------------------------------------
[0.23494 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_39

def test_case_39():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.post_order()
>       var_1 = bst_0.size()

MIO/test_binarySearchTree3_MIO.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree3.Bst'>

>   ???
E   AttributeError: type object 'Bst' has no attribute '_size'

binarySearchTree3:281: AttributeError
[36m   -[0m [#  39] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  278:     def size(self):
  279:         '''Return the size of the BST.'''
  280:         return self._size
  281:     
[34m- 282:     def depth(self):[0m
[34m- 283:         '''Return depth of the BST, representing total levels.'''[0m
[34m- 284:         return 0 if not (self.root) else self.root.height[0m
[34m- 285:     [0m
[32m+ 282:     @classmethod[0m
[32m+ 283:     def depth(self):[0m
[32m+ 284:         '''Return depth of the BST, representing total levels.'''[0m
[32m+ 285:         return 0 if not (self.root) else self.root.height[0m
  286:     def contains(self, val):
  287:         '''Return true if val is in the bst.'''
  288:         return self.search(val) is not None
  289:     
--------------------------------------------------------------------------------
[0.22506 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_30

def test_case_30():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_1 = bst_0.depth()

MIO/test_binarySearchTree3_MIO.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree3.Bst'>

>   ???
E   AttributeError: type object 'Bst' has no attribute 'root'

binarySearchTree3:285: AttributeError
[36m   -[0m [#  40] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  282:     def depth(self):
  283:         '''Return depth of the BST, representing total levels.'''
  284:         return 0 if not (self.root) else self.root.height
  285:     
[34m- 286:     def contains(self, val):[0m
[34m- 287:         '''Return true if val is in the bst.'''[0m
[34m- 288:         return self.search(val) is not None[0m
[34m- 289:     [0m
[32m+ 286:     @classmethod[0m
[32m+ 287:     def contains(self, val):[0m
[32m+ 288:         '''Return true if val is in the bst.'''[0m
[32m+ 289:         return self.search(val) is not None[0m
  290:     def balance(self, tree=None):
  291:         '''Return an integer of how well the tree is balanced.
  292: 
  293:         Trees which are higher on the left than the right should return a
--------------------------------------------------------------------------------
[0.21539 s] [36mincompetent[0m

TypeError: binarySearchTree3:289: TypeError: Bst.search() missing 1 required positional argument: 'val'

[36m   -[0m [#  41] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  286:     def contains(self, val):
  287:         '''Return true if val is in the bst.'''
  288:         return self.search(val) is not None
  289:     
[34m- 290:     def balance(self, tree=None):[0m
[34m- 291:         '''Return an integer of how well the tree is balanced.[0m
[34m- 292: [0m
[34m- 293:         Trees which are higher on the left than the right should return a[0m
[34m- 294:         positive value, trees which are higher on the right than the left[0m
[34m- 295:         should return a negative value. An ideally-balanced tree should[0m
[34m- 296:         return 0.[0m
[34m- 297:         '''[0m
[34m- 298:         if not tree:[0m
[34m- 299:             tree = self.root[0m
[34m- 300:             if not tree:[0m
[34m- 301:                 return 0[0m
[34m- 302:         [0m
[34m- 303:         leftbranch = 0 if not (tree.left) else tree.left.height[0m
[34m- 304:         rightbranch = 0 if not (tree.right) else tree.right.height[0m
[34m- 305:         [0m
[34m- 306:         return leftbranch - rightbranch[0m
[34m- 307:     [0m
[32m+ 290:     @classmethod[0m
[32m+ 291:     def balance(self, tree=None):[0m
[32m+ 292:         '''Return an integer of how well the tree is balanced.[0m
[32m+ 293: [0m
[32m+ 294:         Trees which are higher on the left than the right should return a[0m
[32m+ 295:         positive value, trees which are higher on the right than the left[0m
[32m+ 296:         should return a negative value. An ideally-balanced tree should[0m
[32m+ 297:         return 0.[0m
[32m+ 298:         '''[0m
[32m+ 299:         if not tree:[0m
[32m+ 300:             tree = self.root[0m
[32m+ 301:             if not tree:[0m
[32m+ 302:                 return 0[0m
[32m+ 303:         [0m
[32m+ 304:         leftbranch = 0 if not (tree.left) else tree.left.height[0m
[32m+ 305:         rightbranch = 0 if not (tree.right) else tree.right.height[0m
[32m+ 306:         [0m
[32m+ 307:         return leftbranch - rightbranch[0m
  308:     def pre_order(self, node='root'):
  309:         '''Depth first pre-order traversal of tree.'''
  310:         if node == 'root':
  311:             node = self.root
--------------------------------------------------------------------------------
[0.22535 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_0 = bst_0.balance()

MIO/test_binarySearchTree3_MIO.py:257: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree3.Bst'>, tree = None

>   ???
E   AttributeError: type object 'Bst' has no attribute 'root'

binarySearchTree3:300: AttributeError
[36m   -[0m [#  42] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  304:         rightbranch = 0 if not (tree.right) else tree.right.height
  305:         
  306:         return leftbranch - rightbranch
  307:     
[34m- 308:     def pre_order(self, node='root'):[0m
[34m- 309:         '''Depth first pre-order traversal of tree.'''[0m
[34m- 310:         if node == 'root':[0m
[34m- 311:             node = self.root[0m
[34m- 312:         [0m
[34m- 313:         if not node:[0m
[34m- 314:             return[0m
[34m- 315:         [0m
[34m- 316:         yield node.val[0m
[34m- 317:         [0m
[34m- 318:         for n in self.pre_order(node=node.left):[0m
[34m- 319:             yield n[0m
[34m- 320:         for n in self.pre_order(node=node.right):[0m
[34m- 321:             yield n[0m
[34m- 322:     [0m
[32m+ 308:     @classmethod[0m
[32m+ 309:     def pre_order(self, node='root'):[0m
[32m+ 310:         '''Depth first pre-order traversal of tree.'''[0m
[32m+ 311:         if node == 'root':[0m
[32m+ 312:             node = self.root[0m
[32m+ 313:         [0m
[32m+ 314:         if not node:[0m
[32m+ 315:             return[0m
[32m+ 316:         [0m
[32m+ 317:         yield node.val[0m
[32m+ 318:         [0m
[32m+ 319:         for n in self.pre_order(node=node.left):[0m
[32m+ 320:             yield n[0m
[32m+ 321:         for n in self.pre_order(node=node.right):[0m
[32m+ 322:             yield n[0m
  323:     def in_order(self, node='root'):
  324:         '''Depth first in-order traversal of tree.'''
  325:         if node == 'root':
  326:             node = self.root
--------------------------------------------------------------------------------
[0.34127 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_36

def test_case_36():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.pre_order()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree3.Bst'>, node = 'root'

>   ???
E   AttributeError: type object 'Bst' has no attribute 'root'

binarySearchTree3:312: AttributeError
[36m   -[0m [#  43] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  319:             yield n
  320:         for n in self.pre_order(node=node.right):
  321:             yield n
  322:     
[34m- 323:     def in_order(self, node='root'):[0m
[34m- 324:         '''Depth first in-order traversal of tree.'''[0m
[34m- 325:         if node == 'root':[0m
[34m- 326:             node = self.root[0m
[34m- 327:         [0m
[34m- 328:         if not node:[0m
[34m- 329:             return[0m
[34m- 330:         [0m
[34m- 331:         for n in self.in_order(node=node.left):[0m
[34m- 332:             yield n[0m
[34m- 333:         yield node.val[0m
[34m- 334:         for n in self.in_order(node=node.right):[0m
[34m- 335:             yield n[0m
[34m- 336:     [0m
[32m+ 323:     @classmethod[0m
[32m+ 324:     def in_order(self, node='root'):[0m
[32m+ 325:         '''Depth first in-order traversal of tree.'''[0m
[32m+ 326:         if node == 'root':[0m
[32m+ 327:             node = self.root[0m
[32m+ 328:         [0m
[32m+ 329:         if not node:[0m
[32m+ 330:             return[0m
[32m+ 331:         [0m
[32m+ 332:         for n in self.in_order(node=node.left):[0m
[32m+ 333:             yield n[0m
[32m+ 334:         yield node.val[0m
[32m+ 335:         for n in self.in_order(node=node.right):[0m
[32m+ 336:             yield n[0m
  337:     def post_order(self, node='root'):
  338:         '''Depth frist post_order traversal of tree.'''
  339:         if node == 'root':
  340:             node = self.root
--------------------------------------------------------------------------------
[0.23179 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_38

def test_case_38():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.in_order()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:306: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree3.Bst'>, node = 'root'

>   ???
E   AttributeError: type object 'Bst' has no attribute 'root'

binarySearchTree3:327: AttributeError
[36m   -[0m [#  44] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  333:         yield node.val
  334:         for n in self.in_order(node=node.right):
  335:             yield n
  336:     
[34m- 337:     def post_order(self, node='root'):[0m
[34m- 338:         '''Depth frist post_order traversal of tree.'''[0m
[34m- 339:         if node == 'root':[0m
[34m- 340:             node = self.root[0m
[34m- 341:         [0m
[34m- 342:         if not node:[0m
[34m- 343:             return[0m
[34m- 344:         [0m
[34m- 345:         for n in self.post_order(node=node.left):[0m
[34m- 346:             yield n[0m
[34m- 347:         for n in self.post_order(node=node.right):[0m
[34m- 348:             yield n[0m
[34m- 349:         yield node.val[0m
[34m- 350:     [0m
[32m+ 337:     @classmethod[0m
[32m+ 338:     def post_order(self, node='root'):[0m
[32m+ 339:         '''Depth frist post_order traversal of tree.'''[0m
[32m+ 340:         if node == 'root':[0m
[32m+ 341:             node = self.root[0m
[32m+ 342:         [0m
[32m+ 343:         if not node:[0m
[32m+ 344:             return[0m
[32m+ 345:         [0m
[32m+ 346:         for n in self.post_order(node=node.left):[0m
[32m+ 347:             yield n[0m
[32m+ 348:         for n in self.post_order(node=node.right):[0m
[32m+ 349:             yield n[0m
[32m+ 350:         yield node.val[0m
  351:     def breadth_first(self):
  352:         '''Breadth first traversal of tree.'''
  353:         q = Queue()
  354:         q.enqueue(self.root)
--------------------------------------------------------------------------------
[0.21754 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_39

def test_case_39():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.post_order()
        var_1 = bst_0.size()
        assert var_1 == 0
        var_2 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:320: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree3.Bst'>, node = 'root'

>   ???
E   AttributeError: type object 'Bst' has no attribute 'root'

binarySearchTree3:341: AttributeError
[36m   -[0m [#  45] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  347:         for n in self.post_order(node=node.right):
  348:             yield n
  349:         yield node.val
  350:     
[34m- 351:     def breadth_first(self):[0m
[34m- 352:         '''Breadth first traversal of tree.'''[0m
[34m- 353:         q = Queue()[0m
[34m- 354:         q.enqueue(self.root)[0m
[34m- 355:         while q.peek():[0m
[34m- 356:             node = q.dequeue()[0m
[34m- 357:             yield node.val[0m
[34m- 358:             if node.left:[0m
[34m- 359:                 q.enqueue(node.left)[0m
[34m- 360:             if node.right:[0m
[34m- 361:                 q.enqueue(node.right)[0m
[34m- 362:     [0m
[32m+ 351:     @classmethod[0m
[32m+ 352:     def breadth_first(self):[0m
[32m+ 353:         '''Breadth first traversal of tree.'''[0m
[32m+ 354:         q = Queue()[0m
[32m+ 355:         q.enqueue(self.root)[0m
[32m+ 356:         while q.peek():[0m
[32m+ 357:             node = q.dequeue()[0m
[32m+ 358:             yield node.val[0m
[32m+ 359:             if node.left:[0m
[32m+ 360:                 q.enqueue(node.left)[0m
[32m+ 361:             if node.right:[0m
[32m+ 362:                 q.enqueue(node.right)[0m
  363:     def delete(self, val):
  364:         '''Remove a node from the tree.'''
  365:         if (self._size < 1 or not (self.contains(val))):
  366:             return
--------------------------------------------------------------------------------
[0.34127 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_41

def test_case_41():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.delete(bst_0)
        var_1 = bst_0.insert(var_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_2 = bst_0.breadth_first()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_2)

MIO/test_binarySearchTree3_MIO.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree3.Bst'>

>   ???
E   AttributeError: type object 'Bst' has no attribute 'root'

binarySearchTree3:355: AttributeError
[36m   -[0m [#  46] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  359:                 q.enqueue(node.left)
  360:             if node.right:
  361:                 q.enqueue(node.right)
  362:     
[34m- 363:     def delete(self, val):[0m
[34m- 364:         '''Remove a node from the tree.'''[0m
[34m- 365:         if (self._size < 1 or not (self.contains(val))):[0m
[34m- 366:             return[0m
[34m- 367:         [0m
[34m- 368:         node = self.search(val)[0m
[34m- 369:         [0m
[34m- 370:         if node._is_leaf():[0m
[34m- 371:             if node.parent:[0m
[34m- 372:                 setattr(node.parent, node._side(), None)[0m
[34m- 373:             else:[0m
[34m- 374:                 self.root = None[0m
[34m- 375:         [0m
[34m- 376:         elif node._is_interior():[0m
[34m- 377:             next_node = self._find_replacement(node)[0m
[34m- 378:             self._size += 1[0m
[34m- 379:             self.delete(next_node.val)[0m
[34m- 380:             node.val = next_node.val[0m
[34m- 381:         else:[0m
[34m- 382:             [0m
[34m- 383:             child = getattr(node, node._onlychild())[0m
[34m- 384:             if node.parent:[0m
[34m- 385:                 child.parent = node.parent[0m
[34m- 386:                 setattr(node.parent, node._side(), child)[0m
[34m- 387:             else:[0m
[34m- 388:                 self.root = child[0m
[34m- 389:         [0m
[34m- 390:         self._size -= 1[0m
[34m- 391:     [0m
[32m+ 363:     @classmethod[0m
[32m+ 364:     def delete(self, val):[0m
[32m+ 365:         '''Remove a node from the tree.'''[0m
[32m+ 366:         if (self._size < 1 or not (self.contains(val))):[0m
[32m+ 367:             return[0m
[32m+ 368:         [0m
[32m+ 369:         node = self.search(val)[0m
[32m+ 370:         [0m
[32m+ 371:         if node._is_leaf():[0m
[32m+ 372:             if node.parent:[0m
[32m+ 373:                 setattr(node.parent, node._side(), None)[0m
[32m+ 374:             else:[0m
[32m+ 375:                 self.root = None[0m
[32m+ 376:         [0m
[32m+ 377:         elif node._is_interior():[0m
[32m+ 378:             next_node = self._find_replacement(node)[0m
[32m+ 379:             self._size += 1[0m
[32m+ 380:             self.delete(next_node.val)[0m
[32m+ 381:             node.val = next_node.val[0m
[32m+ 382:         else:[0m
[32m+ 383:             [0m
[32m+ 384:             child = getattr(node, node._onlychild())[0m
[32m+ 385:             if node.parent:[0m
[32m+ 386:                 child.parent = node.parent[0m
[32m+ 387:                 setattr(node.parent, node._side(), child)[0m
[32m+ 388:             else:[0m
[32m+ 389:                 self.root = child[0m
[32m+ 390:         [0m
[32m+ 391:         self._size -= 1[0m
  392:     def _find_replacement(self, node):
  393:         '''Find left most node of right subtree.'''
  394:         if node.right:
  395:             return self._findmin(node.right)
--------------------------------------------------------------------------------
[0.21810 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_1 = bst_0.delete(bst_0)

MIO/test_binarySearchTree3_MIO.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree3.Bst'>
val = <binarySearchTree3.Bst object at 0x7f9b981829b0>

>   ???
E   AttributeError: type object 'Bst' has no attribute '_size'

binarySearchTree3:366: AttributeError
[36m   -[0m [#  47] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  388:                 self.root = child
  389:         
  390:         self._size -= 1
  391:     
[34m- 392:     def _find_replacement(self, node):[0m
[34m- 393:         '''Find left most node of right subtree.'''[0m
[34m- 394:         if node.right:[0m
[34m- 395:             return self._findmin(node.right)[0m
[34m- 396:         [0m
[34m- 397:         elif node.parent:[0m
[34m- 398:             if node._side() == 'left':[0m
[34m- 399:                 return self.parent[0m
[34m- 400:             else:[0m
[34m- 401:                 node.parent.right = None[0m
[34m- 402:                 tmp = self._find_replacement(node.parent)[0m
[34m- 403:                 node.parent.right = node[0m
[34m- 404:                 return tmp[0m
[34m- 405:     [0m
[32m+ 392:     @classmethod[0m
[32m+ 393:     def _find_replacement(self, node):[0m
[32m+ 394:         '''Find left most node of right subtree.'''[0m
[32m+ 395:         if node.right:[0m
[32m+ 396:             return self._findmin(node.right)[0m
[32m+ 397:         [0m
[32m+ 398:         elif node.parent:[0m
[32m+ 399:             if node._side() == 'left':[0m
[32m+ 400:                 return self.parent[0m
[32m+ 401:             else:[0m
[32m+ 402:                 node.parent.right = None[0m
[32m+ 403:                 tmp = self._find_replacement(node.parent)[0m
[32m+ 404:                 node.parent.right = node[0m
[32m+ 405:                 return tmp[0m
  406:     def _findmin(self, node):
  407:         '''Find min of subtree, Min is always left most node.'''
  408:         while node.left:
  409:             node = node.left
--------------------------------------------------------------------------------
[0.19227 s] [31msurvived[0m
[36m   -[0m [#  48] CDI binarySearchTree3: 
--------------------------------------------------------------------------------
  402:                 tmp = self._find_replacement(node.parent)
  403:                 node.parent.right = node
  404:                 return tmp
  405:     
[34m- 406:     def _findmin(self, node):[0m
[34m- 407:         '''Find min of subtree, Min is always left most node.'''[0m
[34m- 408:         while node.left:[0m
[34m- 409:             node = node.left[0m
[34m- 410:         return node[0m
[32m+ 406:     @classmethod[0m
[32m+ 407:     def _findmin(self, node):[0m
[32m+ 408:         '''Find min of subtree, Min is always left most node.'''[0m
[32m+ 409:         while node.left:[0m
[32m+ 410:             node = node.left[0m
[32m+ 411:         return node[0m
--------------------------------------------------------------------------------
[0.17871 s] [31msurvived[0m
[36m   -[0m [#  49] COD binarySearchTree3: 
--------------------------------------------------------------------------------
   43:         old_head = self.head
   44:         self.head = NodeDLL(val, next_node=old_head)
   45:         if old_head:
   46:             old_head.prev = self.head
[34m-  47:         if not (self.tail):[0m
[32m+  47:         if self.tail:[0m
   48:             self.tail = self.head
   49:         self._length += 1
   50:     
   51:     def pop(self):
--------------------------------------------------------------------------------
[0.18020 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_0

def test_case_0():
        bytes_0 = b'E\x9c\xce\xc8G'
        double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       assert f'{type(double_linked_list_0.tail).__module__}.{type(double_linked_list_0.tail).__qualname__}' == 'binarySearchTree3.NodeDLL'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:10: AssertionError
[36m   -[0m [#  50] COD binarySearchTree3: 
--------------------------------------------------------------------------------
  165:         self.height = 1
  166:     
  167:     def _is_leaf(self):
  168:         '''Return true if a leaf.'''
[34m- 169:         return not ((self.right or self.left))[0m
[32m+ 169:         return (self.right or self.left)[0m
  170:     
  171:     def _is_interior(self):
  172:         '''Return true if a interior node.'''
  173:         return (self.right and self.left)
--------------------------------------------------------------------------------
[0.31605 s] [36mincompetent[0m

TypeError: binarySearchTree3:383: TypeError: getattr(): attribute name must be string

[36m   -[0m [#  51] COD binarySearchTree3: 
--------------------------------------------------------------------------------
  173:         return (self.right and self.left)
  174:     
  175:     def _onlychild(self):
  176:         '''Return string depending on children.'''
[34m- 177:         if (self.left and not (self.right)):[0m
[32m+ 177:         if (self.left and self.right):[0m
  178:             return 'left'
  179:         if (self.right and not (self.left)):
  180:             return 'right'
  181:     
--------------------------------------------------------------------------------
[0.19092 s] [31msurvived[0m
[36m   -[0m [#  52] COD binarySearchTree3: 
--------------------------------------------------------------------------------
  175:     def _onlychild(self):
  176:         '''Return string depending on children.'''
  177:         if (self.left and not (self.right)):
  178:             return 'left'
[34m- 179:         if (self.right and not (self.left)):[0m
[32m+ 179:         if (self.right and self.left):[0m
  180:             return 'right'
  181:     
  182:     def _side(self):
  183:         '''Return if left or right child of parent.'''
--------------------------------------------------------------------------------
[0.18999 s] [31msurvived[0m
[36m   -[0m [#  53] COD binarySearchTree3: 
--------------------------------------------------------------------------------
  235:                 self.insert(i)
  236:     
  237:     def insert(self, val):
  238:         '''Insert val into BST. If val is already present will be ignored.'''
[34m- 239:         if not (self.root):[0m
[32m+ 239:         if self.root:[0m
  240:             self.root = Node(val)
  241:             self._size += 1
  242:         else:
  243:             self._step(val, self.root)
--------------------------------------------------------------------------------
[0.32374 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
>       var_0 = bst_0.insert(bst_0)

MIO/test_binarySearchTree3_MIO.py:176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:243: in insert
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98621510>
val = <binarySearchTree3.Bst object at 0x7f9b98621510>, curr = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'val'

binarySearchTree3:247: AttributeError
[36m   -[0m [#  54] COD binarySearchTree3: 
--------------------------------------------------------------------------------
  280:         return self._size
  281:     
  282:     def depth(self):
  283:         '''Return depth of the BST, representing total levels.'''
[34m- 284:         return 0 if not (self.root) else self.root.height[0m
[32m+ 284:         return 0 if self.root else self.root.height[0m
  285:     
  286:     def contains(self, val):
  287:         '''Return true if val is in the bst.'''
  288:         return self.search(val) is not None
--------------------------------------------------------------------------------
[0.22182 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_30

def test_case_30():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_1 = bst_0.depth()
>       assert var_1 == 1
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:243: AssertionError
[36m   -[0m [#  55] COD binarySearchTree3: 
--------------------------------------------------------------------------------
  294:         positive value, trees which are higher on the right than the left
  295:         should return a negative value. An ideally-balanced tree should
  296:         return 0.
  297:         '''
[34m- 298:         if not tree:[0m
[32m+ 298:         if tree:[0m
  299:             tree = self.root
  300:             if not tree:
  301:                 return 0
  302:         
--------------------------------------------------------------------------------
[0.20754 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_0 = bst_0.balance()

MIO/test_binarySearchTree3_MIO.py:257: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b989fee00>, tree = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'left'

binarySearchTree3:303: AttributeError
[36m   -[0m [#  56] COD binarySearchTree3: 
--------------------------------------------------------------------------------
  296:         return 0.
  297:         '''
  298:         if not tree:
  299:             tree = self.root
[34m- 300:             if not tree:[0m
[32m+ 300:             if tree:[0m
  301:                 return 0
  302:         
  303:         leftbranch = 0 if not (tree.left) else tree.left.height
  304:         rightbranch = 0 if not (tree.right) else tree.right.height
--------------------------------------------------------------------------------
[0.23286 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_0 = bst_0.balance()
>       assert var_0 == -1
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:258: AssertionError
[36m   -[0m [#  57] COD binarySearchTree3: 
--------------------------------------------------------------------------------
  299:             tree = self.root
  300:             if not tree:
  301:                 return 0
  302:         
[34m- 303:         leftbranch = 0 if not (tree.left) else tree.left.height[0m
[32m+ 303:         leftbranch = 0 if tree.left else tree.left.height[0m
  304:         rightbranch = 0 if not (tree.right) else tree.right.height
  305:         
  306:         return leftbranch - rightbranch
  307:     
--------------------------------------------------------------------------------
[0.22229 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_0 = bst_0.balance()
>       assert var_0 == -1
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:258: AssertionError
[36m   -[0m [#  58] COD binarySearchTree3: 
--------------------------------------------------------------------------------
  300:             if not tree:
  301:                 return 0
  302:         
  303:         leftbranch = 0 if not (tree.left) else tree.left.height
[34m- 304:         rightbranch = 0 if not (tree.right) else tree.right.height[0m
[32m+ 304:         rightbranch = 0 if tree.right else tree.right.height[0m
  305:         
  306:         return leftbranch - rightbranch
  307:     
  308:     def pre_order(self, node='root'):
--------------------------------------------------------------------------------
[0.33133 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_0 = bst_0.balance()
>       assert var_0 == -1
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:258: AssertionError
[36m   -[0m [#  59] COD binarySearchTree3: 
--------------------------------------------------------------------------------
  309:         '''Depth first pre-order traversal of tree.'''
  310:         if node == 'root':
  311:             node = self.root
  312:         
[34m- 313:         if not node:[0m
[32m+ 313:         if node:[0m
  314:             return
  315:         
  316:         yield node.val
  317:         
--------------------------------------------------------------------------------
[0.22442 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_36

def test_case_36():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.pre_order()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98271300>, node = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'val'

binarySearchTree3:316: AttributeError
[36m   -[0m [#  60] COD binarySearchTree3: 
--------------------------------------------------------------------------------
  324:         '''Depth first in-order traversal of tree.'''
  325:         if node == 'root':
  326:             node = self.root
  327:         
[34m- 328:         if not node:[0m
[32m+ 328:         if node:[0m
  329:             return
  330:         
  331:         for n in self.in_order(node=node.left):
  332:             yield n
--------------------------------------------------------------------------------
[0.22160 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_38

def test_case_38():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.in_order()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:306: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98863370>, node = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'left'

binarySearchTree3:331: AttributeError
[36m   -[0m [#  61] COD binarySearchTree3: 
--------------------------------------------------------------------------------
  338:         '''Depth frist post_order traversal of tree.'''
  339:         if node == 'root':
  340:             node = self.root
  341:         
[34m- 342:         if not node:[0m
[32m+ 342:         if node:[0m
  343:             return
  344:         
  345:         for n in self.post_order(node=node.left):
  346:             yield n
--------------------------------------------------------------------------------
[0.33846 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_39

def test_case_39():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.post_order()
        var_1 = bst_0.size()
        assert var_1 == 0
        var_2 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        double_linked_list_0 = module_0.DoubleLinkedList(var_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
>       assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:322: AssertionError
[36m   -[0m [#  62] COD binarySearchTree3: 
--------------------------------------------------------------------------------
  361:                 q.enqueue(node.right)
  362:     
  363:     def delete(self, val):
  364:         '''Remove a node from the tree.'''
[34m- 365:         if (self._size < 1 or not (self.contains(val))):[0m
[32m+ 365:         if (self._size < 1 or self.contains(val)):[0m
  366:             return
  367:         
  368:         node = self.search(val)
  369:         
--------------------------------------------------------------------------------
[0.22094 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_1 = bst_0.delete(bst_0)
>       assert bst_0.root is None
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:179: AssertionError
[36m   -[0m [#  63] COI binarySearchTree3: 
--------------------------------------------------------------------------------
   34:         try:
   35:             for val in data:
   36:                 self.push(val)
   37:         except TypeError:
[34m-  38:             if data:[0m
[32m+  38:             if not data:[0m
   39:                 self.push(data)
   40:     
   41:     def push(self, val):
   42:         '''Add val to the head of the list.'''
--------------------------------------------------------------------------------
[0.17835 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_1

def test_case_1():
        node_0 = module_0.Node()
        assert node_0.height == 1
        double_linked_list_0 = module_0.DoubleLinkedList(node_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
>       assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:17: AssertionError
[36m   -[0m [#  64] COI binarySearchTree3: 
--------------------------------------------------------------------------------
   41:     def push(self, val):
   42:         '''Add val to the head of the list.'''
   43:         old_head = self.head
   44:         self.head = NodeDLL(val, next_node=old_head)
[34m-  45:         if old_head:[0m
[32m+  45:         if not old_head:[0m
   46:             old_head.prev = self.head
   47:         if not (self.tail):
   48:             self.tail = self.head
   49:         self._length += 1
--------------------------------------------------------------------------------
[0.19481 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_0

def test_case_0():
        bytes_0 = b'E\x9c\xce\xc8G'
>       double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)

MIO/test_binarySearchTree3_MIO.py:7: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:36: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98ac84c0>, val = 69

>   ???
E   AttributeError: 'NoneType' object has no attribute 'prev'

binarySearchTree3:46: AttributeError
[36m   -[0m [#  65] COI binarySearchTree3: 
--------------------------------------------------------------------------------
   43:         old_head = self.head
   44:         self.head = NodeDLL(val, next_node=old_head)
   45:         if old_head:
   46:             old_head.prev = self.head
[34m-  47:         if not (self.tail):[0m
[32m+  47:         if not ((not (self.tail))):[0m
   48:             self.tail = self.head
   49:         self._length += 1
   50:     
   51:     def pop(self):
--------------------------------------------------------------------------------
[0.19669 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_0

def test_case_0():
        bytes_0 = b'E\x9c\xce\xc8G'
        double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       assert f'{type(double_linked_list_0.tail).__module__}.{type(double_linked_list_0.tail).__qualname__}' == 'binarySearchTree3.NodeDLL'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:10: AssertionError
[36m   -[0m [#  66] COI binarySearchTree3: 
--------------------------------------------------------------------------------
   50:     
   51:     def pop(self):
   52:         '''Remove the val from the head of the list.'''
   53:         to_return = self.head
[34m-  54:         if self._length < 1:[0m
[32m+  54:         if not (self._length < 1):[0m
   55:             raise IndexError('Cannot pop from an empty list.')
   56:         
   57:         new_head = self.head.next
   58:         if new_head:
--------------------------------------------------------------------------------
[0.29554 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_4

def test_case_4():
        str_0 = 'aX}B^sw\x0cA!<Uq;!!D9'
        queue_0 = module_0.Queue(str_0)
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.dequeue()

MIO/test_binarySearchTree3_MIO.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:143: in dequeue
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b983ae0e0>

>   ???
E   IndexError: Cannot pop from an empty list.

binarySearchTree3:55: IndexError
[36m   -[0m [#  67] COI binarySearchTree3: 
--------------------------------------------------------------------------------
   54:         if self._length < 1:
   55:             raise IndexError('Cannot pop from an empty list.')
   56:         
   57:         new_head = self.head.next
[34m-  58:         if new_head:[0m
[32m+  58:         if not new_head:[0m
   59:             new_head.prev = None
   60:         self.head = new_head
   61:         self._length -= 1
   62:         if self._length < 1:
--------------------------------------------------------------------------------
[0.20105 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_5

def test_case_5():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        queue_0 = module_0.Queue(bst_0)
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.dequeue()

MIO/test_binarySearchTree3_MIO.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:143: in dequeue
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b9886aa10>

>   ???
E   AttributeError: 'NoneType' object has no attribute 'prev'

binarySearchTree3:59: AttributeError
[36m   -[0m [#  68] COI binarySearchTree3: 
--------------------------------------------------------------------------------
   58:         if new_head:
   59:             new_head.prev = None
   60:         self.head = new_head
   61:         self._length -= 1
[34m-  62:         if self._length < 1:[0m
[32m+  62:         if not (self._length < 1):[0m
   63:             self.tail = None
   64:         return to_return.data
   65:     
   66:     def append(self, val):
--------------------------------------------------------------------------------
[0.20254 s] [31msurvived[0m
[36m   -[0m [#  69] COI binarySearchTree3: 
--------------------------------------------------------------------------------
   66:     def append(self, val):
   67:         '''Add val to the tail of the list.'''
   68:         old_tail = self.tail
   69:         self.tail = NodeDLL(val, prev=old_tail)
[34m-  70:         if old_tail:[0m
[32m+  70:         if not old_tail:[0m
   71:             old_tail.next = self.tail
   72:         if self._length < 1:
   73:             self.head = self.tail
   74:         self._length += 1
--------------------------------------------------------------------------------
[0.32747 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_7

def test_case_7():
        queue_0 = module_0.Queue()
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.enqueue(queue_0)

MIO/test_binarySearchTree3_MIO.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:139: in enqueue
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b9888f4c0>
val = <binarySearchTree3.Queue object at 0x7f9b9888f490>

>   ???
E   AttributeError: 'NoneType' object has no attribute 'next'

binarySearchTree3:71: AttributeError
[36m   -[0m [#  70] COI binarySearchTree3: 
--------------------------------------------------------------------------------
   68:         old_tail = self.tail
   69:         self.tail = NodeDLL(val, prev=old_tail)
   70:         if old_tail:
   71:             old_tail.next = self.tail
[34m-  72:         if self._length < 1:[0m
[32m+  72:         if not (self._length < 1):[0m
   73:             self.head = self.tail
   74:         self._length += 1
   75:     
   76:     def shift(self):
--------------------------------------------------------------------------------
[0.20740 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_12

def test_case_12():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.append(double_linked_list_0)
>       assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:103: AssertionError
[36m   -[0m [#  71] COI binarySearchTree3: 
--------------------------------------------------------------------------------
   75:     
   76:     def shift(self):
   77:         '''Remove the val from the tail of the list.'''
   78:         to_return = self.tail
[34m-  79:         if self._length < 1:[0m
[32m+  79:         if not (self._length < 1):[0m
   80:             raise IndexError('Cannot shift from an empty list.')
   81:         
   82:         new_tail = self.tail.prev
   83:         if new_tail:
--------------------------------------------------------------------------------
[0.20461 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_9

def test_case_9():
        bytes_0 = b'@\x95\xef|X\x9c\x0b\xbd\x9d\xbd\x9d)\x19\xa9'
        double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
        assert f'{type(double_linked_list_0.tail).__module__}.{type(double_linked_list_0.tail).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_0 = double_linked_list_0.shift()

MIO/test_binarySearchTree3_MIO.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b989becb0>

>   ???
E   IndexError: Cannot shift from an empty list.

binarySearchTree3:80: IndexError
[36m   -[0m [#  72] COI binarySearchTree3: 
--------------------------------------------------------------------------------
   79:         if self._length < 1:
   80:             raise IndexError('Cannot shift from an empty list.')
   81:         
   82:         new_tail = self.tail.prev
[34m-  83:         if new_tail:[0m
[32m+  83:         if not new_tail:[0m
   84:             new_tail.next = None
   85:         self.tail = new_tail
   86:         self._length -= 1
   87:         if self._length < 1:
--------------------------------------------------------------------------------
[0.20471 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_10

def test_case_10():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        double_linked_list_0 = module_0.DoubleLinkedList(bst_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
        assert f'{type(double_linked_list_0.tail).__module__}.{type(double_linked_list_0.tail).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_0 = double_linked_list_0.shift()

MIO/test_binarySearchTree3_MIO.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98272d70>

>   ???
E   AttributeError: 'NoneType' object has no attribute 'next'

binarySearchTree3:84: AttributeError
[36m   -[0m [#  73] COI binarySearchTree3: 
--------------------------------------------------------------------------------
   83:         if new_tail:
   84:             new_tail.next = None
   85:         self.tail = new_tail
   86:         self._length -= 1
[34m-  87:         if self._length < 1:[0m
[32m+  87:         if not (self._length < 1):[0m
   88:             self.tail = None
   89:         return to_return.data
   90:     
   91:     def remove(self, val):
--------------------------------------------------------------------------------
[0.19982 s] [31msurvived[0m
[36m   -[0m [#  74] COI binarySearchTree3: 
--------------------------------------------------------------------------------
   90:     
   91:     def remove(self, val):
   92:         '''Remove first occurance of val from list.'''
   93:         curr = self.head
[34m-  94:         while curr:[0m
[32m+  94:         while not curr:[0m
   95:             if curr.data is val:
   96:                 if self._length == 1:
   97:                     (self.head, self.tail) = (None, None)
   98:                 elif (curr is not self.head and curr is not self.tail):
--------------------------------------------------------------------------------
[0.32451 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_12

def test_case_12():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.append(double_linked_list_0)
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_1 = double_linked_list_0.remove(double_linked_list_0)

MIO/test_binarySearchTree3_MIO.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98985420>
val = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98985420>

>   ???
E   ValueError: <binarySearchTree3.DoubleLinkedList object at 0x7f9b98985420> is not in the list

binarySearchTree3:108: ValueError
[36m   -[0m [#  75] COI binarySearchTree3: 
--------------------------------------------------------------------------------
   91:     def remove(self, val):
   92:         '''Remove first occurance of val from list.'''
   93:         curr = self.head
   94:         while curr:
[34m-  95:             if curr.data is val:[0m
[32m+  95:             if not (curr.data is val):[0m
   96:                 if self._length == 1:
   97:                     (self.head, self.tail) = (None, None)
   98:                 elif (curr is not self.head and curr is not self.tail):
   99:                     (curr.next.prev, curr.prev.next) = (curr.prev, curr.next)
--------------------------------------------------------------------------------
[0.20738 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_12

def test_case_12():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.append(double_linked_list_0)
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_1 = double_linked_list_0.remove(double_linked_list_0)

MIO/test_binarySearchTree3_MIO.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98aa2f50>
val = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98aa2f50>

>   ???
E   ValueError: <binarySearchTree3.DoubleLinkedList object at 0x7f9b98aa2f50> is not in the list

binarySearchTree3:108: ValueError
[36m   -[0m [#  76] COI binarySearchTree3: 
--------------------------------------------------------------------------------
   92:         '''Remove first occurance of val from list.'''
   93:         curr = self.head
   94:         while curr:
   95:             if curr.data is val:
[34m-  96:                 if self._length == 1:[0m
[32m+  96:                 if not (self._length == 1):[0m
   97:                     (self.head, self.tail) = (None, None)
   98:                 elif (curr is not self.head and curr is not self.tail):
   99:                     (curr.next.prev, curr.prev.next) = (curr.prev, curr.next)
  100:                 elif curr is self.head:
--------------------------------------------------------------------------------
[0.19130 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_12

def test_case_12():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.append(double_linked_list_0)
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_1 = double_linked_list_0.remove(double_linked_list_0)

MIO/test_binarySearchTree3_MIO.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b987f8190>
val = <binarySearchTree3.DoubleLinkedList object at 0x7f9b987f8190>

>   ???
E   AttributeError: 'NoneType' object has no attribute 'prev'

binarySearchTree3:101: AttributeError
[36m   -[0m [#  77] COI binarySearchTree3: 
--------------------------------------------------------------------------------
   94:         while curr:
   95:             if curr.data is val:
   96:                 if self._length == 1:
   97:                     (self.head, self.tail) = (None, None)
[34m-  98:                 elif (curr is not self.head and curr is not self.tail):[0m
[32m+  98:                 elif not ((curr is not self.head and curr is not self.tail)):[0m
   99:                     (curr.next.prev, curr.prev.next) = (curr.prev, curr.next)
  100:                 elif curr is self.head:
  101:                     (self.head, curr.next.prev) = (curr.next, None)
  102:                 elif curr is self.tail:
--------------------------------------------------------------------------------
[0.32084 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_13

def test_case_13():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.append(double_linked_list_0)
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
        var_1 = double_linked_list_0.append(var_0)
>       var_2 = double_linked_list_0.remove(double_linked_list_0)

MIO/test_binarySearchTree3_MIO.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b984a42e0>
val = <binarySearchTree3.DoubleLinkedList object at 0x7f9b984a42e0>

>   ???
E   AttributeError: 'NoneType' object has no attribute 'next'

binarySearchTree3:99: AttributeError
[36m   -[0m [#  78] COI binarySearchTree3: 
--------------------------------------------------------------------------------
   96:                 if self._length == 1:
   97:                     (self.head, self.tail) = (None, None)
   98:                 elif (curr is not self.head and curr is not self.tail):
   99:                     (curr.next.prev, curr.prev.next) = (curr.prev, curr.next)
[34m- 100:                 elif curr is self.head:[0m
[32m+ 100:                 elif not (curr is self.head):[0m
  101:                     (self.head, curr.next.prev) = (curr.next, None)
  102:                 elif curr is self.tail:
  103:                     (self.tail, curr.prev.next) = (curr.prev, None)
  104:                 self._length -= 1
--------------------------------------------------------------------------------
[0.21432 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_14

def test_case_14():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.push(double_linked_list_0)
        assert f'{type(double_linked_list_0.tail).__module__}.{type(double_linked_list_0.tail).__qualname__}' == 'binarySearchTree3.NodeDLL'
        var_1 = double_linked_list_0.push(var_0)
>       var_2 = double_linked_list_0.remove(double_linked_list_0)

MIO/test_binarySearchTree3_MIO.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98458d90>
val = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98458d90>

>   ???
E   AttributeError: 'NoneType' object has no attribute 'prev'

binarySearchTree3:101: AttributeError
[36m   -[0m [#  79] COI binarySearchTree3: 
--------------------------------------------------------------------------------
   98:                 elif (curr is not self.head and curr is not self.tail):
   99:                     (curr.next.prev, curr.prev.next) = (curr.prev, curr.next)
  100:                 elif curr is self.head:
  101:                     (self.head, curr.next.prev) = (curr.next, None)
[34m- 102:                 elif curr is self.tail:[0m
[32m+ 102:                 elif not (curr is self.tail):[0m
  103:                     (self.tail, curr.prev.next) = (curr.prev, None)
  104:                 self._length -= 1
  105:                 return
  106:             curr = curr.next
--------------------------------------------------------------------------------
[0.19477 s] [31msurvived[0m
[36m   -[0m [#  80] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  109:     
  110:     def _repr(self):
  111:         '''Return list representation of dll.'''
  112:         l = []
[34m- 113:         while True:[0m
[32m+ 113:         while not True:[0m
  114:             try:
  115:                 popped_data = self.pop()
  116:                 l.append(popped_data)
  117:             except IndexError:
--------------------------------------------------------------------------------
[0.20102 s] [31msurvived[0m
[36m   -[0m [#  81] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  173:         return (self.right and self.left)
  174:     
  175:     def _onlychild(self):
  176:         '''Return string depending on children.'''
[34m- 177:         if (self.left and not (self.right)):[0m
[32m+ 177:         if not ((self.left and not (self.right))):[0m
  178:             return 'left'
  179:         if (self.right and not (self.left)):
  180:             return 'right'
  181:     
--------------------------------------------------------------------------------
[0.19881 s] [31msurvived[0m
[36m   -[0m [#  82] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  175:     def _onlychild(self):
  176:         '''Return string depending on children.'''
  177:         if (self.left and not (self.right)):
  178:             return 'left'
[34m- 179:         if (self.right and not (self.left)):[0m
[32m+ 179:         if not ((self.right and not (self.left))):[0m
  180:             return 'right'
  181:     
  182:     def _side(self):
  183:         '''Return if left or right child of parent.'''
--------------------------------------------------------------------------------
[0.31494 s] [31msurvived[0m
[36m   -[0m [#  83] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  180:             return 'right'
  181:     
  182:     def _side(self):
  183:         '''Return if left or right child of parent.'''
[34m- 184:         if self.parent:[0m
[32m+ 184:         if not (self.parent):[0m
  185:             return 'left' if self.parent.left == self else 'right'
  186: 
  187: 
  188: class Bst(object):
--------------------------------------------------------------------------------
[0.19829 s] [31msurvived[0m
[36m   -[0m [#  84] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  229:         '''Initialize tree.'''
  230:         self._size = 0
  231:         self.root = None
  232:         
[34m- 233:         if data:[0m
[32m+ 233:         if not data:[0m
  234:             for i in data:
  235:                 self.insert(i)
  236:     
  237:     def insert(self, val):
--------------------------------------------------------------------------------
[0.19801 s] [36mincompetent[0m

TypeError: binarySearchTree3:234: TypeError: 'NoneType' object is not iterable

[36m   -[0m [#  85] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  235:                 self.insert(i)
  236:     
  237:     def insert(self, val):
  238:         '''Insert val into BST. If val is already present will be ignored.'''
[34m- 239:         if not (self.root):[0m
[32m+ 239:         if not ((not (self.root))):[0m
  240:             self.root = Node(val)
  241:             self._size += 1
  242:         else:
  243:             self._step(val, self.root)
--------------------------------------------------------------------------------
[0.21346 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
>       var_0 = bst_0.insert(bst_0)

MIO/test_binarySearchTree3_MIO.py:176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:243: in insert
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b982d2590>
val = <binarySearchTree3.Bst object at 0x7f9b982d2590>, curr = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'val'

binarySearchTree3:247: AttributeError
[36m   -[0m [#  86] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  243:             self._step(val, self.root)
  244:     
  245:     def _step(self, val, curr):
  246:         '''Decide left or right and returns height.'''
[34m- 247:         if val < curr.val:[0m
[32m+ 247:         if not (val < curr.val):[0m
  248:             curr = self._set_child(curr, 'left', val)
  249:         elif val > curr.val:
  250:             curr = self._set_child(curr, 'right', val)
  251:         return curr.height
--------------------------------------------------------------------------------
[0.23268 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_0 = bst_0.balance()
>       assert var_0 == -1
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:258: AssertionError
[36m   -[0m [#  87] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  245:     def _step(self, val, curr):
  246:         '''Decide left or right and returns height.'''
  247:         if val < curr.val:
  248:             curr = self._set_child(curr, 'left', val)
[34m- 249:         elif val > curr.val:[0m
[32m+ 249:         elif not (val > curr.val):[0m
  250:             curr = self._set_child(curr, 'right', val)
  251:         return curr.height
  252:     
  253:     def _set_child(self, curr, side, val):
--------------------------------------------------------------------------------
[0.23142 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_0 = bst_0.balance()
>       assert var_0 == -1
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:258: AssertionError
[36m   -[0m [#  88] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  252:     
  253:     def _set_child(self, curr, side, val):
  254:         '''Helping.'''
  255:         child = getattr(curr, side)
[34m- 256:         if child:[0m
[32m+ 256:         if not child:[0m
  257:             count = self._step(val, child)
  258:             if curr.height <= count:
  259:                 curr.height += 1
  260:         else:
--------------------------------------------------------------------------------
[0.21762 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_21

def test_case_21():
        bytes_0 = b'z\xc7'
>       bst_0 = module_0.Bst(bytes_0)

MIO/test_binarySearchTree3_MIO.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:235: in __init__
    ???
binarySearchTree3:243: in insert
    ???
binarySearchTree3:250: in _step
    ???
binarySearchTree3:257: in _set_child
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98644d30>, val = 199, curr = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'val'

binarySearchTree3:247: AttributeError
[36m   -[0m [#  89] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  254:         '''Helping.'''
  255:         child = getattr(curr, side)
  256:         if child:
  257:             count = self._step(val, child)
[34m- 258:             if curr.height <= count:[0m
[32m+ 258:             if not (curr.height <= count):[0m
  259:                 curr.height += 1
  260:         else:
  261:             setattr(curr, side, Node(val, curr))
  262:             self._size += 1
--------------------------------------------------------------------------------
[0.23114 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_0 = bst_0.balance()
>       assert var_0 == -1
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:258: AssertionError
[36m   -[0m [#  90] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  259:                 curr.height += 1
  260:         else:
  261:             setattr(curr, side, Node(val, curr))
  262:             self._size += 1
[34m- 263:             if curr.height == 1:[0m
[32m+ 263:             if not (curr.height == 1):[0m
  264:                 curr.height += 1
  265:         return curr
  266:     
  267:     def search(self, val):
--------------------------------------------------------------------------------
[0.30830 s] [31msurvived[0m
[36m   -[0m [#  91] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  266:     
  267:     def search(self, val):
  268:         '''Return the node containing val.'''
  269:         curr = self.root
[34m- 270:         while curr:[0m
[32m+ 270:         while not curr:[0m
  271:             if curr.val == val:
  272:                 return curr
  273:             elif val < curr.val:
  274:                 curr = curr.left
--------------------------------------------------------------------------------
[0.21781 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_1 = bst_0.delete(bst_0)
>       assert bst_0.root is None
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:179: AssertionError
[36m   -[0m [#  92] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  267:     def search(self, val):
  268:         '''Return the node containing val.'''
  269:         curr = self.root
  270:         while curr:
[34m- 271:             if curr.val == val:[0m
[32m+ 271:             if not (curr.val == val):[0m
  272:                 return curr
  273:             elif val < curr.val:
  274:                 curr = curr.left
  275:             else:
--------------------------------------------------------------------------------
[0.21672 s] [36mincompetent[0m

TypeError: binarySearchTree3:273: TypeError: '<' not supported between instances of 'Bst' and 'Bst'

[36m   -[0m [#  93] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  269:         curr = self.root
  270:         while curr:
  271:             if curr.val == val:
  272:                 return curr
[34m- 273:             elif val < curr.val:[0m
[32m+ 273:             elif not (val < curr.val):[0m
  274:                 curr = curr.left
  275:             else:
  276:                 curr = curr.right
  277:     
--------------------------------------------------------------------------------
[0.19786 s] [31msurvived[0m
[36m   -[0m [#  94] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  294:         positive value, trees which are higher on the right than the left
  295:         should return a negative value. An ideally-balanced tree should
  296:         return 0.
  297:         '''
[34m- 298:         if not tree:[0m
[32m+ 298:         if not ((not tree)):[0m
  299:             tree = self.root
  300:             if not tree:
  301:                 return 0
  302:         
--------------------------------------------------------------------------------
[0.22720 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_0 = bst_0.balance()

MIO/test_binarySearchTree3_MIO.py:257: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98645750>, tree = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'left'

binarySearchTree3:303: AttributeError
[36m   -[0m [#  95] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  296:         return 0.
  297:         '''
  298:         if not tree:
  299:             tree = self.root
[34m- 300:             if not tree:[0m
[32m+ 300:             if not ((not tree)):[0m
  301:                 return 0
  302:         
  303:         leftbranch = 0 if not (tree.left) else tree.left.height
  304:         rightbranch = 0 if not (tree.right) else tree.right.height
--------------------------------------------------------------------------------
[0.23260 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_0 = bst_0.balance()
>       assert var_0 == -1
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:258: AssertionError
[36m   -[0m [#  96] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  306:         return leftbranch - rightbranch
  307:     
  308:     def pre_order(self, node='root'):
  309:         '''Depth first pre-order traversal of tree.'''
[34m- 310:         if node == 'root':[0m
[32m+ 310:         if not (node == 'root'):[0m
  311:             node = self.root
  312:         
  313:         if not node:
  314:             return
--------------------------------------------------------------------------------
[0.23104 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_36

def test_case_36():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.pre_order()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98645240>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'val'

binarySearchTree3:316: AttributeError
[36m   -[0m [#  97] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  309:         '''Depth first pre-order traversal of tree.'''
  310:         if node == 'root':
  311:             node = self.root
  312:         
[34m- 313:         if not node:[0m
[32m+ 313:         if not ((not node)):[0m
  314:             return
  315:         
  316:         yield node.val
  317:         
--------------------------------------------------------------------------------
[0.22721 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_36

def test_case_36():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.pre_order()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98316020>, node = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'val'

binarySearchTree3:316: AttributeError
[36m   -[0m [#  98] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  321:             yield n
  322:     
  323:     def in_order(self, node='root'):
  324:         '''Depth first in-order traversal of tree.'''
[34m- 325:         if node == 'root':[0m
[32m+ 325:         if not (node == 'root'):[0m
  326:             node = self.root
  327:         
  328:         if not node:
  329:             return
--------------------------------------------------------------------------------
[0.34213 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_38

def test_case_38():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.in_order()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:306: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b9820a6b0>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

binarySearchTree3:331: AttributeError
[36m   -[0m [#  99] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  324:         '''Depth first in-order traversal of tree.'''
  325:         if node == 'root':
  326:             node = self.root
  327:         
[34m- 328:         if not node:[0m
[32m+ 328:         if not ((not node)):[0m
  329:             return
  330:         
  331:         for n in self.in_order(node=node.left):
  332:             yield n
--------------------------------------------------------------------------------
[0.23442 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_38

def test_case_38():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.in_order()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:306: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b983a0df0>, node = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'left'

binarySearchTree3:331: AttributeError
[36m   -[0m [# 100] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  335:             yield n
  336:     
  337:     def post_order(self, node='root'):
  338:         '''Depth frist post_order traversal of tree.'''
[34m- 339:         if node == 'root':[0m
[32m+ 339:         if not (node == 'root'):[0m
  340:             node = self.root
  341:         
  342:         if not node:
  343:             return
--------------------------------------------------------------------------------
[0.23439 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_39

def test_case_39():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.post_order()
        var_1 = bst_0.size()
        assert var_1 == 0
        var_2 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:320: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b987a41c0>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

binarySearchTree3:345: AttributeError
[36m   -[0m [# 101] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  338:         '''Depth frist post_order traversal of tree.'''
  339:         if node == 'root':
  340:             node = self.root
  341:         
[34m- 342:         if not node:[0m
[32m+ 342:         if not ((not node)):[0m
  343:             return
  344:         
  345:         for n in self.post_order(node=node.left):
  346:             yield n
--------------------------------------------------------------------------------
[0.21469 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_39

def test_case_39():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.post_order()
        var_1 = bst_0.size()
        assert var_1 == 0
        var_2 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        double_linked_list_0 = module_0.DoubleLinkedList(var_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
>       assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:322: AssertionError
[36m   -[0m [# 102] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  351:     def breadth_first(self):
  352:         '''Breadth first traversal of tree.'''
  353:         q = Queue()
  354:         q.enqueue(self.root)
[34m- 355:         while q.peek():[0m
[32m+ 355:         while not (q.peek()):[0m
  356:             node = q.dequeue()
  357:             yield node.val
  358:             if node.left:
  359:                 q.enqueue(node.left)
--------------------------------------------------------------------------------
[0.23738 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_41

def test_case_41():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.delete(bst_0)
        var_1 = bst_0.insert(var_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_2 = bst_0.breadth_first()
        double_linked_list_0 = module_0.DoubleLinkedList(var_2)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
>       assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:345: AssertionError
[36m   -[0m [# 103] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  354:         q.enqueue(self.root)
  355:         while q.peek():
  356:             node = q.dequeue()
  357:             yield node.val
[34m- 358:             if node.left:[0m
[32m+ 358:             if not (node.left):[0m
  359:                 q.enqueue(node.left)
  360:             if node.right:
  361:                 q.enqueue(node.right)
  362:     
--------------------------------------------------------------------------------
[0.19975 s] [31msurvived[0m
[36m   -[0m [# 104] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  356:             node = q.dequeue()
  357:             yield node.val
  358:             if node.left:
  359:                 q.enqueue(node.left)
[34m- 360:             if node.right:[0m
[32m+ 360:             if not (node.right):[0m
  361:                 q.enqueue(node.right)
  362:     
  363:     def delete(self, val):
  364:         '''Remove a node from the tree.'''
--------------------------------------------------------------------------------
[0.18101 s] [31msurvived[0m
[36m   -[0m [# 105] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  361:                 q.enqueue(node.right)
  362:     
  363:     def delete(self, val):
  364:         '''Remove a node from the tree.'''
[34m- 365:         if (self._size < 1 or not (self.contains(val))):[0m
[32m+ 365:         if not ((self._size < 1 or not (self.contains(val)))):[0m
  366:             return
  367:         
  368:         node = self.search(val)
  369:         
--------------------------------------------------------------------------------
[0.22154 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_1 = bst_0.delete(bst_0)
>       assert bst_0.root is None
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:179: AssertionError
[36m   -[0m [# 106] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  366:             return
  367:         
  368:         node = self.search(val)
  369:         
[34m- 370:         if node._is_leaf():[0m
[32m+ 370:         if not (node._is_leaf()):[0m
  371:             if node.parent:
  372:                 setattr(node.parent, node._side(), None)
  373:             else:
  374:                 self.root = None
--------------------------------------------------------------------------------
[0.30832 s] [36mincompetent[0m

TypeError: binarySearchTree3:383: TypeError: getattr(): attribute name must be string

[36m   -[0m [# 107] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  367:         
  368:         node = self.search(val)
  369:         
  370:         if node._is_leaf():
[34m- 371:             if node.parent:[0m
[32m+ 371:             if not (node.parent):[0m
  372:                 setattr(node.parent, node._side(), None)
  373:             else:
  374:                 self.root = None
  375:         
--------------------------------------------------------------------------------
[0.21514 s] [36mincompetent[0m

TypeError: binarySearchTree3:372: TypeError: attribute name must be string, not 'NoneType'

[36m   -[0m [# 108] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  372:                 setattr(node.parent, node._side(), None)
  373:             else:
  374:                 self.root = None
  375:         
[34m- 376:         elif node._is_interior():[0m
[32m+ 376:         elif not (node._is_interior()):[0m
  377:             next_node = self._find_replacement(node)
  378:             self._size += 1
  379:             self.delete(next_node.val)
  380:             node.val = next_node.val
--------------------------------------------------------------------------------
[0.18338 s] [31msurvived[0m
[36m   -[0m [# 109] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  380:             node.val = next_node.val
  381:         else:
  382:             
  383:             child = getattr(node, node._onlychild())
[34m- 384:             if node.parent:[0m
[32m+ 384:             if not (node.parent):[0m
  385:                 child.parent = node.parent
  386:                 setattr(node.parent, node._side(), child)
  387:             else:
  388:                 self.root = child
--------------------------------------------------------------------------------
[0.19925 s] [31msurvived[0m
[36m   -[0m [# 110] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  390:         self._size -= 1
  391:     
  392:     def _find_replacement(self, node):
  393:         '''Find left most node of right subtree.'''
[34m- 394:         if node.right:[0m
[32m+ 394:         if not (node.right):[0m
  395:             return self._findmin(node.right)
  396:         
  397:         elif node.parent:
  398:             if node._side() == 'left':
--------------------------------------------------------------------------------
[0.20280 s] [31msurvived[0m
[36m   -[0m [# 111] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  393:         '''Find left most node of right subtree.'''
  394:         if node.right:
  395:             return self._findmin(node.right)
  396:         
[34m- 397:         elif node.parent:[0m
[32m+ 397:         elif not (node.parent):[0m
  398:             if node._side() == 'left':
  399:                 return self.parent
  400:             else:
  401:                 node.parent.right = None
--------------------------------------------------------------------------------
[0.19992 s] [31msurvived[0m
[36m   -[0m [# 112] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  394:         if node.right:
  395:             return self._findmin(node.right)
  396:         
  397:         elif node.parent:
[34m- 398:             if node._side() == 'left':[0m
[32m+ 398:             if not (node._side() == 'left'):[0m
  399:                 return self.parent
  400:             else:
  401:                 node.parent.right = None
  402:                 tmp = self._find_replacement(node.parent)
--------------------------------------------------------------------------------
[0.20090 s] [31msurvived[0m
[36m   -[0m [# 113] COI binarySearchTree3: 
--------------------------------------------------------------------------------
  404:                 return tmp
  405:     
  406:     def _findmin(self, node):
  407:         '''Find min of subtree, Min is always left most node.'''
[34m- 408:         while node.left:[0m
[32m+ 408:         while not (node.left):[0m
  409:             node = node.left
  410:         return node
--------------------------------------------------------------------------------
[0.20263 s] [31msurvived[0m
[36m   -[0m [# 114] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
   10:         self.prev = prev
   11:     
   12:     def __repr__(self):
   13:         '''String representation.'''
[34m-  14:         return 'Value: {}'.format(self.data)[0m
[32m+  14:         return 'mutpy'.format(self.data)[0m
   15: 
   16: 
   17: class DoubleLinkedList(object):
   18:     '''Double linked list impplementation.
--------------------------------------------------------------------------------
[0.36413 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_45

def test_case_45():
        node_d_l_l_0 = module_0.NodeDLL()
        var_0 = node_d_l_l_0.__repr__()
>       assert var_0 == 'Value: None'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:370: AssertionError
[36m   -[0m [# 115] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
   10:         self.prev = prev
   11:     
   12:     def __repr__(self):
   13:         '''String representation.'''
[34m-  14:         return 'Value: {}'.format(self.data)[0m
[32m+  14:         return ''.format(self.data)[0m
   15: 
   16: 
   17: class DoubleLinkedList(object):
   18:     '''Double linked list impplementation.
--------------------------------------------------------------------------------
[0.24049 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_45

def test_case_45():
        node_d_l_l_0 = module_0.NodeDLL()
        var_0 = node_d_l_l_0.__repr__()
>       assert var_0 == 'Value: None'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:370: AssertionError
[36m   -[0m [# 116] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
   29:     def __init__(self, data=None):
   30:         '''Initialize list.'''
   31:         self.head = None
   32:         self.tail = None
[34m-  33:         self._length = 0[0m
[32m+  33:         self._length = 1[0m
   34:         try:
   35:             for val in data:
   36:                 self.push(val)
   37:         except TypeError:
--------------------------------------------------------------------------------
[0.21040 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_11

def test_case_11():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        with pytest.raises(IndexError):
>           double_linked_list_0.shift()

MIO/test_binarySearchTree3_MIO.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98af83d0>

>   ???
E   AttributeError: 'NoneType' object has no attribute 'prev'

binarySearchTree3:82: AttributeError
[36m   -[0m [# 117] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
   45:         if old_head:
   46:             old_head.prev = self.head
   47:         if not (self.tail):
   48:             self.tail = self.head
[34m-  49:         self._length += 1[0m
[32m+  49:         self._length += 2[0m
   50:     
   51:     def pop(self):
   52:         '''Remove the val from the head of the list.'''
   53:         to_return = self.head
--------------------------------------------------------------------------------
[0.19990 s] [31msurvived[0m
[36m   -[0m [# 118] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
   50:     
   51:     def pop(self):
   52:         '''Remove the val from the head of the list.'''
   53:         to_return = self.head
[34m-  54:         if self._length < 1:[0m
[32m+  54:         if self._length < 2:[0m
   55:             raise IndexError('Cannot pop from an empty list.')
   56:         
   57:         new_head = self.head.next
   58:         if new_head:
--------------------------------------------------------------------------------
[0.20267 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_5

def test_case_5():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        queue_0 = module_0.Queue(bst_0)
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.dequeue()

MIO/test_binarySearchTree3_MIO.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:143: in dequeue
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b982f6fe0>

>   ???
E   IndexError: Cannot pop from an empty list.

binarySearchTree3:55: IndexError
[36m   -[0m [# 119] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
   51:     def pop(self):
   52:         '''Remove the val from the head of the list.'''
   53:         to_return = self.head
   54:         if self._length < 1:
[34m-  55:             raise IndexError('Cannot pop from an empty list.')[0m
[32m+  55:             raise IndexError('mutpy')[0m
   56:         
   57:         new_head = self.head.next
   58:         if new_head:
   59:             new_head.prev = None
--------------------------------------------------------------------------------
[0.20242 s] [31msurvived[0m
[36m   -[0m [# 120] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
   51:     def pop(self):
   52:         '''Remove the val from the head of the list.'''
   53:         to_return = self.head
   54:         if self._length < 1:
[34m-  55:             raise IndexError('Cannot pop from an empty list.')[0m
[32m+  55:             raise IndexError('')[0m
   56:         
   57:         new_head = self.head.next
   58:         if new_head:
   59:             new_head.prev = None
--------------------------------------------------------------------------------
[0.19908 s] [31msurvived[0m
[36m   -[0m [# 121] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
   57:         new_head = self.head.next
   58:         if new_head:
   59:             new_head.prev = None
   60:         self.head = new_head
[34m-  61:         self._length -= 1[0m
[32m+  61:         self._length -= 2[0m
   62:         if self._length < 1:
   63:             self.tail = None
   64:         return to_return.data
   65:     
--------------------------------------------------------------------------------
[0.19870 s] [31msurvived[0m
[36m   -[0m [# 122] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
   58:         if new_head:
   59:             new_head.prev = None
   60:         self.head = new_head
   61:         self._length -= 1
[34m-  62:         if self._length < 1:[0m
[32m+  62:         if self._length < 2:[0m
   63:             self.tail = None
   64:         return to_return.data
   65:     
   66:     def append(self, val):
--------------------------------------------------------------------------------
[0.29328 s] [31msurvived[0m
[36m   -[0m [# 123] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
   68:         old_tail = self.tail
   69:         self.tail = NodeDLL(val, prev=old_tail)
   70:         if old_tail:
   71:             old_tail.next = self.tail
[34m-  72:         if self._length < 1:[0m
[32m+  72:         if self._length < 2:[0m
   73:             self.head = self.tail
   74:         self._length += 1
   75:     
   76:     def shift(self):
--------------------------------------------------------------------------------
[0.21219 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_13

def test_case_13():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.append(double_linked_list_0)
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
        var_1 = double_linked_list_0.append(var_0)
>       var_2 = double_linked_list_0.remove(double_linked_list_0)

MIO/test_binarySearchTree3_MIO.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98679510>
val = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98679510>

>   ???
E   ValueError: <binarySearchTree3.DoubleLinkedList object at 0x7f9b98679510> is not in the list

binarySearchTree3:108: ValueError
[36m   -[0m [# 124] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
   70:         if old_tail:
   71:             old_tail.next = self.tail
   72:         if self._length < 1:
   73:             self.head = self.tail
[34m-  74:         self._length += 1[0m
[32m+  74:         self._length += 2[0m
   75:     
   76:     def shift(self):
   77:         '''Remove the val from the tail of the list.'''
   78:         to_return = self.tail
--------------------------------------------------------------------------------
[0.20693 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_12

def test_case_12():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.append(double_linked_list_0)
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_1 = double_linked_list_0.remove(double_linked_list_0)

MIO/test_binarySearchTree3_MIO.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b983a11e0>
val = <binarySearchTree3.DoubleLinkedList object at 0x7f9b983a11e0>

>   ???
E   AttributeError: 'NoneType' object has no attribute 'prev'

binarySearchTree3:101: AttributeError
[36m   -[0m [# 125] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
   75:     
   76:     def shift(self):
   77:         '''Remove the val from the tail of the list.'''
   78:         to_return = self.tail
[34m-  79:         if self._length < 1:[0m
[32m+  79:         if self._length < 2:[0m
   80:             raise IndexError('Cannot shift from an empty list.')
   81:         
   82:         new_tail = self.tail.prev
   83:         if new_tail:
--------------------------------------------------------------------------------
[0.20333 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_10

def test_case_10():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        double_linked_list_0 = module_0.DoubleLinkedList(bst_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
        assert f'{type(double_linked_list_0.tail).__module__}.{type(double_linked_list_0.tail).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_0 = double_linked_list_0.shift()

MIO/test_binarySearchTree3_MIO.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b9885f550>

>   ???
E   IndexError: Cannot shift from an empty list.

binarySearchTree3:80: IndexError
[36m   -[0m [# 126] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
   76:     def shift(self):
   77:         '''Remove the val from the tail of the list.'''
   78:         to_return = self.tail
   79:         if self._length < 1:
[34m-  80:             raise IndexError('Cannot shift from an empty list.')[0m
[32m+  80:             raise IndexError('mutpy')[0m
   81:         
   82:         new_tail = self.tail.prev
   83:         if new_tail:
   84:             new_tail.next = None
--------------------------------------------------------------------------------
[0.19889 s] [31msurvived[0m
[36m   -[0m [# 127] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
   76:     def shift(self):
   77:         '''Remove the val from the tail of the list.'''
   78:         to_return = self.tail
   79:         if self._length < 1:
[34m-  80:             raise IndexError('Cannot shift from an empty list.')[0m
[32m+  80:             raise IndexError('')[0m
   81:         
   82:         new_tail = self.tail.prev
   83:         if new_tail:
   84:             new_tail.next = None
--------------------------------------------------------------------------------
[0.18015 s] [31msurvived[0m
[36m   -[0m [# 128] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
   82:         new_tail = self.tail.prev
   83:         if new_tail:
   84:             new_tail.next = None
   85:         self.tail = new_tail
[34m-  86:         self._length -= 1[0m
[32m+  86:         self._length -= 2[0m
   87:         if self._length < 1:
   88:             self.tail = None
   89:         return to_return.data
   90:     
--------------------------------------------------------------------------------
[0.20382 s] [31msurvived[0m
[36m   -[0m [# 129] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
   83:         if new_tail:
   84:             new_tail.next = None
   85:         self.tail = new_tail
   86:         self._length -= 1
[34m-  87:         if self._length < 1:[0m
[32m+  87:         if self._length < 2:[0m
   88:             self.tail = None
   89:         return to_return.data
   90:     
   91:     def remove(self, val):
--------------------------------------------------------------------------------
[0.18291 s] [31msurvived[0m
[36m   -[0m [# 130] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
   92:         '''Remove first occurance of val from list.'''
   93:         curr = self.head
   94:         while curr:
   95:             if curr.data is val:
[34m-  96:                 if self._length == 1:[0m
[32m+  96:                 if self._length == 2:[0m
   97:                     (self.head, self.tail) = (None, None)
   98:                 elif (curr is not self.head and curr is not self.tail):
   99:                     (curr.next.prev, curr.prev.next) = (curr.prev, curr.next)
  100:                 elif curr is self.head:
--------------------------------------------------------------------------------
[0.32148 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_12

def test_case_12():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.append(double_linked_list_0)
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_1 = double_linked_list_0.remove(double_linked_list_0)

MIO/test_binarySearchTree3_MIO.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98828c70>
val = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98828c70>

>   ???
E   AttributeError: 'NoneType' object has no attribute 'prev'

binarySearchTree3:101: AttributeError
[36m   -[0m [# 131] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  100:                 elif curr is self.head:
  101:                     (self.head, curr.next.prev) = (curr.next, None)
  102:                 elif curr is self.tail:
  103:                     (self.tail, curr.prev.next) = (curr.prev, None)
[34m- 104:                 self._length -= 1[0m
[32m+ 104:                 self._length -= 2[0m
  105:                 return
  106:             curr = curr.next
  107:         
  108:         raise ValueError('{} is not in the list'.format(val))
--------------------------------------------------------------------------------
[0.20268 s] [31msurvived[0m
[36m   -[0m [# 132] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  104:                 self._length -= 1
  105:                 return
  106:             curr = curr.next
  107:         
[34m- 108:         raise ValueError('{} is not in the list'.format(val))[0m
[32m+ 108:         raise ValueError('mutpy'.format(val))[0m
  109:     
  110:     def _repr(self):
  111:         '''Return list representation of dll.'''
  112:         l = []
--------------------------------------------------------------------------------
[0.20038 s] [31msurvived[0m
[36m   -[0m [# 133] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  104:                 self._length -= 1
  105:                 return
  106:             curr = curr.next
  107:         
[34m- 108:         raise ValueError('{} is not in the list'.format(val))[0m
[32m+ 108:         raise ValueError(''.format(val))[0m
  109:     
  110:     def _repr(self):
  111:         '''Return list representation of dll.'''
  112:         l = []
--------------------------------------------------------------------------------
[0.32902 s] [31msurvived[0m
[36m   -[0m [# 134] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  161:         self.val = val
  162:         self.right = None
  163:         self.left = None
  164:         self.parent = parent
[34m- 165:         self.height = 1[0m
[32m+ 165:         self.height = 2[0m
  166:     
  167:     def _is_leaf(self):
  168:         '''Return true if a leaf.'''
  169:         return not ((self.right or self.left))
--------------------------------------------------------------------------------
[0.19397 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_1

def test_case_1():
        node_0 = module_0.Node()
>       assert node_0.height == 1
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:14: AssertionError
[36m   -[0m [# 135] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  174:     
  175:     def _onlychild(self):
  176:         '''Return string depending on children.'''
  177:         if (self.left and not (self.right)):
[34m- 178:             return 'left'[0m
[32m+ 178:             return 'mutpy'[0m
  179:         if (self.right and not (self.left)):
  180:             return 'right'
  181:     
  182:     def _side(self):
--------------------------------------------------------------------------------
[0.20028 s] [31msurvived[0m
[36m   -[0m [# 136] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  174:     
  175:     def _onlychild(self):
  176:         '''Return string depending on children.'''
  177:         if (self.left and not (self.right)):
[34m- 178:             return 'left'[0m
[32m+ 178:             return ''[0m
  179:         if (self.right and not (self.left)):
  180:             return 'right'
  181:     
  182:     def _side(self):
--------------------------------------------------------------------------------
[0.18315 s] [31msurvived[0m
[36m   -[0m [# 137] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  176:         '''Return string depending on children.'''
  177:         if (self.left and not (self.right)):
  178:             return 'left'
  179:         if (self.right and not (self.left)):
[34m- 180:             return 'right'[0m
[32m+ 180:             return 'mutpy'[0m
  181:     
  182:     def _side(self):
  183:         '''Return if left or right child of parent.'''
  184:         if self.parent:
--------------------------------------------------------------------------------
[0.19298 s] [31msurvived[0m
[36m   -[0m [# 138] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  176:         '''Return string depending on children.'''
  177:         if (self.left and not (self.right)):
  178:             return 'left'
  179:         if (self.right and not (self.left)):
[34m- 180:             return 'right'[0m
[32m+ 180:             return ''[0m
  181:     
  182:     def _side(self):
  183:         '''Return if left or right child of parent.'''
  184:         if self.parent:
--------------------------------------------------------------------------------
[0.20011 s] [31msurvived[0m
[36m   -[0m [# 139] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  181:     
  182:     def _side(self):
  183:         '''Return if left or right child of parent.'''
  184:         if self.parent:
[34m- 185:             return 'left' if self.parent.left == self else 'right'[0m
[32m+ 185:             return 'mutpy' if self.parent.left == self else 'right'[0m
  186: 
  187: 
  188: class Bst(object):
  189:     '''Binary Search Tree.
--------------------------------------------------------------------------------
[0.19420 s] [31msurvived[0m
[36m   -[0m [# 140] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  181:     
  182:     def _side(self):
  183:         '''Return if left or right child of parent.'''
  184:         if self.parent:
[34m- 185:             return 'left' if self.parent.left == self else 'right'[0m
[32m+ 185:             return '' if self.parent.left == self else 'right'[0m
  186: 
  187: 
  188: class Bst(object):
  189:     '''Binary Search Tree.
--------------------------------------------------------------------------------
[0.19938 s] [31msurvived[0m
[36m   -[0m [# 141] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  181:     
  182:     def _side(self):
  183:         '''Return if left or right child of parent.'''
  184:         if self.parent:
[34m- 185:             return 'left' if self.parent.left == self else 'right'[0m
[32m+ 185:             return 'left' if self.parent.left == self else 'mutpy'[0m
  186: 
  187: 
  188: class Bst(object):
  189:     '''Binary Search Tree.
--------------------------------------------------------------------------------
[0.30634 s] [31msurvived[0m
[36m   -[0m [# 142] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  181:     
  182:     def _side(self):
  183:         '''Return if left or right child of parent.'''
  184:         if self.parent:
[34m- 185:             return 'left' if self.parent.left == self else 'right'[0m
[32m+ 185:             return 'left' if self.parent.left == self else ''[0m
  186: 
  187: 
  188: class Bst(object):
  189:     '''Binary Search Tree.
--------------------------------------------------------------------------------
[0.18278 s] [31msurvived[0m
[36m   -[0m [# 143] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  226:     '''
  227:     
  228:     def __init__(self, data=None):
  229:         '''Initialize tree.'''
[34m- 230:         self._size = 0[0m
[32m+ 230:         self._size = 1[0m
  231:         self.root = None
  232:         
  233:         if data:
  234:             for i in data:
--------------------------------------------------------------------------------
[0.21599 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_39

def test_case_39():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.post_order()
        var_1 = bst_0.size()
>       assert var_1 == 0
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:317: AssertionError
[36m   -[0m [# 144] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  237:     def insert(self, val):
  238:         '''Insert val into BST. If val is already present will be ignored.'''
  239:         if not (self.root):
  240:             self.root = Node(val)
[34m- 241:             self._size += 1[0m
[32m+ 241:             self._size += 2[0m
  242:         else:
  243:             self._step(val, self.root)
  244:     
  245:     def _step(self, val, curr):
--------------------------------------------------------------------------------
[0.20099 s] [31msurvived[0m
[36m   -[0m [# 145] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  244:     
  245:     def _step(self, val, curr):
  246:         '''Decide left or right and returns height.'''
  247:         if val < curr.val:
[34m- 248:             curr = self._set_child(curr, 'left', val)[0m
[32m+ 248:             curr = self._set_child(curr, 'mutpy', val)[0m
  249:         elif val > curr.val:
  250:             curr = self._set_child(curr, 'right', val)
  251:         return curr.height
  252:     
--------------------------------------------------------------------------------
[0.22230 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_25

def test_case_25():
        bytes_0 = b'd~\xd8\xfc\xfd,@,$\xb91f\xe7\x92\xc2\x14\xd3H'
>       bst_0 = module_0.Bst(bytes_0)

MIO/test_binarySearchTree3_MIO.py:205: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:235: in __init__
    ???
binarySearchTree3:243: in insert
    ???
binarySearchTree3:248: in _step
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98aae6e0>
curr = <binarySearchTree3.Node object at 0x7f9b98aae230>, side = 'mutpy'
val = 44

>   ???
E   AttributeError: 'Node' object has no attribute 'mutpy'

binarySearchTree3:255: AttributeError
[36m   -[0m [# 146] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  244:     
  245:     def _step(self, val, curr):
  246:         '''Decide left or right and returns height.'''
  247:         if val < curr.val:
[34m- 248:             curr = self._set_child(curr, 'left', val)[0m
[32m+ 248:             curr = self._set_child(curr, '', val)[0m
  249:         elif val > curr.val:
  250:             curr = self._set_child(curr, 'right', val)
  251:         return curr.height
  252:     
--------------------------------------------------------------------------------
[0.22277 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_25

def test_case_25():
        bytes_0 = b'd~\xd8\xfc\xfd,@,$\xb91f\xe7\x92\xc2\x14\xd3H'
>       bst_0 = module_0.Bst(bytes_0)

MIO/test_binarySearchTree3_MIO.py:205: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:235: in __init__
    ???
binarySearchTree3:243: in insert
    ???
binarySearchTree3:248: in _step
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b989cdae0>
curr = <binarySearchTree3.Node object at 0x7f9b98890070>, side = '', val = 44

>   ???
E   AttributeError: 'Node' object has no attribute ''

binarySearchTree3:255: AttributeError
[36m   -[0m [# 147] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  246:         '''Decide left or right and returns height.'''
  247:         if val < curr.val:
  248:             curr = self._set_child(curr, 'left', val)
  249:         elif val > curr.val:
[34m- 250:             curr = self._set_child(curr, 'right', val)[0m
[32m+ 250:             curr = self._set_child(curr, 'mutpy', val)[0m
  251:         return curr.height
  252:     
  253:     def _set_child(self, curr, side, val):
  254:         '''Helping.'''
--------------------------------------------------------------------------------
[0.21871 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_21

def test_case_21():
        bytes_0 = b'z\xc7'
>       bst_0 = module_0.Bst(bytes_0)

MIO/test_binarySearchTree3_MIO.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:235: in __init__
    ???
binarySearchTree3:243: in insert
    ???
binarySearchTree3:250: in _step
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b982478e0>
curr = <binarySearchTree3.Node object at 0x7f9b98247e50>, side = 'mutpy'
val = 199

>   ???
E   AttributeError: 'Node' object has no attribute 'mutpy'

binarySearchTree3:255: AttributeError
[36m   -[0m [# 148] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  246:         '''Decide left or right and returns height.'''
  247:         if val < curr.val:
  248:             curr = self._set_child(curr, 'left', val)
  249:         elif val > curr.val:
[34m- 250:             curr = self._set_child(curr, 'right', val)[0m
[32m+ 250:             curr = self._set_child(curr, '', val)[0m
  251:         return curr.height
  252:     
  253:     def _set_child(self, curr, side, val):
  254:         '''Helping.'''
--------------------------------------------------------------------------------
[0.20995 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_21

def test_case_21():
        bytes_0 = b'z\xc7'
>       bst_0 = module_0.Bst(bytes_0)

MIO/test_binarySearchTree3_MIO.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:235: in __init__
    ???
binarySearchTree3:243: in insert
    ???
binarySearchTree3:250: in _step
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b984a5ab0>
curr = <binarySearchTree3.Node object at 0x7f9b984a6770>, side = '', val = 199

>   ???
E   AttributeError: 'Node' object has no attribute ''

binarySearchTree3:255: AttributeError
[36m   -[0m [# 149] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  255:         child = getattr(curr, side)
  256:         if child:
  257:             count = self._step(val, child)
  258:             if curr.height <= count:
[34m- 259:                 curr.height += 1[0m
[32m+ 259:                 curr.height += 2[0m
  260:         else:
  261:             setattr(curr, side, Node(val, curr))
  262:             self._size += 1
  263:             if curr.height == 1:
--------------------------------------------------------------------------------
[0.35661 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_0 = bst_0.balance()
>       assert var_0 == -1
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:258: AssertionError
[36m   -[0m [# 150] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  258:             if curr.height <= count:
  259:                 curr.height += 1
  260:         else:
  261:             setattr(curr, side, Node(val, curr))
[34m- 262:             self._size += 1[0m
[32m+ 262:             self._size += 2[0m
  263:             if curr.height == 1:
  264:                 curr.height += 1
  265:         return curr
  266:     
--------------------------------------------------------------------------------
[0.19906 s] [31msurvived[0m
[36m   -[0m [# 151] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  259:                 curr.height += 1
  260:         else:
  261:             setattr(curr, side, Node(val, curr))
  262:             self._size += 1
[34m- 263:             if curr.height == 1:[0m
[32m+ 263:             if curr.height == 2:[0m
  264:                 curr.height += 1
  265:         return curr
  266:     
  267:     def search(self, val):
--------------------------------------------------------------------------------
[0.19937 s] [31msurvived[0m
[36m   -[0m [# 152] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  260:         else:
  261:             setattr(curr, side, Node(val, curr))
  262:             self._size += 1
  263:             if curr.height == 1:
[34m- 264:                 curr.height += 1[0m
[32m+ 264:                 curr.height += 2[0m
  265:         return curr
  266:     
  267:     def search(self, val):
  268:         '''Return the node containing val.'''
--------------------------------------------------------------------------------
[0.19913 s] [31msurvived[0m
[36m   -[0m [# 153] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  280:         return self._size
  281:     
  282:     def depth(self):
  283:         '''Return depth of the BST, representing total levels.'''
[34m- 284:         return 0 if not (self.root) else self.root.height[0m
[32m+ 284:         return 1 if not (self.root) else self.root.height[0m
  285:     
  286:     def contains(self, val):
  287:         '''Return true if val is in the bst.'''
  288:         return self.search(val) is not None
--------------------------------------------------------------------------------
[0.23121 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_31

def test_case_31():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.depth()
>       assert var_0 == 0
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:250: AssertionError
[36m   -[0m [# 154] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  297:         '''
  298:         if not tree:
  299:             tree = self.root
  300:             if not tree:
[34m- 301:                 return 0[0m
[32m+ 301:                 return 1[0m
  302:         
  303:         leftbranch = 0 if not (tree.left) else tree.left.height
  304:         rightbranch = 0 if not (tree.right) else tree.right.height
  305:         
--------------------------------------------------------------------------------
[0.23485 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_34

def test_case_34():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.balance()
>       assert var_0 == 0
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:274: AssertionError
[36m   -[0m [# 155] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  299:             tree = self.root
  300:             if not tree:
  301:                 return 0
  302:         
[34m- 303:         leftbranch = 0 if not (tree.left) else tree.left.height[0m
[32m+ 303:         leftbranch = 1 if not (tree.left) else tree.left.height[0m
  304:         rightbranch = 0 if not (tree.right) else tree.right.height
  305:         
  306:         return leftbranch - rightbranch
  307:     
--------------------------------------------------------------------------------
[0.21445 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_33

def test_case_33():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_1 = bst_0.balance()
>       assert var_1 == 0
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:267: AssertionError
[36m   -[0m [# 156] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  300:             if not tree:
  301:                 return 0
  302:         
  303:         leftbranch = 0 if not (tree.left) else tree.left.height
[34m- 304:         rightbranch = 0 if not (tree.right) else tree.right.height[0m
[32m+ 304:         rightbranch = 1 if not (tree.right) else tree.right.height[0m
  305:         
  306:         return leftbranch - rightbranch
  307:     
  308:     def pre_order(self, node='root'):
--------------------------------------------------------------------------------
[0.23435 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_33

def test_case_33():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_1 = bst_0.balance()
>       assert var_1 == 0
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:267: AssertionError
[36m   -[0m [# 157] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  304:         rightbranch = 0 if not (tree.right) else tree.right.height
  305:         
  306:         return leftbranch - rightbranch
  307:     
[34m- 308:     def pre_order(self, node='root'):[0m
[32m+ 308:     def pre_order(self, node='mutpy'):[0m
  309:         '''Depth first pre-order traversal of tree.'''
  310:         if node == 'root':
  311:             node = self.root
  312:         
--------------------------------------------------------------------------------
[0.34685 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_36

def test_case_36():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.pre_order()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b981e9120>, node = 'mutpy'

>   ???
E   AttributeError: 'str' object has no attribute 'val'

binarySearchTree3:316: AttributeError
[36m   -[0m [# 158] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  304:         rightbranch = 0 if not (tree.right) else tree.right.height
  305:         
  306:         return leftbranch - rightbranch
  307:     
[34m- 308:     def pre_order(self, node='root'):[0m
[32m+ 308:     def pre_order(self, node=''):[0m
  309:         '''Depth first pre-order traversal of tree.'''
  310:         if node == 'root':
  311:             node = self.root
  312:         
--------------------------------------------------------------------------------
[0.20115 s] [31msurvived[0m
[36m   -[0m [# 159] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  306:         return leftbranch - rightbranch
  307:     
  308:     def pre_order(self, node='root'):
  309:         '''Depth first pre-order traversal of tree.'''
[34m- 310:         if node == 'root':[0m
[32m+ 310:         if node == 'mutpy':[0m
  311:             node = self.root
  312:         
  313:         if not node:
  314:             return
--------------------------------------------------------------------------------
[0.23111 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_36

def test_case_36():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.pre_order()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98a132b0>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'val'

binarySearchTree3:316: AttributeError
[36m   -[0m [# 160] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  306:         return leftbranch - rightbranch
  307:     
  308:     def pre_order(self, node='root'):
  309:         '''Depth first pre-order traversal of tree.'''
[34m- 310:         if node == 'root':[0m
[32m+ 310:         if node == '':[0m
  311:             node = self.root
  312:         
  313:         if not node:
  314:             return
--------------------------------------------------------------------------------
[0.35903 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_36

def test_case_36():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.pre_order()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b982f4820>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'val'

binarySearchTree3:316: AttributeError
[36m   -[0m [# 161] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  319:             yield n
  320:         for n in self.pre_order(node=node.right):
  321:             yield n
  322:     
[34m- 323:     def in_order(self, node='root'):[0m
[32m+ 323:     def in_order(self, node='mutpy'):[0m
  324:         '''Depth first in-order traversal of tree.'''
  325:         if node == 'root':
  326:             node = self.root
  327:         
--------------------------------------------------------------------------------
[0.21557 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_38

def test_case_38():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.in_order()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:306: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98a15480>, node = 'mutpy'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

binarySearchTree3:331: AttributeError
[36m   -[0m [# 162] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  319:             yield n
  320:         for n in self.pre_order(node=node.right):
  321:             yield n
  322:     
[34m- 323:     def in_order(self, node='root'):[0m
[32m+ 323:     def in_order(self, node=''):[0m
  324:         '''Depth first in-order traversal of tree.'''
  325:         if node == 'root':
  326:             node = self.root
  327:         
--------------------------------------------------------------------------------
[0.19199 s] [31msurvived[0m
[36m   -[0m [# 163] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  321:             yield n
  322:     
  323:     def in_order(self, node='root'):
  324:         '''Depth first in-order traversal of tree.'''
[34m- 325:         if node == 'root':[0m
[32m+ 325:         if node == 'mutpy':[0m
  326:             node = self.root
  327:         
  328:         if not node:
  329:             return
--------------------------------------------------------------------------------
[0.23399 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_38

def test_case_38():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.in_order()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:306: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98a84c10>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

binarySearchTree3:331: AttributeError
[36m   -[0m [# 164] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  321:             yield n
  322:     
  323:     def in_order(self, node='root'):
  324:         '''Depth first in-order traversal of tree.'''
[34m- 325:         if node == 'root':[0m
[32m+ 325:         if node == '':[0m
  326:             node = self.root
  327:         
  328:         if not node:
  329:             return
--------------------------------------------------------------------------------
[0.23577 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_38

def test_case_38():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.in_order()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:306: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98a9d060>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

binarySearchTree3:331: AttributeError
[36m   -[0m [# 165] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  333:         yield node.val
  334:         for n in self.in_order(node=node.right):
  335:             yield n
  336:     
[34m- 337:     def post_order(self, node='root'):[0m
[32m+ 337:     def post_order(self, node='mutpy'):[0m
  338:         '''Depth frist post_order traversal of tree.'''
  339:         if node == 'root':
  340:             node = self.root
  341:         
--------------------------------------------------------------------------------
[0.34687 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_39

def test_case_39():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.post_order()
        var_1 = bst_0.size()
        assert var_1 == 0
        var_2 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:320: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98ad65f0>, node = 'mutpy'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

binarySearchTree3:345: AttributeError
[36m   -[0m [# 166] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  333:         yield node.val
  334:         for n in self.in_order(node=node.right):
  335:             yield n
  336:     
[34m- 337:     def post_order(self, node='root'):[0m
[32m+ 337:     def post_order(self, node=''):[0m
  338:         '''Depth frist post_order traversal of tree.'''
  339:         if node == 'root':
  340:             node = self.root
  341:         
--------------------------------------------------------------------------------
[0.23006 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_39

def test_case_39():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.post_order()
        var_1 = bst_0.size()
        assert var_1 == 0
        var_2 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        double_linked_list_0 = module_0.DoubleLinkedList(var_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
>       assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:322: AssertionError
[36m   -[0m [# 167] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  335:             yield n
  336:     
  337:     def post_order(self, node='root'):
  338:         '''Depth frist post_order traversal of tree.'''
[34m- 339:         if node == 'root':[0m
[32m+ 339:         if node == 'mutpy':[0m
  340:             node = self.root
  341:         
  342:         if not node:
  343:             return
--------------------------------------------------------------------------------
[0.23633 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_39

def test_case_39():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.post_order()
        var_1 = bst_0.size()
        assert var_1 == 0
        var_2 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:320: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b989b0760>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

binarySearchTree3:345: AttributeError
[36m   -[0m [# 168] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  335:             yield n
  336:     
  337:     def post_order(self, node='root'):
  338:         '''Depth frist post_order traversal of tree.'''
[34m- 339:         if node == 'root':[0m
[32m+ 339:         if node == '':[0m
  340:             node = self.root
  341:         
  342:         if not node:
  343:             return
--------------------------------------------------------------------------------
[0.35839 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_39

def test_case_39():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.post_order()
        var_1 = bst_0.size()
        assert var_1 == 0
        var_2 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:320: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98ae6d40>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

binarySearchTree3:345: AttributeError
[36m   -[0m [# 169] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  361:                 q.enqueue(node.right)
  362:     
  363:     def delete(self, val):
  364:         '''Remove a node from the tree.'''
[34m- 365:         if (self._size < 1 or not (self.contains(val))):[0m
[32m+ 365:         if (self._size < 2 or not (self.contains(val))):[0m
  366:             return
  367:         
  368:         node = self.search(val)
  369:         
--------------------------------------------------------------------------------
[0.21864 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_1 = bst_0.delete(bst_0)
>       assert bst_0.root is None
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:179: AssertionError
[36m   -[0m [# 170] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  374:                 self.root = None
  375:         
  376:         elif node._is_interior():
  377:             next_node = self._find_replacement(node)
[34m- 378:             self._size += 1[0m
[32m+ 378:             self._size += 2[0m
  379:             self.delete(next_node.val)
  380:             node.val = next_node.val
  381:         else:
  382:             
--------------------------------------------------------------------------------
[0.18213 s] [31msurvived[0m
[36m   -[0m [# 171] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  386:                 setattr(node.parent, node._side(), child)
  387:             else:
  388:                 self.root = child
  389:         
[34m- 390:         self._size -= 1[0m
[32m+ 390:         self._size -= 2[0m
  391:     
  392:     def _find_replacement(self, node):
  393:         '''Find left most node of right subtree.'''
  394:         if node.right:
--------------------------------------------------------------------------------
[0.19774 s] [31msurvived[0m
[36m   -[0m [# 172] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  394:         if node.right:
  395:             return self._findmin(node.right)
  396:         
  397:         elif node.parent:
[34m- 398:             if node._side() == 'left':[0m
[32m+ 398:             if node._side() == 'mutpy':[0m
  399:                 return self.parent
  400:             else:
  401:                 node.parent.right = None
  402:                 tmp = self._find_replacement(node.parent)
--------------------------------------------------------------------------------
[0.18035 s] [31msurvived[0m
[36m   -[0m [# 173] CRP binarySearchTree3: 
--------------------------------------------------------------------------------
  394:         if node.right:
  395:             return self._findmin(node.right)
  396:         
  397:         elif node.parent:
[34m- 398:             if node._side() == 'left':[0m
[32m+ 398:             if node._side() == '':[0m
  399:                 return self.parent
  400:             else:
  401:                 node.parent.right = None
  402:                 tmp = self._find_replacement(node.parent)
--------------------------------------------------------------------------------
[0.19690 s] [31msurvived[0m
[36m   -[0m [# 174] EHD binarySearchTree3: 
--------------------------------------------------------------------------------
   34:         try:
   35:             for val in data:
   36:                 self.push(val)
   37:         except TypeError:
[34m-  38:             if data:[0m
[34m-  39:                 self.push(data)[0m
[32m+  38:             raise[0m
[32m+  39:     [0m
   40:     
   41:     def push(self, val):
   42:         '''Add val to the head of the list.'''
   43:         old_head = self.head
--------------------------------------------------------------------------------
[0.19417 s] [36mincompetent[0m

TypeError: binarySearchTree3:35: TypeError: 'Node' object is not iterable

[36m   -[0m [# 175] EHD binarySearchTree3: 
--------------------------------------------------------------------------------
  114:             try:
  115:                 popped_data = self.pop()
  116:                 l.append(popped_data)
  117:             except IndexError:
[34m- 118:                 break[0m
[32m+ 118:                 raise[0m
  119:         return l
  120: 
  121: class Queue(object):
  122:     '''Implementation of Queue.
--------------------------------------------------------------------------------
[0.20024 s] [31msurvived[0m
[36m   -[0m [# 176] EHD binarySearchTree3: 
--------------------------------------------------------------------------------
  146:         '''Return the next value in the queue without dequing it.'''
  147:         try:
  148:             return self._container.head.data
  149:         except AttributeError:
[34m- 150:             return None[0m
[32m+ 150:             raise[0m
  151:     
  152:     def size(self):
  153:         '''Return the size of the queue.'''
  154:         return self._container._length
--------------------------------------------------------------------------------
[0.32968 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_19

def test_case_19():
        queue_0 = module_0.Queue()
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.peek()

MIO/test_binarySearchTree3_MIO.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Queue object at 0x7f9b98557640>

>   ???
E   AttributeError: 'NoneType' object has no attribute 'data'

binarySearchTree3:148: AttributeError
[36m   -[0m [# 177] EXS binarySearchTree3: 
--------------------------------------------------------------------------------
   34:         try:
   35:             for val in data:
   36:                 self.push(val)
   37:         except TypeError:
[34m-  38:             if data:[0m
[34m-  39:                 self.push(data)[0m
[32m+  38:             pass[0m
[32m+  39:     [0m
   40:     
   41:     def push(self, val):
   42:         '''Add val to the head of the list.'''
   43:         old_head = self.head
--------------------------------------------------------------------------------
[0.19317 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_1

def test_case_1():
        node_0 = module_0.Node()
        assert node_0.height == 1
        double_linked_list_0 = module_0.DoubleLinkedList(node_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
>       assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:17: AssertionError
[36m   -[0m [# 178] EXS binarySearchTree3: 
--------------------------------------------------------------------------------
  114:             try:
  115:                 popped_data = self.pop()
  116:                 l.append(popped_data)
  117:             except IndexError:
[34m- 118:                 break[0m
[32m+ 118:                 pass[0m
  119:         return l
  120: 
  121: class Queue(object):
  122:     '''Implementation of Queue.
--------------------------------------------------------------------------------
[0.19837 s] [31msurvived[0m
[36m   -[0m [# 179] EXS binarySearchTree3: 
--------------------------------------------------------------------------------
  146:         '''Return the next value in the queue without dequing it.'''
  147:         try:
  148:             return self._container.head.data
  149:         except AttributeError:
[34m- 150:             return None[0m
[32m+ 150:             pass[0m
  151:     
  152:     def size(self):
  153:         '''Return the size of the queue.'''
  154:         return self._container._length
--------------------------------------------------------------------------------
[0.18198 s] [31msurvived[0m
[36m   -[0m [# 180] LCR binarySearchTree3: 
--------------------------------------------------------------------------------
   94:         while curr:
   95:             if curr.data is val:
   96:                 if self._length == 1:
   97:                     (self.head, self.tail) = (None, None)
[34m-  98:                 elif (curr is not self.head and curr is not self.tail):[0m
[32m+  98:                 elif (curr is not self.head or curr is not self.tail):[0m
   99:                     (curr.next.prev, curr.prev.next) = (curr.prev, curr.next)
  100:                 elif curr is self.head:
  101:                     (self.head, curr.next.prev) = (curr.next, None)
  102:                 elif curr is self.tail:
--------------------------------------------------------------------------------
[0.21227 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_13

def test_case_13():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.append(double_linked_list_0)
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
        var_1 = double_linked_list_0.append(var_0)
>       var_2 = double_linked_list_0.remove(double_linked_list_0)

MIO/test_binarySearchTree3_MIO.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b989c8130>
val = <binarySearchTree3.DoubleLinkedList object at 0x7f9b989c8130>

>   ???
E   AttributeError: 'NoneType' object has no attribute 'next'

binarySearchTree3:99: AttributeError
[36m   -[0m [# 181] LCR binarySearchTree3: 
--------------------------------------------------------------------------------
  165:         self.height = 1
  166:     
  167:     def _is_leaf(self):
  168:         '''Return true if a leaf.'''
[34m- 169:         return not ((self.right or self.left))[0m
[32m+ 169:         return not ((self.right and self.left))[0m
  170:     
  171:     def _is_interior(self):
  172:         '''Return true if a interior node.'''
  173:         return (self.right and self.left)
--------------------------------------------------------------------------------
[0.30904 s] [31msurvived[0m
[36m   -[0m [# 182] LCR binarySearchTree3: 
--------------------------------------------------------------------------------
  169:         return not ((self.right or self.left))
  170:     
  171:     def _is_interior(self):
  172:         '''Return true if a interior node.'''
[34m- 173:         return (self.right and self.left)[0m
[32m+ 173:         return (self.right or self.left)[0m
  174:     
  175:     def _onlychild(self):
  176:         '''Return string depending on children.'''
  177:         if (self.left and not (self.right)):
--------------------------------------------------------------------------------
[0.19756 s] [31msurvived[0m
[36m   -[0m [# 183] LCR binarySearchTree3: 
--------------------------------------------------------------------------------
  173:         return (self.right and self.left)
  174:     
  175:     def _onlychild(self):
  176:         '''Return string depending on children.'''
[34m- 177:         if (self.left and not (self.right)):[0m
[32m+ 177:         if (self.left or not (self.right)):[0m
  178:             return 'left'
  179:         if (self.right and not (self.left)):
  180:             return 'right'
  181:     
--------------------------------------------------------------------------------
[0.19815 s] [31msurvived[0m
[36m   -[0m [# 184] LCR binarySearchTree3: 
--------------------------------------------------------------------------------
  175:     def _onlychild(self):
  176:         '''Return string depending on children.'''
  177:         if (self.left and not (self.right)):
  178:             return 'left'
[34m- 179:         if (self.right and not (self.left)):[0m
[32m+ 179:         if (self.right or not (self.left)):[0m
  180:             return 'right'
  181:     
  182:     def _side(self):
  183:         '''Return if left or right child of parent.'''
--------------------------------------------------------------------------------
[0.19716 s] [31msurvived[0m
[36m   -[0m [# 185] LCR binarySearchTree3: 
--------------------------------------------------------------------------------
  361:                 q.enqueue(node.right)
  362:     
  363:     def delete(self, val):
  364:         '''Remove a node from the tree.'''
[34m- 365:         if (self._size < 1 or not (self.contains(val))):[0m
[32m+ 365:         if (self._size < 1 and not (self.contains(val))):[0m
  366:             return
  367:         
  368:         node = self.search(val)
  369:         
--------------------------------------------------------------------------------
[0.22646 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_27

def test_case_27():
        str_0 = '_N*mxW@Y-+\x0c9z|?='
        bst_0 = module_0.Bst(str_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_0 = bst_0.delete(str_0)

MIO/test_binarySearchTree3_MIO.py:220: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98a17f70>
val = '_N*mxW@Y-+\x0c9z|?='

>   ???
E   AttributeError: 'NoneType' object has no attribute '_is_leaf'

binarySearchTree3:370: AttributeError
[36m   -[0m [# 186] OIL binarySearchTree3: 
--------------------------------------------------------------------------------
   33:         self._length = 0
   34:         try:
   35:             for val in data:
   36:                 self.push(val)
[34m-  37:         except TypeError:[0m
[32m+  37:                 breakexcept TypeError:[0m
   38:             if data:
   39:                 self.push(data)
   40:     
   41:     def push(self, val):
--------------------------------------------------------------------------------
[0.20307 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_4

def test_case_4():
        str_0 = 'aX}B^sw\x0cA!<Uq;!!D9'
        queue_0 = module_0.Queue(str_0)
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
        var_0 = queue_0.dequeue()
>       assert var_0 == '9'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:37: AssertionError
[36m   -[0m [# 187] OIL binarySearchTree3: 
--------------------------------------------------------------------------------
  103:                     (self.tail, curr.prev.next) = (curr.prev, None)
  104:                 self._length -= 1
  105:                 return
  106:             curr = curr.next
[34m- 107:         [0m
[32m+ 107:             break[0m
  108:         raise ValueError('{} is not in the list'.format(val))
  109:     
  110:     def _repr(self):
  111:         '''Return list representation of dll.'''
--------------------------------------------------------------------------------
[0.21471 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_14

def test_case_14():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.push(double_linked_list_0)
        assert f'{type(double_linked_list_0.tail).__module__}.{type(double_linked_list_0.tail).__qualname__}' == 'binarySearchTree3.NodeDLL'
        var_1 = double_linked_list_0.push(var_0)
>       var_2 = double_linked_list_0.remove(double_linked_list_0)

MIO/test_binarySearchTree3_MIO.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98829060>
val = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98829060>

>   ???
E   ValueError: <binarySearchTree3.DoubleLinkedList object at 0x7f9b98829060> is not in the list

binarySearchTree3:108: ValueError
[36m   -[0m [# 188] OIL binarySearchTree3: 
--------------------------------------------------------------------------------
  114:             try:
  115:                 popped_data = self.pop()
  116:                 l.append(popped_data)
  117:             except IndexError:
[34m- 118:                 break[0m
[32m+ 118:                 breakbreak[0m
  119:         return l
  120: 
  121: class Queue(object):
  122:     '''Implementation of Queue.
--------------------------------------------------------------------------------
[0.19770 s] [31msurvived[0m
[36m   -[0m [# 189] OIL binarySearchTree3: 
--------------------------------------------------------------------------------
  232:         
  233:         if data:
  234:             for i in data:
  235:                 self.insert(i)
[34m- 236:     [0m
[32m+ 236:                 break[0m
  237:     def insert(self, val):
  238:         '''Insert val into BST. If val is already present will be ignored.'''
  239:         if not (self.root):
  240:             self.root = Node(val)
--------------------------------------------------------------------------------
[0.35673 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_0 = bst_0.balance()
>       assert var_0 == -1
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:258: AssertionError
[36m   -[0m [# 190] OIL binarySearchTree3: 
--------------------------------------------------------------------------------
  272:                 return curr
  273:             elif val < curr.val:
  274:                 curr = curr.left
  275:             else:
[34m- 276:                 curr = curr.right[0m
[32m+ 276:                 curr = curr.rightbreak[0m
  277:     
  278:     def size(self):
  279:         '''Return the size of the BST.'''
  280:         return self._size
--------------------------------------------------------------------------------
[0.19840 s] [31msurvived[0m
[36m   -[0m [# 191] OIL binarySearchTree3: 
--------------------------------------------------------------------------------
  316:         yield node.val
  317:         
  318:         for n in self.pre_order(node=node.left):
  319:             yield n
[34m- 320:         for n in self.pre_order(node=node.right):[0m
[34m- 321:             yield n[0m
[34m- 322:     [0m
[32m+ 320:             break[0m
[32m+ 321:         for n in self.pre_order(node=node.right):[0m
[32m+ 322:             yield n[0m
  323:     def in_order(self, node='root'):
  324:         '''Depth first in-order traversal of tree.'''
  325:         if node == 'root':
  326:             node = self.root
--------------------------------------------------------------------------------
[0.19798 s] [31msurvived[0m
[36m   -[0m [# 192] OIL binarySearchTree3: 
--------------------------------------------------------------------------------
  318:         for n in self.pre_order(node=node.left):
  319:             yield n
  320:         for n in self.pre_order(node=node.right):
  321:             yield n
[34m- 322:     [0m
[32m+ 322:             break[0m
  323:     def in_order(self, node='root'):
  324:         '''Depth first in-order traversal of tree.'''
  325:         if node == 'root':
  326:             node = self.root
--------------------------------------------------------------------------------
[0.17983 s] [31msurvived[0m
[36m   -[0m [# 193] OIL binarySearchTree3: 
--------------------------------------------------------------------------------
  329:             return
  330:         
  331:         for n in self.in_order(node=node.left):
  332:             yield n
[34m- 333:         yield node.val[0m
[34m- 334:         for n in self.in_order(node=node.right):[0m
[34m- 335:             yield n[0m
[34m- 336:     [0m
[32m+ 333:             break[0m
[32m+ 334:         yield node.val[0m
[32m+ 335:         for n in self.in_order(node=node.right):[0m
[32m+ 336:             yield n[0m
  337:     def post_order(self, node='root'):
  338:         '''Depth frist post_order traversal of tree.'''
  339:         if node == 'root':
  340:             node = self.root
--------------------------------------------------------------------------------
[0.18063 s] [31msurvived[0m
[36m   -[0m [# 194] OIL binarySearchTree3: 
--------------------------------------------------------------------------------
  332:             yield n
  333:         yield node.val
  334:         for n in self.in_order(node=node.right):
  335:             yield n
[34m- 336:     [0m
[32m+ 336:             break[0m
  337:     def post_order(self, node='root'):
  338:         '''Depth frist post_order traversal of tree.'''
  339:         if node == 'root':
  340:             node = self.root
--------------------------------------------------------------------------------
[0.18751 s] [31msurvived[0m
[36m   -[0m [# 195] OIL binarySearchTree3: 
--------------------------------------------------------------------------------
  343:             return
  344:         
  345:         for n in self.post_order(node=node.left):
  346:             yield n
[34m- 347:         for n in self.post_order(node=node.right):[0m
[34m- 348:             yield n[0m
[34m- 349:         yield node.val[0m
[34m- 350:     [0m
[32m+ 347:             break[0m
[32m+ 348:         for n in self.post_order(node=node.right):[0m
[32m+ 349:             yield n[0m
[32m+ 350:         yield node.val[0m
  351:     def breadth_first(self):
  352:         '''Breadth first traversal of tree.'''
  353:         q = Queue()
  354:         q.enqueue(self.root)
--------------------------------------------------------------------------------
[0.19655 s] [31msurvived[0m
[36m   -[0m [# 196] OIL binarySearchTree3: 
--------------------------------------------------------------------------------
  345:         for n in self.post_order(node=node.left):
  346:             yield n
  347:         for n in self.post_order(node=node.right):
  348:             yield n
[34m- 349:         yield node.val[0m
[34m- 350:     [0m
[32m+ 349:             break[0m
[32m+ 350:         yield node.val[0m
  351:     def breadth_first(self):
  352:         '''Breadth first traversal of tree.'''
  353:         q = Queue()
  354:         q.enqueue(self.root)
--------------------------------------------------------------------------------
[0.18061 s] [31msurvived[0m
[36m   -[0m [# 197] OIL binarySearchTree3: 
--------------------------------------------------------------------------------
  358:             if node.left:
  359:                 q.enqueue(node.left)
  360:             if node.right:
  361:                 q.enqueue(node.right)
[34m- 362:     [0m
[32m+ 362:             break[0m
  363:     def delete(self, val):
  364:         '''Remove a node from the tree.'''
  365:         if (self._size < 1 or not (self.contains(val))):
  366:             return
--------------------------------------------------------------------------------
[0.33248 s] [31msurvived[0m
[36m   -[0m [# 198] OIL binarySearchTree3: 
--------------------------------------------------------------------------------
  406:     def _findmin(self, node):
  407:         '''Find min of subtree, Min is always left most node.'''
  408:         while node.left:
  409:             node = node.left
[34m- 410:         return node[0m
[32m+ 410:             break[0m
[32m+ 411:         return node[0m
--------------------------------------------------------------------------------
[0.20107 s] [31msurvived[0m
[36m   -[0m [# 199] RIL binarySearchTree3: 
--------------------------------------------------------------------------------
   31:         self.head = None
   32:         self.tail = None
   33:         self._length = 0
   34:         try:
[34m-  35:             for val in data:[0m
[32m+  35:             for val in reversed(data):[0m
   36:                 self.push(val)
   37:         except TypeError:
   38:             if data:
   39:                 self.push(data)
--------------------------------------------------------------------------------
[0.20462 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_4

def test_case_4():
        str_0 = 'aX}B^sw\x0cA!<Uq;!!D9'
        queue_0 = module_0.Queue(str_0)
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
        var_0 = queue_0.dequeue()
>       assert var_0 == '9'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:37: AssertionError
[36m   -[0m [# 200] RIL binarySearchTree3: 
--------------------------------------------------------------------------------
  230:         self._size = 0
  231:         self.root = None
  232:         
  233:         if data:
[34m- 234:             for i in data:[0m
[32m+ 234:             for i in reversed(data):[0m
  235:                 self.insert(i)
  236:     
  237:     def insert(self, val):
  238:         '''Insert val into BST. If val is already present will be ignored.'''
--------------------------------------------------------------------------------
[0.23177 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_0 = bst_0.balance()
>       assert var_0 == -1
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:258: AssertionError
[36m   -[0m [# 201] RIL binarySearchTree3: 
--------------------------------------------------------------------------------
  314:             return
  315:         
  316:         yield node.val
  317:         
[34m- 318:         for n in self.pre_order(node=node.left):[0m
[32m+ 318:         for n in reversed(self.pre_order(node=node.left)):[0m
  319:             yield n
  320:         for n in self.pre_order(node=node.right):
  321:             yield n
  322:     
--------------------------------------------------------------------------------
[0.19978 s] [31msurvived[0m
[36m   -[0m [# 202] RIL binarySearchTree3: 
--------------------------------------------------------------------------------
  316:         yield node.val
  317:         
  318:         for n in self.pre_order(node=node.left):
  319:             yield n
[34m- 320:         for n in self.pre_order(node=node.right):[0m
[32m+ 320:         for n in reversed(self.pre_order(node=node.right)):[0m
  321:             yield n
  322:     
  323:     def in_order(self, node='root'):
  324:         '''Depth first in-order traversal of tree.'''
--------------------------------------------------------------------------------
[0.17991 s] [31msurvived[0m
[36m   -[0m [# 203] RIL binarySearchTree3: 
--------------------------------------------------------------------------------
  327:         
  328:         if not node:
  329:             return
  330:         
[34m- 331:         for n in self.in_order(node=node.left):[0m
[32m+ 331:         for n in reversed(self.in_order(node=node.left)):[0m
  332:             yield n
  333:         yield node.val
  334:         for n in self.in_order(node=node.right):
  335:             yield n
--------------------------------------------------------------------------------
[0.20276 s] [31msurvived[0m
[36m   -[0m [# 204] RIL binarySearchTree3: 
--------------------------------------------------------------------------------
  330:         
  331:         for n in self.in_order(node=node.left):
  332:             yield n
  333:         yield node.val
[34m- 334:         for n in self.in_order(node=node.right):[0m
[32m+ 334:         for n in reversed(self.in_order(node=node.right)):[0m
  335:             yield n
  336:     
  337:     def post_order(self, node='root'):
  338:         '''Depth frist post_order traversal of tree.'''
--------------------------------------------------------------------------------
[0.20462 s] [31msurvived[0m
[36m   -[0m [# 205] RIL binarySearchTree3: 
--------------------------------------------------------------------------------
  341:         
  342:         if not node:
  343:             return
  344:         
[34m- 345:         for n in self.post_order(node=node.left):[0m
[32m+ 345:         for n in reversed(self.post_order(node=node.left)):[0m
  346:             yield n
  347:         for n in self.post_order(node=node.right):
  348:             yield n
  349:         yield node.val
--------------------------------------------------------------------------------
[0.31836 s] [31msurvived[0m
[36m   -[0m [# 206] RIL binarySearchTree3: 
--------------------------------------------------------------------------------
  343:             return
  344:         
  345:         for n in self.post_order(node=node.left):
  346:             yield n
[34m- 347:         for n in self.post_order(node=node.right):[0m
[32m+ 347:         for n in reversed(self.post_order(node=node.right)):[0m
  348:             yield n
  349:         yield node.val
  350:     
  351:     def breadth_first(self):
--------------------------------------------------------------------------------
[0.19920 s] [31msurvived[0m
[36m   -[0m [# 207] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
   50:     
   51:     def pop(self):
   52:         '''Remove the val from the head of the list.'''
   53:         to_return = self.head
[34m-  54:         if self._length < 1:[0m
[32m+  54:         if self._length > 1:[0m
   55:             raise IndexError('Cannot pop from an empty list.')
   56:         
   57:         new_head = self.head.next
   58:         if new_head:
--------------------------------------------------------------------------------
[0.19872 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_4

def test_case_4():
        str_0 = 'aX}B^sw\x0cA!<Uq;!!D9'
        queue_0 = module_0.Queue(str_0)
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.dequeue()

MIO/test_binarySearchTree3_MIO.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:143: in dequeue
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b985dbca0>

>   ???
E   IndexError: Cannot pop from an empty list.

binarySearchTree3:55: IndexError
[36m   -[0m [# 208] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
   50:     
   51:     def pop(self):
   52:         '''Remove the val from the head of the list.'''
   53:         to_return = self.head
[34m-  54:         if self._length < 1:[0m
[32m+  54:         if self._length <= 1:[0m
   55:             raise IndexError('Cannot pop from an empty list.')
   56:         
   57:         new_head = self.head.next
   58:         if new_head:
--------------------------------------------------------------------------------
[0.19992 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_5

def test_case_5():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        queue_0 = module_0.Queue(bst_0)
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.dequeue()

MIO/test_binarySearchTree3_MIO.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:143: in dequeue
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98555c00>

>   ???
E   IndexError: Cannot pop from an empty list.

binarySearchTree3:55: IndexError
[36m   -[0m [# 209] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
   58:         if new_head:
   59:             new_head.prev = None
   60:         self.head = new_head
   61:         self._length -= 1
[34m-  62:         if self._length < 1:[0m
[32m+  62:         if self._length > 1:[0m
   63:             self.tail = None
   64:         return to_return.data
   65:     
   66:     def append(self, val):
--------------------------------------------------------------------------------
[0.20006 s] [31msurvived[0m
[36m   -[0m [# 210] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
   58:         if new_head:
   59:             new_head.prev = None
   60:         self.head = new_head
   61:         self._length -= 1
[34m-  62:         if self._length < 1:[0m
[32m+  62:         if self._length <= 1:[0m
   63:             self.tail = None
   64:         return to_return.data
   65:     
   66:     def append(self, val):
--------------------------------------------------------------------------------
[0.19955 s] [31msurvived[0m
[36m   -[0m [# 211] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
   68:         old_tail = self.tail
   69:         self.tail = NodeDLL(val, prev=old_tail)
   70:         if old_tail:
   71:             old_tail.next = self.tail
[34m-  72:         if self._length < 1:[0m
[32m+  72:         if self._length > 1:[0m
   73:             self.head = self.tail
   74:         self._length += 1
   75:     
   76:     def shift(self):
--------------------------------------------------------------------------------
[0.20682 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_12

def test_case_12():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.append(double_linked_list_0)
>       assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:103: AssertionError
[36m   -[0m [# 212] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
   68:         old_tail = self.tail
   69:         self.tail = NodeDLL(val, prev=old_tail)
   70:         if old_tail:
   71:             old_tail.next = self.tail
[34m-  72:         if self._length < 1:[0m
[32m+  72:         if self._length <= 1:[0m
   73:             self.head = self.tail
   74:         self._length += 1
   75:     
   76:     def shift(self):
--------------------------------------------------------------------------------
[0.21358 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_13

def test_case_13():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.append(double_linked_list_0)
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
        var_1 = double_linked_list_0.append(var_0)
>       var_2 = double_linked_list_0.remove(double_linked_list_0)

MIO/test_binarySearchTree3_MIO.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b9870f820>
val = <binarySearchTree3.DoubleLinkedList object at 0x7f9b9870f820>

>   ???
E   ValueError: <binarySearchTree3.DoubleLinkedList object at 0x7f9b9870f820> is not in the list

binarySearchTree3:108: ValueError
[36m   -[0m [# 213] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
   75:     
   76:     def shift(self):
   77:         '''Remove the val from the tail of the list.'''
   78:         to_return = self.tail
[34m-  79:         if self._length < 1:[0m
[32m+  79:         if self._length > 1:[0m
   80:             raise IndexError('Cannot shift from an empty list.')
   81:         
   82:         new_tail = self.tail.prev
   83:         if new_tail:
--------------------------------------------------------------------------------
[0.33088 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_9

def test_case_9():
        bytes_0 = b'@\x95\xef|X\x9c\x0b\xbd\x9d\xbd\x9d)\x19\xa9'
        double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
        assert f'{type(double_linked_list_0.tail).__module__}.{type(double_linked_list_0.tail).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_0 = double_linked_list_0.shift()

MIO/test_binarySearchTree3_MIO.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b987af430>

>   ???
E   IndexError: Cannot shift from an empty list.

binarySearchTree3:80: IndexError
[36m   -[0m [# 214] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
   75:     
   76:     def shift(self):
   77:         '''Remove the val from the tail of the list.'''
   78:         to_return = self.tail
[34m-  79:         if self._length < 1:[0m
[32m+  79:         if self._length <= 1:[0m
   80:             raise IndexError('Cannot shift from an empty list.')
   81:         
   82:         new_tail = self.tail.prev
   83:         if new_tail:
--------------------------------------------------------------------------------
[0.20545 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_10

def test_case_10():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        double_linked_list_0 = module_0.DoubleLinkedList(bst_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
        assert f'{type(double_linked_list_0.tail).__module__}.{type(double_linked_list_0.tail).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_0 = double_linked_list_0.shift()

MIO/test_binarySearchTree3_MIO.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b9886b640>

>   ???
E   IndexError: Cannot shift from an empty list.

binarySearchTree3:80: IndexError
[36m   -[0m [# 215] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
   83:         if new_tail:
   84:             new_tail.next = None
   85:         self.tail = new_tail
   86:         self._length -= 1
[34m-  87:         if self._length < 1:[0m
[32m+  87:         if self._length > 1:[0m
   88:             self.tail = None
   89:         return to_return.data
   90:     
   91:     def remove(self, val):
--------------------------------------------------------------------------------
[0.20040 s] [31msurvived[0m
[36m   -[0m [# 216] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
   83:         if new_tail:
   84:             new_tail.next = None
   85:         self.tail = new_tail
   86:         self._length -= 1
[34m-  87:         if self._length < 1:[0m
[32m+  87:         if self._length <= 1:[0m
   88:             self.tail = None
   89:         return to_return.data
   90:     
   91:     def remove(self, val):
--------------------------------------------------------------------------------
[0.20467 s] [31msurvived[0m
[36m   -[0m [# 217] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
   92:         '''Remove first occurance of val from list.'''
   93:         curr = self.head
   94:         while curr:
   95:             if curr.data is val:
[34m-  96:                 if self._length == 1:[0m
[32m+  96:                 if self._length != 1:[0m
   97:                     (self.head, self.tail) = (None, None)
   98:                 elif (curr is not self.head and curr is not self.tail):
   99:                     (curr.next.prev, curr.prev.next) = (curr.prev, curr.next)
  100:                 elif curr is self.head:
--------------------------------------------------------------------------------
[0.20829 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_12

def test_case_12():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.append(double_linked_list_0)
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_1 = double_linked_list_0.remove(double_linked_list_0)

MIO/test_binarySearchTree3_MIO.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98540a00>
val = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98540a00>

>   ???
E   AttributeError: 'NoneType' object has no attribute 'prev'

binarySearchTree3:101: AttributeError
[36m   -[0m [# 218] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
  181:     
  182:     def _side(self):
  183:         '''Return if left or right child of parent.'''
  184:         if self.parent:
[34m- 185:             return 'left' if self.parent.left == self else 'right'[0m
[32m+ 185:             return 'left' if self.parent.left != self else 'right'[0m
  186: 
  187: 
  188: class Bst(object):
  189:     '''Binary Search Tree.
--------------------------------------------------------------------------------
[0.20213 s] [31msurvived[0m
[36m   -[0m [# 219] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
  243:             self._step(val, self.root)
  244:     
  245:     def _step(self, val, curr):
  246:         '''Decide left or right and returns height.'''
[34m- 247:         if val < curr.val:[0m
[32m+ 247:         if val > curr.val:[0m
  248:             curr = self._set_child(curr, 'left', val)
  249:         elif val > curr.val:
  250:             curr = self._set_child(curr, 'right', val)
  251:         return curr.height
--------------------------------------------------------------------------------
[0.23438 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_0 = bst_0.balance()
>       assert var_0 == -1
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:258: AssertionError
[36m   -[0m [# 220] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
  243:             self._step(val, self.root)
  244:     
  245:     def _step(self, val, curr):
  246:         '''Decide left or right and returns height.'''
[34m- 247:         if val < curr.val:[0m
[32m+ 247:         if val <= curr.val:[0m
  248:             curr = self._set_child(curr, 'left', val)
  249:         elif val > curr.val:
  250:             curr = self._set_child(curr, 'right', val)
  251:         return curr.height
--------------------------------------------------------------------------------
[0.23178 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_0 = bst_0.balance()
>       assert var_0 == -1
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:258: AssertionError
[36m   -[0m [# 221] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
  245:     def _step(self, val, curr):
  246:         '''Decide left or right and returns height.'''
  247:         if val < curr.val:
  248:             curr = self._set_child(curr, 'left', val)
[34m- 249:         elif val > curr.val:[0m
[32m+ 249:         elif val < curr.val:[0m
  250:             curr = self._set_child(curr, 'right', val)
  251:         return curr.height
  252:     
  253:     def _set_child(self, curr, side, val):
--------------------------------------------------------------------------------
[0.36044 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_0 = bst_0.balance()
>       assert var_0 == -1
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:258: AssertionError
[36m   -[0m [# 222] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
  245:     def _step(self, val, curr):
  246:         '''Decide left or right and returns height.'''
  247:         if val < curr.val:
  248:             curr = self._set_child(curr, 'left', val)
[34m- 249:         elif val > curr.val:[0m
[32m+ 249:         elif val >= curr.val:[0m
  250:             curr = self._set_child(curr, 'right', val)
  251:         return curr.height
  252:     
  253:     def _set_child(self, curr, side, val):
--------------------------------------------------------------------------------
[0.20399 s] [31msurvived[0m
[36m   -[0m [# 223] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
  254:         '''Helping.'''
  255:         child = getattr(curr, side)
  256:         if child:
  257:             count = self._step(val, child)
[34m- 258:             if curr.height <= count:[0m
[32m+ 258:             if curr.height >= count:[0m
  259:                 curr.height += 1
  260:         else:
  261:             setattr(curr, side, Node(val, curr))
  262:             self._size += 1
--------------------------------------------------------------------------------
[0.23376 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_0 = bst_0.balance()
>       assert var_0 == -1
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:258: AssertionError
[36m   -[0m [# 224] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
  254:         '''Helping.'''
  255:         child = getattr(curr, side)
  256:         if child:
  257:             count = self._step(val, child)
[34m- 258:             if curr.height <= count:[0m
[32m+ 258:             if curr.height < count:[0m
  259:                 curr.height += 1
  260:         else:
  261:             setattr(curr, side, Node(val, curr))
  262:             self._size += 1
--------------------------------------------------------------------------------
[0.23041 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_0 = bst_0.balance()
>       assert var_0 == -1
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:258: AssertionError
[36m   -[0m [# 225] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
  259:                 curr.height += 1
  260:         else:
  261:             setattr(curr, side, Node(val, curr))
  262:             self._size += 1
[34m- 263:             if curr.height == 1:[0m
[32m+ 263:             if curr.height != 1:[0m
  264:                 curr.height += 1
  265:         return curr
  266:     
  267:     def search(self, val):
--------------------------------------------------------------------------------
[0.20058 s] [31msurvived[0m
[36m   -[0m [# 226] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
  267:     def search(self, val):
  268:         '''Return the node containing val.'''
  269:         curr = self.root
  270:         while curr:
[34m- 271:             if curr.val == val:[0m
[32m+ 271:             if curr.val != val:[0m
  272:                 return curr
  273:             elif val < curr.val:
  274:                 curr = curr.left
  275:             else:
--------------------------------------------------------------------------------
[0.21848 s] [36mincompetent[0m

TypeError: binarySearchTree3:273: TypeError: '<' not supported between instances of 'Bst' and 'Bst'

[36m   -[0m [# 227] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
  269:         curr = self.root
  270:         while curr:
  271:             if curr.val == val:
  272:                 return curr
[34m- 273:             elif val < curr.val:[0m
[32m+ 273:             elif val > curr.val:[0m
  274:                 curr = curr.left
  275:             else:
  276:                 curr = curr.right
  277:     
--------------------------------------------------------------------------------
[0.20014 s] [31msurvived[0m
[36m   -[0m [# 228] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
  269:         curr = self.root
  270:         while curr:
  271:             if curr.val == val:
  272:                 return curr
[34m- 273:             elif val < curr.val:[0m
[32m+ 273:             elif val <= curr.val:[0m
  274:                 curr = curr.left
  275:             else:
  276:                 curr = curr.right
  277:     
--------------------------------------------------------------------------------
[0.20072 s] [31msurvived[0m
[36m   -[0m [# 229] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
  306:         return leftbranch - rightbranch
  307:     
  308:     def pre_order(self, node='root'):
  309:         '''Depth first pre-order traversal of tree.'''
[34m- 310:         if node == 'root':[0m
[32m+ 310:         if node != 'root':[0m
  311:             node = self.root
  312:         
  313:         if not node:
  314:             return
--------------------------------------------------------------------------------
[0.34229 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_36

def test_case_36():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.pre_order()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b9888a3b0>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'val'

binarySearchTree3:316: AttributeError
[36m   -[0m [# 230] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
  321:             yield n
  322:     
  323:     def in_order(self, node='root'):
  324:         '''Depth first in-order traversal of tree.'''
[34m- 325:         if node == 'root':[0m
[32m+ 325:         if node != 'root':[0m
  326:             node = self.root
  327:         
  328:         if not node:
  329:             return
--------------------------------------------------------------------------------
[0.23628 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_38

def test_case_38():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.in_order()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:306: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98d07eb0>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

binarySearchTree3:331: AttributeError
[36m   -[0m [# 231] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
  335:             yield n
  336:     
  337:     def post_order(self, node='root'):
  338:         '''Depth frist post_order traversal of tree.'''
[34m- 339:         if node == 'root':[0m
[32m+ 339:         if node != 'root':[0m
  340:             node = self.root
  341:         
  342:         if not node:
  343:             return
--------------------------------------------------------------------------------
[0.23619 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_39

def test_case_39():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.post_order()
        var_1 = bst_0.size()
        assert var_1 == 0
        var_2 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:320: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98a28790>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

binarySearchTree3:345: AttributeError
[36m   -[0m [# 232] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
  361:                 q.enqueue(node.right)
  362:     
  363:     def delete(self, val):
  364:         '''Remove a node from the tree.'''
[34m- 365:         if (self._size < 1 or not (self.contains(val))):[0m
[32m+ 365:         if (self._size > 1 or not (self.contains(val))):[0m
  366:             return
  367:         
  368:         node = self.search(val)
  369:         
--------------------------------------------------------------------------------
[0.32676 s] [31msurvived[0m
[36m   -[0m [# 233] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
  361:                 q.enqueue(node.right)
  362:     
  363:     def delete(self, val):
  364:         '''Remove a node from the tree.'''
[34m- 365:         if (self._size < 1 or not (self.contains(val))):[0m
[32m+ 365:         if (self._size <= 1 or not (self.contains(val))):[0m
  366:             return
  367:         
  368:         node = self.search(val)
  369:         
--------------------------------------------------------------------------------
[0.22027 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_1 = bst_0.delete(bst_0)
>       assert bst_0.root is None
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:179: AssertionError
[36m   -[0m [# 234] ROR binarySearchTree3: 
--------------------------------------------------------------------------------
  394:         if node.right:
  395:             return self._findmin(node.right)
  396:         
  397:         elif node.parent:
[34m- 398:             if node._side() == 'left':[0m
[32m+ 398:             if node._side() != 'left':[0m
  399:                 return self.parent
  400:             else:
  401:                 node.parent.right = None
  402:                 tmp = self._find_replacement(node.parent)
--------------------------------------------------------------------------------
[0.18078 s] [31msurvived[0m
[36m   -[0m [# 235] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
    2: 
    3: class NodeDLL(object):
    4:     '''Node class for data storage.'''
    5:     
[34m-   6:     def __init__(self, data=None, next_node=None, prev=None):[0m
[34m-   7:         '''Initialize Node.'''[0m
[34m-   8:         self.data = data[0m
[34m-   9:         self.next = next_node[0m
[34m-  10:         self.prev = prev[0m
[34m-  11:     [0m
[32m+   6:     @staticmethod[0m
[32m+   7:     def __init__(self, data=None, next_node=None, prev=None):[0m
[32m+   8:         '''Initialize Node.'''[0m
[32m+   9:         self.data = data[0m
[32m+  10:         self.next = next_node[0m
[32m+  11:         self.prev = prev[0m
   12:     def __repr__(self):
   13:         '''String representation.'''
   14:         return 'Value: {}'.format(self.data)
   15: 
--------------------------------------------------------------------------------
[0.19652 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_0

def test_case_0():
        bytes_0 = b'E\x9c\xce\xc8G'
>       double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)

MIO/test_binarySearchTree3_MIO.py:7: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:36: in __init__
    ???
binarySearchTree3:44: in push
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 69, data = None, next_node = None, prev = None

>   ???
E   AttributeError: 'int' object has no attribute 'data'

binarySearchTree3:9: AttributeError
[36m   -[0m [# 236] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
    8:         self.data = data
    9:         self.next = next_node
   10:         self.prev = prev
   11:     
[34m-  12:     def __repr__(self):[0m
[34m-  13:         '''String representation.'''[0m
[34m-  14:         return 'Value: {}'.format(self.data)[0m
[34m-  15: [0m
[32m+  12:     @staticmethod[0m
[32m+  13:     def __repr__(self):[0m
[32m+  14:         '''String representation.'''[0m
[32m+  15:         return 'Value: {}'.format(self.data)[0m
   16: 
   17: class DoubleLinkedList(object):
   18:     '''Double linked list impplementation.
   19: 
--------------------------------------------------------------------------------
[0.22260 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments/binarySearchTree3/MIO/test_binarySearchTree3_MIO.py:369: TypeError: NodeDLL.__repr__() missing 1 required positional argument: 'self'

[36m   -[0m [# 237] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
   25:     remove(val) - will remove the first instance of (val) found in the list,
   26:     starting from the head.
   27:     '''
   28:     
[34m-  29:     def __init__(self, data=None):[0m
[34m-  30:         '''Initialize list.'''[0m
[34m-  31:         self.head = None[0m
[34m-  32:         self.tail = None[0m
[34m-  33:         self._length = 0[0m
[34m-  34:         try:[0m
[34m-  35:             for val in data:[0m
[34m-  36:                 self.push(val)[0m
[34m-  37:         except TypeError:[0m
[34m-  38:             if data:[0m
[34m-  39:                 self.push(data)[0m
[34m-  40:     [0m
[32m+  29:     @staticmethod[0m
[32m+  30:     def __init__(self, data=None):[0m
[32m+  31:         '''Initialize list.'''[0m
[32m+  32:         self.head = None[0m
[32m+  33:         self.tail = None[0m
[32m+  34:         self._length = 0[0m
[32m+  35:         try:[0m
[32m+  36:             for val in data:[0m
[32m+  37:                 self.push(val)[0m
[32m+  38:         except TypeError:[0m
[32m+  39:             if data:[0m
[32m+  40:                 self.push(data)[0m
   41:     def push(self, val):
   42:         '''Add val to the head of the list.'''
   43:         old_head = self.head
   44:         self.head = NodeDLL(val, next_node=old_head)
--------------------------------------------------------------------------------
[0.32625 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_0

def test_case_0():
        bytes_0 = b'E\x9c\xce\xc8G'
>       double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)

MIO/test_binarySearchTree3_MIO.py:7: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = b'E\x9c\xce\xc8G', data = None

>   ???
E   AttributeError: 'bytes' object has no attribute 'head'

binarySearchTree3:32: AttributeError
[36m   -[0m [# 238] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
   37:         except TypeError:
   38:             if data:
   39:                 self.push(data)
   40:     
[34m-  41:     def push(self, val):[0m
[34m-  42:         '''Add val to the head of the list.'''[0m
[34m-  43:         old_head = self.head[0m
[34m-  44:         self.head = NodeDLL(val, next_node=old_head)[0m
[34m-  45:         if old_head:[0m
[34m-  46:             old_head.prev = self.head[0m
[34m-  47:         if not (self.tail):[0m
[34m-  48:             self.tail = self.head[0m
[34m-  49:         self._length += 1[0m
[34m-  50:     [0m
[32m+  41:     @staticmethod[0m
[32m+  42:     def push(self, val):[0m
[32m+  43:         '''Add val to the head of the list.'''[0m
[32m+  44:         old_head = self.head[0m
[32m+  45:         self.head = NodeDLL(val, next_node=old_head)[0m
[32m+  46:         if old_head:[0m
[32m+  47:             old_head.prev = self.head[0m
[32m+  48:         if not (self.tail):[0m
[32m+  49:             self.tail = self.head[0m
[32m+  50:         self._length += 1[0m
   51:     def pop(self):
   52:         '''Remove the val from the head of the list.'''
   53:         to_return = self.head
   54:         if self._length < 1:
--------------------------------------------------------------------------------
[0.19611 s] [36mincompetent[0m

TypeError: binarySearchTree3:39: TypeError: DoubleLinkedList.push() missing 1 required positional argument: 'val'

[36m   -[0m [# 239] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
   47:         if not (self.tail):
   48:             self.tail = self.head
   49:         self._length += 1
   50:     
[34m-  51:     def pop(self):[0m
[34m-  52:         '''Remove the val from the head of the list.'''[0m
[34m-  53:         to_return = self.head[0m
[34m-  54:         if self._length < 1:[0m
[34m-  55:             raise IndexError('Cannot pop from an empty list.')[0m
[34m-  56:         [0m
[34m-  57:         new_head = self.head.next[0m
[34m-  58:         if new_head:[0m
[34m-  59:             new_head.prev = None[0m
[34m-  60:         self.head = new_head[0m
[34m-  61:         self._length -= 1[0m
[34m-  62:         if self._length < 1:[0m
[34m-  63:             self.tail = None[0m
[34m-  64:         return to_return.data[0m
[34m-  65:     [0m
[32m+  51:     @staticmethod[0m
[32m+  52:     def pop(self):[0m
[32m+  53:         '''Remove the val from the head of the list.'''[0m
[32m+  54:         to_return = self.head[0m
[32m+  55:         if self._length < 1:[0m
[32m+  56:             raise IndexError('Cannot pop from an empty list.')[0m
[32m+  57:         [0m
[32m+  58:         new_head = self.head.next[0m
[32m+  59:         if new_head:[0m
[32m+  60:             new_head.prev = None[0m
[32m+  61:         self.head = new_head[0m
[32m+  62:         self._length -= 1[0m
[32m+  63:         if self._length < 1:[0m
[32m+  64:             self.tail = None[0m
[32m+  65:         return to_return.data[0m
   66:     def append(self, val):
   67:         '''Add val to the tail of the list.'''
   68:         old_tail = self.tail
   69:         self.tail = NodeDLL(val, prev=old_tail)
--------------------------------------------------------------------------------
[0.20103 s] [36mincompetent[0m

TypeError: binarySearchTree3:143: TypeError: DoubleLinkedList.pop() missing 1 required positional argument: 'self'

[36m   -[0m [# 240] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
   62:         if self._length < 1:
   63:             self.tail = None
   64:         return to_return.data
   65:     
[34m-  66:     def append(self, val):[0m
[34m-  67:         '''Add val to the tail of the list.'''[0m
[34m-  68:         old_tail = self.tail[0m
[34m-  69:         self.tail = NodeDLL(val, prev=old_tail)[0m
[34m-  70:         if old_tail:[0m
[34m-  71:             old_tail.next = self.tail[0m
[34m-  72:         if self._length < 1:[0m
[34m-  73:             self.head = self.tail[0m
[34m-  74:         self._length += 1[0m
[34m-  75:     [0m
[32m+  66:     @staticmethod[0m
[32m+  67:     def append(self, val):[0m
[32m+  68:         '''Add val to the tail of the list.'''[0m
[32m+  69:         old_tail = self.tail[0m
[32m+  70:         self.tail = NodeDLL(val, prev=old_tail)[0m
[32m+  71:         if old_tail:[0m
[32m+  72:             old_tail.next = self.tail[0m
[32m+  73:         if self._length < 1:[0m
[32m+  74:             self.head = self.tail[0m
[32m+  75:         self._length += 1[0m
   76:     def shift(self):
   77:         '''Remove the val from the tail of the list.'''
   78:         to_return = self.tail
   79:         if self._length < 1:
--------------------------------------------------------------------------------
[0.19006 s] [36mincompetent[0m

TypeError: binarySearchTree3:139: TypeError: DoubleLinkedList.append() missing 1 required positional argument: 'val'

[36m   -[0m [# 241] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
   72:         if self._length < 1:
   73:             self.head = self.tail
   74:         self._length += 1
   75:     
[34m-  76:     def shift(self):[0m
[34m-  77:         '''Remove the val from the tail of the list.'''[0m
[34m-  78:         to_return = self.tail[0m
[34m-  79:         if self._length < 1:[0m
[34m-  80:             raise IndexError('Cannot shift from an empty list.')[0m
[34m-  81:         [0m
[34m-  82:         new_tail = self.tail.prev[0m
[34m-  83:         if new_tail:[0m
[34m-  84:             new_tail.next = None[0m
[34m-  85:         self.tail = new_tail[0m
[34m-  86:         self._length -= 1[0m
[34m-  87:         if self._length < 1:[0m
[34m-  88:             self.tail = None[0m
[34m-  89:         return to_return.data[0m
[34m-  90:     [0m
[32m+  76:     @staticmethod[0m
[32m+  77:     def shift(self):[0m
[32m+  78:         '''Remove the val from the tail of the list.'''[0m
[32m+  79:         to_return = self.tail[0m
[32m+  80:         if self._length < 1:[0m
[32m+  81:             raise IndexError('Cannot shift from an empty list.')[0m
[32m+  82:         [0m
[32m+  83:         new_tail = self.tail.prev[0m
[32m+  84:         if new_tail:[0m
[32m+  85:             new_tail.next = None[0m
[32m+  86:         self.tail = new_tail[0m
[32m+  87:         self._length -= 1[0m
[32m+  88:         if self._length < 1:[0m
[32m+  89:             self.tail = None[0m
[32m+  90:         return to_return.data[0m
   91:     def remove(self, val):
   92:         '''Remove first occurance of val from list.'''
   93:         curr = self.head
   94:         while curr:
--------------------------------------------------------------------------------
[0.20477 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments/binarySearchTree3/MIO/test_binarySearchTree3_MIO.py:73: TypeError: DoubleLinkedList.shift() missing 1 required positional argument: 'self'

[36m   -[0m [# 242] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
   87:         if self._length < 1:
   88:             self.tail = None
   89:         return to_return.data
   90:     
[34m-  91:     def remove(self, val):[0m
[34m-  92:         '''Remove first occurance of val from list.'''[0m
[34m-  93:         curr = self.head[0m
[34m-  94:         while curr:[0m
[34m-  95:             if curr.data is val:[0m
[34m-  96:                 if self._length == 1:[0m
[34m-  97:                     (self.head, self.tail) = (None, None)[0m
[34m-  98:                 elif (curr is not self.head and curr is not self.tail):[0m
[34m-  99:                     (curr.next.prev, curr.prev.next) = (curr.prev, curr.next)[0m
[34m- 100:                 elif curr is self.head:[0m
[34m- 101:                     (self.head, curr.next.prev) = (curr.next, None)[0m
[34m- 102:                 elif curr is self.tail:[0m
[34m- 103:                     (self.tail, curr.prev.next) = (curr.prev, None)[0m
[34m- 104:                 self._length -= 1[0m
[34m- 105:                 return[0m
[34m- 106:             curr = curr.next[0m
[34m- 107:         [0m
[34m- 108:         raise ValueError('{} is not in the list'.format(val))[0m
[34m- 109:     [0m
[32m+  91:     @staticmethod[0m
[32m+  92:     def remove(self, val):[0m
[32m+  93:         '''Remove first occurance of val from list.'''[0m
[32m+  94:         curr = self.head[0m
[32m+  95:         while curr:[0m
[32m+  96:             if curr.data is val:[0m
[32m+  97:                 if self._length == 1:[0m
[32m+  98:                     (self.head, self.tail) = (None, None)[0m
[32m+  99:                 elif (curr is not self.head and curr is not self.tail):[0m
[32m+ 100:                     (curr.next.prev, curr.prev.next) = (curr.prev, curr.next)[0m
[32m+ 101:                 elif curr is self.head:[0m
[32m+ 102:                     (self.head, curr.next.prev) = (curr.next, None)[0m
[32m+ 103:                 elif curr is self.tail:[0m
[32m+ 104:                     (self.tail, curr.prev.next) = (curr.prev, None)[0m
[32m+ 105:                 self._length -= 1[0m
[32m+ 106:                 return[0m
[32m+ 107:             curr = curr.next[0m
[32m+ 108:         [0m
[32m+ 109:         raise ValueError('{} is not in the list'.format(val))[0m
  110:     def _repr(self):
  111:         '''Return list representation of dll.'''
  112:         l = []
  113:         while True:
--------------------------------------------------------------------------------
[0.32421 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments/binarySearchTree3/MIO/test_binarySearchTree3_MIO.py:104: TypeError: DoubleLinkedList.remove() missing 1 required positional argument: 'val'

[36m   -[0m [# 243] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  106:             curr = curr.next
  107:         
  108:         raise ValueError('{} is not in the list'.format(val))
  109:     
[34m- 110:     def _repr(self):[0m
[34m- 111:         '''Return list representation of dll.'''[0m
[34m- 112:         l = [][0m
[34m- 113:         while True:[0m
[34m- 114:             try:[0m
[34m- 115:                 popped_data = self.pop()[0m
[34m- 116:                 l.append(popped_data)[0m
[34m- 117:             except IndexError:[0m
[34m- 118:                 break[0m
[34m- 119:         return l[0m
[34m- 120: [0m
[32m+ 110:     @staticmethod[0m
[32m+ 111:     def _repr(self):[0m
[32m+ 112:         '''Return list representation of dll.'''[0m
[32m+ 113:         l = [][0m
[32m+ 114:         while True:[0m
[32m+ 115:             try:[0m
[32m+ 116:                 popped_data = self.pop()[0m
[32m+ 117:                 l.append(popped_data)[0m
[32m+ 118:             except IndexError:[0m
[32m+ 119:                 break[0m
[32m+ 120:         return l[0m
  121: class Queue(object):
  122:     '''Implementation of Queue.
  123: 
  124:     This implementation supports the following public methods:
--------------------------------------------------------------------------------
[0.20015 s] [31msurvived[0m
[36m   -[0m [# 244] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  129:     If the queue is empty, returns None
  130:     size(): return the size of the queue. Returns 0 if the queue is empty.
  131:     '''
  132:     
[34m- 133:     def __init__(self, data=None):[0m
[34m- 134:         '''Initialize queue data structure.'''[0m
[34m- 135:         self._container = DoubleLinkedList(data)[0m
[34m- 136:     [0m
[32m+ 133:     @staticmethod[0m
[32m+ 134:     def __init__(self, data=None):[0m
[32m+ 135:         '''Initialize queue data structure.'''[0m
[32m+ 136:         self._container = DoubleLinkedList(data)[0m
  137:     def enqueue(self, val):
  138:         '''Add a value to the queue.'''
  139:         self._container.append(val)
  140:     
--------------------------------------------------------------------------------
[0.19877 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_4

def test_case_4():
        str_0 = 'aX}B^sw\x0cA!<Uq;!!D9'
>       queue_0 = module_0.Queue(str_0)

MIO/test_binarySearchTree3_MIO.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = 'aX}B^sw\x0cA!<Uq;!!D9', data = None

>   ???
E   AttributeError: 'str' object has no attribute '_container'

binarySearchTree3:136: AttributeError
[36m   -[0m [# 245] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  133:     def __init__(self, data=None):
  134:         '''Initialize queue data structure.'''
  135:         self._container = DoubleLinkedList(data)
  136:     
[34m- 137:     def enqueue(self, val):[0m
[34m- 138:         '''Add a value to the queue.'''[0m
[34m- 139:         self._container.append(val)[0m
[34m- 140:     [0m
[32m+ 137:     @staticmethod[0m
[32m+ 138:     def enqueue(self, val):[0m
[32m+ 139:         '''Add a value to the queue.'''[0m
[32m+ 140:         self._container.append(val)[0m
  141:     def dequeue(self):
  142:         '''Remove a value from the front of the queue.'''
  143:         return self._container.pop()
  144:     
--------------------------------------------------------------------------------
[0.20885 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments/binarySearchTree3/MIO/test_binarySearchTree3_MIO.py:56: TypeError: Queue.enqueue() missing 1 required positional argument: 'val'

[36m   -[0m [# 246] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  137:     def enqueue(self, val):
  138:         '''Add a value to the queue.'''
  139:         self._container.append(val)
  140:     
[34m- 141:     def dequeue(self):[0m
[34m- 142:         '''Remove a value from the front of the queue.'''[0m
[34m- 143:         return self._container.pop()[0m
[34m- 144:     [0m
[32m+ 141:     @staticmethod[0m
[32m+ 142:     def dequeue(self):[0m
[32m+ 143:         '''Remove a value from the front of the queue.'''[0m
[32m+ 144:         return self._container.pop()[0m
  145:     def peek(self):
  146:         '''Return the next value in the queue without dequing it.'''
  147:         try:
  148:             return self._container.head.data
--------------------------------------------------------------------------------
[0.19998 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments/binarySearchTree3/MIO/test_binarySearchTree3_MIO.py:36: TypeError: Queue.dequeue() missing 1 required positional argument: 'self'

[36m   -[0m [# 247] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  141:     def dequeue(self):
  142:         '''Remove a value from the front of the queue.'''
  143:         return self._container.pop()
  144:     
[34m- 145:     def peek(self):[0m
[34m- 146:         '''Return the next value in the queue without dequing it.'''[0m
[34m- 147:         try:[0m
[34m- 148:             return self._container.head.data[0m
[34m- 149:         except AttributeError:[0m
[34m- 150:             return None[0m
[34m- 151:     [0m
[32m+ 145:     @staticmethod[0m
[32m+ 146:     def peek(self):[0m
[32m+ 147:         '''Return the next value in the queue without dequing it.'''[0m
[32m+ 148:         try:[0m
[32m+ 149:             return self._container.head.data[0m
[32m+ 150:         except AttributeError:[0m
[32m+ 151:             return None[0m
  152:     def size(self):
  153:         '''Return the size of the queue.'''
  154:         return self._container._length
  155: 
--------------------------------------------------------------------------------
[0.21783 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments/binarySearchTree3/MIO/test_binarySearchTree3_MIO.py:170: TypeError: Queue.peek() missing 1 required positional argument: 'self'

[36m   -[0m [# 248] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  148:             return self._container.head.data
  149:         except AttributeError:
  150:             return None
  151:     
[34m- 152:     def size(self):[0m
[34m- 153:         '''Return the size of the queue.'''[0m
[34m- 154:         return self._container._length[0m
[34m- 155: [0m
[32m+ 152:     @staticmethod[0m
[32m+ 153:     def size(self):[0m
[32m+ 154:         '''Return the size of the queue.'''[0m
[32m+ 155:         return self._container._length[0m
  156: class Node(object):
  157:     '''Node, or leaf of the BST.'''
  158:     
  159:     def __init__(self, val=None, parent=None):
--------------------------------------------------------------------------------
[0.24122 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments/binarySearchTree3/MIO/test_binarySearchTree3_MIO.py:379: TypeError: Queue.size() missing 1 required positional argument: 'self'

[36m   -[0m [# 249] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  155: 
  156: class Node(object):
  157:     '''Node, or leaf of the BST.'''
  158:     
[34m- 159:     def __init__(self, val=None, parent=None):[0m
[34m- 160:         '''Create node object.'''[0m
[34m- 161:         self.val = val[0m
[34m- 162:         self.right = None[0m
[34m- 163:         self.left = None[0m
[34m- 164:         self.parent = parent[0m
[34m- 165:         self.height = 1[0m
[34m- 166:     [0m
[32m+ 159:     @staticmethod[0m
[32m+ 160:     def __init__(self, val=None, parent=None):[0m
[32m+ 161:         '''Create node object.'''[0m
[32m+ 162:         self.val = val[0m
[32m+ 163:         self.right = None[0m
[32m+ 164:         self.left = None[0m
[32m+ 165:         self.parent = parent[0m
[32m+ 166:         self.height = 1[0m
  167:     def _is_leaf(self):
  168:         '''Return true if a leaf.'''
  169:         return not ((self.right or self.left))
  170:     
--------------------------------------------------------------------------------
[0.19567 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments/binarySearchTree3/MIO/test_binarySearchTree3_MIO.py:13: TypeError: Node.__init__() missing 1 required positional argument: 'self'

[36m   -[0m [# 250] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  163:         self.left = None
  164:         self.parent = parent
  165:         self.height = 1
  166:     
[34m- 167:     def _is_leaf(self):[0m
[34m- 168:         '''Return true if a leaf.'''[0m
[34m- 169:         return not ((self.right or self.left))[0m
[34m- 170:     [0m
[32m+ 167:     @staticmethod[0m
[32m+ 168:     def _is_leaf(self):[0m
[32m+ 169:         '''Return true if a leaf.'''[0m
[32m+ 170:         return not ((self.right or self.left))[0m
  171:     def _is_interior(self):
  172:         '''Return true if a interior node.'''
  173:         return (self.right and self.left)
  174:     
--------------------------------------------------------------------------------
[0.34556 s] [36mincompetent[0m

TypeError: binarySearchTree3:370: TypeError: Node._is_leaf() missing 1 required positional argument: 'self'

[36m   -[0m [# 251] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  167:     def _is_leaf(self):
  168:         '''Return true if a leaf.'''
  169:         return not ((self.right or self.left))
  170:     
[34m- 171:     def _is_interior(self):[0m
[34m- 172:         '''Return true if a interior node.'''[0m
[34m- 173:         return (self.right and self.left)[0m
[34m- 174:     [0m
[32m+ 171:     @staticmethod[0m
[32m+ 172:     def _is_interior(self):[0m
[32m+ 173:         '''Return true if a interior node.'''[0m
[32m+ 174:         return (self.right and self.left)[0m
  175:     def _onlychild(self):
  176:         '''Return string depending on children.'''
  177:         if (self.left and not (self.right)):
  178:             return 'left'
--------------------------------------------------------------------------------
[0.19967 s] [31msurvived[0m
[36m   -[0m [# 252] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  171:     def _is_interior(self):
  172:         '''Return true if a interior node.'''
  173:         return (self.right and self.left)
  174:     
[34m- 175:     def _onlychild(self):[0m
[34m- 176:         '''Return string depending on children.'''[0m
[34m- 177:         if (self.left and not (self.right)):[0m
[34m- 178:             return 'left'[0m
[34m- 179:         if (self.right and not (self.left)):[0m
[34m- 180:             return 'right'[0m
[34m- 181:     [0m
[32m+ 175:     @staticmethod[0m
[32m+ 176:     def _onlychild(self):[0m
[32m+ 177:         '''Return string depending on children.'''[0m
[32m+ 178:         if (self.left and not (self.right)):[0m
[32m+ 179:             return 'left'[0m
[32m+ 180:         if (self.right and not (self.left)):[0m
[32m+ 181:             return 'right'[0m
  182:     def _side(self):
  183:         '''Return if left or right child of parent.'''
  184:         if self.parent:
  185:             return 'left' if self.parent.left == self else 'right'
--------------------------------------------------------------------------------
[0.19935 s] [31msurvived[0m
[36m   -[0m [# 253] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  178:             return 'left'
  179:         if (self.right and not (self.left)):
  180:             return 'right'
  181:     
[34m- 182:     def _side(self):[0m
[34m- 183:         '''Return if left or right child of parent.'''[0m
[34m- 184:         if self.parent:[0m
[34m- 185:             return 'left' if self.parent.left == self else 'right'[0m
[34m- 186: [0m
[32m+ 182:     @staticmethod[0m
[32m+ 183:     def _side(self):[0m
[32m+ 184:         '''Return if left or right child of parent.'''[0m
[32m+ 185:         if self.parent:[0m
[32m+ 186:             return 'left' if self.parent.left == self else 'right'[0m
  187: 
  188: class Bst(object):
  189:     '''Binary Search Tree.
  190: 
--------------------------------------------------------------------------------
[0.20349 s] [31msurvived[0m
[36m   -[0m [# 254] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  224:     using breadth frist traversal, one at a time.
  225: 
  226:     '''
  227:     
[34m- 228:     def __init__(self, data=None):[0m
[34m- 229:         '''Initialize tree.'''[0m
[34m- 230:         self._size = 0[0m
[34m- 231:         self.root = None[0m
[34m- 232:         [0m
[34m- 233:         if data:[0m
[34m- 234:             for i in data:[0m
[34m- 235:                 self.insert(i)[0m
[34m- 236:     [0m
[32m+ 228:     @staticmethod[0m
[32m+ 229:     def __init__(self, data=None):[0m
[32m+ 230:         '''Initialize tree.'''[0m
[32m+ 231:         self._size = 0[0m
[32m+ 232:         self.root = None[0m
[32m+ 233:         [0m
[32m+ 234:         if data:[0m
[32m+ 235:             for i in data:[0m
[32m+ 236:                 self.insert(i)[0m
  237:     def insert(self, val):
  238:         '''Insert val into BST. If val is already present will be ignored.'''
  239:         if not (self.root):
  240:             self.root = Node(val)
--------------------------------------------------------------------------------
[0.19887 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments/binarySearchTree3/MIO/test_binarySearchTree3_MIO.py:27: TypeError: Bst.__init__() missing 1 required positional argument: 'self'

[36m   -[0m [# 255] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  233:         if data:
  234:             for i in data:
  235:                 self.insert(i)
  236:     
[34m- 237:     def insert(self, val):[0m
[34m- 238:         '''Insert val into BST. If val is already present will be ignored.'''[0m
[34m- 239:         if not (self.root):[0m
[34m- 240:             self.root = Node(val)[0m
[34m- 241:             self._size += 1[0m
[34m- 242:         else:[0m
[34m- 243:             self._step(val, self.root)[0m
[34m- 244:     [0m
[32m+ 237:     @staticmethod[0m
[32m+ 238:     def insert(self, val):[0m
[32m+ 239:         '''Insert val into BST. If val is already present will be ignored.'''[0m
[32m+ 240:         if not (self.root):[0m
[32m+ 241:             self.root = Node(val)[0m
[32m+ 242:             self._size += 1[0m
[32m+ 243:         else:[0m
[32m+ 244:             self._step(val, self.root)[0m
  245:     def _step(self, val, curr):
  246:         '''Decide left or right and returns height.'''
  247:         if val < curr.val:
  248:             curr = self._set_child(curr, 'left', val)
--------------------------------------------------------------------------------
[0.21661 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments/binarySearchTree3/MIO/test_binarySearchTree3_MIO.py:176: TypeError: Bst.insert() missing 1 required positional argument: 'val'

[36m   -[0m [# 256] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  241:             self._size += 1
  242:         else:
  243:             self._step(val, self.root)
  244:     
[34m- 245:     def _step(self, val, curr):[0m
[34m- 246:         '''Decide left or right and returns height.'''[0m
[34m- 247:         if val < curr.val:[0m
[34m- 248:             curr = self._set_child(curr, 'left', val)[0m
[34m- 249:         elif val > curr.val:[0m
[34m- 250:             curr = self._set_child(curr, 'right', val)[0m
[34m- 251:         return curr.height[0m
[34m- 252:     [0m
[32m+ 245:     @staticmethod[0m
[32m+ 246:     def _step(self, val, curr):[0m
[32m+ 247:         '''Decide left or right and returns height.'''[0m
[32m+ 248:         if val < curr.val:[0m
[32m+ 249:             curr = self._set_child(curr, 'left', val)[0m
[32m+ 250:         elif val > curr.val:[0m
[32m+ 251:             curr = self._set_child(curr, 'right', val)[0m
[32m+ 252:         return curr.height[0m
  253:     def _set_child(self, curr, side, val):
  254:         '''Helping.'''
  255:         child = getattr(curr, side)
  256:         if child:
--------------------------------------------------------------------------------
[0.20018 s] [36mincompetent[0m

TypeError: binarySearchTree3:243: TypeError: Bst._step() missing 1 required positional argument: 'curr'

[36m   -[0m [# 257] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  249:         elif val > curr.val:
  250:             curr = self._set_child(curr, 'right', val)
  251:         return curr.height
  252:     
[34m- 253:     def _set_child(self, curr, side, val):[0m
[34m- 254:         '''Helping.'''[0m
[34m- 255:         child = getattr(curr, side)[0m
[34m- 256:         if child:[0m
[34m- 257:             count = self._step(val, child)[0m
[34m- 258:             if curr.height <= count:[0m
[34m- 259:                 curr.height += 1[0m
[34m- 260:         else:[0m
[34m- 261:             setattr(curr, side, Node(val, curr))[0m
[34m- 262:             self._size += 1[0m
[34m- 263:             if curr.height == 1:[0m
[34m- 264:                 curr.height += 1[0m
[34m- 265:         return curr[0m
[34m- 266:     [0m
[32m+ 253:     @staticmethod[0m
[32m+ 254:     def _set_child(self, curr, side, val):[0m
[32m+ 255:         '''Helping.'''[0m
[32m+ 256:         child = getattr(curr, side)[0m
[32m+ 257:         if child:[0m
[32m+ 258:             count = self._step(val, child)[0m
[32m+ 259:             if curr.height <= count:[0m
[32m+ 260:                 curr.height += 1[0m
[32m+ 261:         else:[0m
[32m+ 262:             setattr(curr, side, Node(val, curr))[0m
[32m+ 263:             self._size += 1[0m
[32m+ 264:             if curr.height == 1:[0m
[32m+ 265:                 curr.height += 1[0m
[32m+ 266:         return curr[0m
  267:     def search(self, val):
  268:         '''Return the node containing val.'''
  269:         curr = self.root
  270:         while curr:
--------------------------------------------------------------------------------
[0.21642 s] [36mincompetent[0m

TypeError: binarySearchTree3:250: TypeError: Bst._set_child() missing 1 required positional argument: 'val'

[36m   -[0m [# 258] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  263:             if curr.height == 1:
  264:                 curr.height += 1
  265:         return curr
  266:     
[34m- 267:     def search(self, val):[0m
[34m- 268:         '''Return the node containing val.'''[0m
[34m- 269:         curr = self.root[0m
[34m- 270:         while curr:[0m
[34m- 271:             if curr.val == val:[0m
[34m- 272:                 return curr[0m
[34m- 273:             elif val < curr.val:[0m
[34m- 274:                 curr = curr.left[0m
[34m- 275:             else:[0m
[34m- 276:                 curr = curr.right[0m
[34m- 277:     [0m
[32m+ 267:     @staticmethod[0m
[32m+ 268:     def search(self, val):[0m
[32m+ 269:         '''Return the node containing val.'''[0m
[32m+ 270:         curr = self.root[0m
[32m+ 271:         while curr:[0m
[32m+ 272:             if curr.val == val:[0m
[32m+ 273:                 return curr[0m
[32m+ 274:             elif val < curr.val:[0m
[32m+ 275:                 curr = curr.left[0m
[32m+ 276:             else:[0m
[32m+ 277:                 curr = curr.right[0m
  278:     def size(self):
  279:         '''Return the size of the BST.'''
  280:         return self._size
  281:     
--------------------------------------------------------------------------------
[0.33870 s] [36mincompetent[0m

TypeError: binarySearchTree3:288: TypeError: Bst.search() missing 1 required positional argument: 'val'

[36m   -[0m [# 259] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  274:                 curr = curr.left
  275:             else:
  276:                 curr = curr.right
  277:     
[34m- 278:     def size(self):[0m
[34m- 279:         '''Return the size of the BST.'''[0m
[34m- 280:         return self._size[0m
[34m- 281:     [0m
[32m+ 278:     @staticmethod[0m
[32m+ 279:     def size(self):[0m
[32m+ 280:         '''Return the size of the BST.'''[0m
[32m+ 281:         return self._size[0m
  282:     def depth(self):
  283:         '''Return depth of the BST, representing total levels.'''
  284:         return 0 if not (self.root) else self.root.height
  285:     
--------------------------------------------------------------------------------
[0.23584 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments/binarySearchTree3/MIO/test_binarySearchTree3_MIO.py:316: TypeError: Bst.size() missing 1 required positional argument: 'self'

[36m   -[0m [# 260] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  278:     def size(self):
  279:         '''Return the size of the BST.'''
  280:         return self._size
  281:     
[34m- 282:     def depth(self):[0m
[34m- 283:         '''Return depth of the BST, representing total levels.'''[0m
[34m- 284:         return 0 if not (self.root) else self.root.height[0m
[34m- 285:     [0m
[32m+ 282:     @staticmethod[0m
[32m+ 283:     def depth(self):[0m
[32m+ 284:         '''Return depth of the BST, representing total levels.'''[0m
[32m+ 285:         return 0 if not (self.root) else self.root.height[0m
  286:     def contains(self, val):
  287:         '''Return true if val is in the bst.'''
  288:         return self.search(val) is not None
  289:     
--------------------------------------------------------------------------------
[0.20461 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments/binarySearchTree3/MIO/test_binarySearchTree3_MIO.py:242: TypeError: Bst.depth() missing 1 required positional argument: 'self'

[36m   -[0m [# 261] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  282:     def depth(self):
  283:         '''Return depth of the BST, representing total levels.'''
  284:         return 0 if not (self.root) else self.root.height
  285:     
[34m- 286:     def contains(self, val):[0m
[34m- 287:         '''Return true if val is in the bst.'''[0m
[34m- 288:         return self.search(val) is not None[0m
[34m- 289:     [0m
[32m+ 286:     @staticmethod[0m
[32m+ 287:     def contains(self, val):[0m
[32m+ 288:         '''Return true if val is in the bst.'''[0m
[32m+ 289:         return self.search(val) is not None[0m
  290:     def balance(self, tree=None):
  291:         '''Return an integer of how well the tree is balanced.
  292: 
  293:         Trees which are higher on the left than the right should return a
--------------------------------------------------------------------------------
[0.21688 s] [36mincompetent[0m

TypeError: binarySearchTree3:365: TypeError: Bst.contains() missing 1 required positional argument: 'val'

[36m   -[0m [# 262] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  286:     def contains(self, val):
  287:         '''Return true if val is in the bst.'''
  288:         return self.search(val) is not None
  289:     
[34m- 290:     def balance(self, tree=None):[0m
[34m- 291:         '''Return an integer of how well the tree is balanced.[0m
[34m- 292: [0m
[34m- 293:         Trees which are higher on the left than the right should return a[0m
[34m- 294:         positive value, trees which are higher on the right than the left[0m
[34m- 295:         should return a negative value. An ideally-balanced tree should[0m
[34m- 296:         return 0.[0m
[34m- 297:         '''[0m
[34m- 298:         if not tree:[0m
[34m- 299:             tree = self.root[0m
[34m- 300:             if not tree:[0m
[34m- 301:                 return 0[0m
[34m- 302:         [0m
[34m- 303:         leftbranch = 0 if not (tree.left) else tree.left.height[0m
[34m- 304:         rightbranch = 0 if not (tree.right) else tree.right.height[0m
[34m- 305:         [0m
[34m- 306:         return leftbranch - rightbranch[0m
[34m- 307:     [0m
[32m+ 290:     @staticmethod[0m
[32m+ 291:     def balance(self, tree=None):[0m
[32m+ 292:         '''Return an integer of how well the tree is balanced.[0m
[32m+ 293: [0m
[32m+ 294:         Trees which are higher on the left than the right should return a[0m
[32m+ 295:         positive value, trees which are higher on the right than the left[0m
[32m+ 296:         should return a negative value. An ideally-balanced tree should[0m
[32m+ 297:         return 0.[0m
[32m+ 298:         '''[0m
[32m+ 299:         if not tree:[0m
[32m+ 300:             tree = self.root[0m
[32m+ 301:             if not tree:[0m
[32m+ 302:                 return 0[0m
[32m+ 303:         [0m
[32m+ 304:         leftbranch = 0 if not (tree.left) else tree.left.height[0m
[32m+ 305:         rightbranch = 0 if not (tree.right) else tree.right.height[0m
[32m+ 306:         [0m
[32m+ 307:         return leftbranch - rightbranch[0m
  308:     def pre_order(self, node='root'):
  309:         '''Depth first pre-order traversal of tree.'''
  310:         if node == 'root':
  311:             node = self.root
--------------------------------------------------------------------------------
[0.22836 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments/binarySearchTree3/MIO/test_binarySearchTree3_MIO.py:257: TypeError: Bst.balance() missing 1 required positional argument: 'self'

[36m   -[0m [# 263] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  304:         rightbranch = 0 if not (tree.right) else tree.right.height
  305:         
  306:         return leftbranch - rightbranch
  307:     
[34m- 308:     def pre_order(self, node='root'):[0m
[34m- 309:         '''Depth first pre-order traversal of tree.'''[0m
[34m- 310:         if node == 'root':[0m
[34m- 311:             node = self.root[0m
[34m- 312:         [0m
[34m- 313:         if not node:[0m
[34m- 314:             return[0m
[34m- 315:         [0m
[34m- 316:         yield node.val[0m
[34m- 317:         [0m
[34m- 318:         for n in self.pre_order(node=node.left):[0m
[34m- 319:             yield n[0m
[34m- 320:         for n in self.pre_order(node=node.right):[0m
[34m- 321:             yield n[0m
[34m- 322:     [0m
[32m+ 308:     @staticmethod[0m
[32m+ 309:     def pre_order(self, node='root'):[0m
[32m+ 310:         '''Depth first pre-order traversal of tree.'''[0m
[32m+ 311:         if node == 'root':[0m
[32m+ 312:             node = self.root[0m
[32m+ 313:         [0m
[32m+ 314:         if not node:[0m
[32m+ 315:             return[0m
[32m+ 316:         [0m
[32m+ 317:         yield node.val[0m
[32m+ 318:         [0m
[32m+ 319:         for n in self.pre_order(node=node.left):[0m
[32m+ 320:             yield n[0m
[32m+ 321:         for n in self.pre_order(node=node.right):[0m
[32m+ 322:             yield n[0m
  323:     def in_order(self, node='root'):
  324:         '''Depth first in-order traversal of tree.'''
  325:         if node == 'root':
  326:             node = self.root
--------------------------------------------------------------------------------
[0.34394 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments/binarySearchTree3/MIO/test_binarySearchTree3_MIO.py:285: TypeError: Bst.pre_order() missing 1 required positional argument: 'self'

[36m   -[0m [# 264] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  319:             yield n
  320:         for n in self.pre_order(node=node.right):
  321:             yield n
  322:     
[34m- 323:     def in_order(self, node='root'):[0m
[34m- 324:         '''Depth first in-order traversal of tree.'''[0m
[34m- 325:         if node == 'root':[0m
[34m- 326:             node = self.root[0m
[34m- 327:         [0m
[34m- 328:         if not node:[0m
[34m- 329:             return[0m
[34m- 330:         [0m
[34m- 331:         for n in self.in_order(node=node.left):[0m
[34m- 332:             yield n[0m
[34m- 333:         yield node.val[0m
[34m- 334:         for n in self.in_order(node=node.right):[0m
[34m- 335:             yield n[0m
[34m- 336:     [0m
[32m+ 323:     @staticmethod[0m
[32m+ 324:     def in_order(self, node='root'):[0m
[32m+ 325:         '''Depth first in-order traversal of tree.'''[0m
[32m+ 326:         if node == 'root':[0m
[32m+ 327:             node = self.root[0m
[32m+ 328:         [0m
[32m+ 329:         if not node:[0m
[32m+ 330:             return[0m
[32m+ 331:         [0m
[32m+ 332:         for n in self.in_order(node=node.left):[0m
[32m+ 333:             yield n[0m
[32m+ 334:         yield node.val[0m
[32m+ 335:         for n in self.in_order(node=node.right):[0m
[32m+ 336:             yield n[0m
  337:     def post_order(self, node='root'):
  338:         '''Depth frist post_order traversal of tree.'''
  339:         if node == 'root':
  340:             node = self.root
--------------------------------------------------------------------------------
[0.22821 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments/binarySearchTree3/MIO/test_binarySearchTree3_MIO.py:305: TypeError: Bst.in_order() missing 1 required positional argument: 'self'

[36m   -[0m [# 265] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  333:         yield node.val
  334:         for n in self.in_order(node=node.right):
  335:             yield n
  336:     
[34m- 337:     def post_order(self, node='root'):[0m
[34m- 338:         '''Depth frist post_order traversal of tree.'''[0m
[34m- 339:         if node == 'root':[0m
[34m- 340:             node = self.root[0m
[34m- 341:         [0m
[34m- 342:         if not node:[0m
[34m- 343:             return[0m
[34m- 344:         [0m
[34m- 345:         for n in self.post_order(node=node.left):[0m
[34m- 346:             yield n[0m
[34m- 347:         for n in self.post_order(node=node.right):[0m
[34m- 348:             yield n[0m
[34m- 349:         yield node.val[0m
[34m- 350:     [0m
[32m+ 337:     @staticmethod[0m
[32m+ 338:     def post_order(self, node='root'):[0m
[32m+ 339:         '''Depth frist post_order traversal of tree.'''[0m
[32m+ 340:         if node == 'root':[0m
[32m+ 341:             node = self.root[0m
[32m+ 342:         [0m
[32m+ 343:         if not node:[0m
[32m+ 344:             return[0m
[32m+ 345:         [0m
[32m+ 346:         for n in self.post_order(node=node.left):[0m
[32m+ 347:             yield n[0m
[32m+ 348:         for n in self.post_order(node=node.right):[0m
[32m+ 349:             yield n[0m
[32m+ 350:         yield node.val[0m
  351:     def breadth_first(self):
  352:         '''Breadth first traversal of tree.'''
  353:         q = Queue()
  354:         q.enqueue(self.root)
--------------------------------------------------------------------------------
[0.23355 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments/binarySearchTree3/MIO/test_binarySearchTree3_MIO.py:315: TypeError: Bst.post_order() missing 1 required positional argument: 'self'

[36m   -[0m [# 266] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  347:         for n in self.post_order(node=node.right):
  348:             yield n
  349:         yield node.val
  350:     
[34m- 351:     def breadth_first(self):[0m
[34m- 352:         '''Breadth first traversal of tree.'''[0m
[34m- 353:         q = Queue()[0m
[34m- 354:         q.enqueue(self.root)[0m
[34m- 355:         while q.peek():[0m
[34m- 356:             node = q.dequeue()[0m
[34m- 357:             yield node.val[0m
[34m- 358:             if node.left:[0m
[34m- 359:                 q.enqueue(node.left)[0m
[34m- 360:             if node.right:[0m
[34m- 361:                 q.enqueue(node.right)[0m
[34m- 362:     [0m
[32m+ 351:     @staticmethod[0m
[32m+ 352:     def breadth_first(self):[0m
[32m+ 353:         '''Breadth first traversal of tree.'''[0m
[32m+ 354:         q = Queue()[0m
[32m+ 355:         q.enqueue(self.root)[0m
[32m+ 356:         while q.peek():[0m
[32m+ 357:             node = q.dequeue()[0m
[32m+ 358:             yield node.val[0m
[32m+ 359:             if node.left:[0m
[32m+ 360:                 q.enqueue(node.left)[0m
[32m+ 361:             if node.right:[0m
[32m+ 362:                 q.enqueue(node.right)[0m
  363:     def delete(self, val):
  364:         '''Remove a node from the tree.'''
  365:         if (self._size < 1 or not (self.contains(val))):
  366:             return
--------------------------------------------------------------------------------
[0.35931 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments/binarySearchTree3/MIO/test_binarySearchTree3_MIO.py:342: TypeError: Bst.breadth_first() missing 1 required positional argument: 'self'

[36m   -[0m [# 267] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  359:                 q.enqueue(node.left)
  360:             if node.right:
  361:                 q.enqueue(node.right)
  362:     
[34m- 363:     def delete(self, val):[0m
[34m- 364:         '''Remove a node from the tree.'''[0m
[34m- 365:         if (self._size < 1 or not (self.contains(val))):[0m
[34m- 366:             return[0m
[34m- 367:         [0m
[34m- 368:         node = self.search(val)[0m
[34m- 369:         [0m
[34m- 370:         if node._is_leaf():[0m
[34m- 371:             if node.parent:[0m
[34m- 372:                 setattr(node.parent, node._side(), None)[0m
[34m- 373:             else:[0m
[34m- 374:                 self.root = None[0m
[34m- 375:         [0m
[34m- 376:         elif node._is_interior():[0m
[34m- 377:             next_node = self._find_replacement(node)[0m
[34m- 378:             self._size += 1[0m
[34m- 379:             self.delete(next_node.val)[0m
[34m- 380:             node.val = next_node.val[0m
[34m- 381:         else:[0m
[34m- 382:             [0m
[34m- 383:             child = getattr(node, node._onlychild())[0m
[34m- 384:             if node.parent:[0m
[34m- 385:                 child.parent = node.parent[0m
[34m- 386:                 setattr(node.parent, node._side(), child)[0m
[34m- 387:             else:[0m
[34m- 388:                 self.root = child[0m
[34m- 389:         [0m
[34m- 390:         self._size -= 1[0m
[34m- 391:     [0m
[32m+ 363:     @staticmethod[0m
[32m+ 364:     def delete(self, val):[0m
[32m+ 365:         '''Remove a node from the tree.'''[0m
[32m+ 366:         if (self._size < 1 or not (self.contains(val))):[0m
[32m+ 367:             return[0m
[32m+ 368:         [0m
[32m+ 369:         node = self.search(val)[0m
[32m+ 370:         [0m
[32m+ 371:         if node._is_leaf():[0m
[32m+ 372:             if node.parent:[0m
[32m+ 373:                 setattr(node.parent, node._side(), None)[0m
[32m+ 374:             else:[0m
[32m+ 375:                 self.root = None[0m
[32m+ 376:         [0m
[32m+ 377:         elif node._is_interior():[0m
[32m+ 378:             next_node = self._find_replacement(node)[0m
[32m+ 379:             self._size += 1[0m
[32m+ 380:             self.delete(next_node.val)[0m
[32m+ 381:             node.val = next_node.val[0m
[32m+ 382:         else:[0m
[32m+ 383:             [0m
[32m+ 384:             child = getattr(node, node._onlychild())[0m
[32m+ 385:             if node.parent:[0m
[32m+ 386:                 child.parent = node.parent[0m
[32m+ 387:                 setattr(node.parent, node._side(), child)[0m
[32m+ 388:             else:[0m
[32m+ 389:                 self.root = child[0m
[32m+ 390:         [0m
[32m+ 391:         self._size -= 1[0m
  392:     def _find_replacement(self, node):
  393:         '''Find left most node of right subtree.'''
  394:         if node.right:
  395:             return self._findmin(node.right)
--------------------------------------------------------------------------------
[0.21304 s] [36mincompetent[0m

TypeError: /home/lucca/desktop/ic/experimento/testes/python_experiments/binarySearchTree3/MIO/test_binarySearchTree3_MIO.py:178: TypeError: Bst.delete() missing 1 required positional argument: 'val'

[36m   -[0m [# 268] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  388:                 self.root = child
  389:         
  390:         self._size -= 1
  391:     
[34m- 392:     def _find_replacement(self, node):[0m
[34m- 393:         '''Find left most node of right subtree.'''[0m
[34m- 394:         if node.right:[0m
[34m- 395:             return self._findmin(node.right)[0m
[34m- 396:         [0m
[34m- 397:         elif node.parent:[0m
[34m- 398:             if node._side() == 'left':[0m
[34m- 399:                 return self.parent[0m
[34m- 400:             else:[0m
[34m- 401:                 node.parent.right = None[0m
[34m- 402:                 tmp = self._find_replacement(node.parent)[0m
[34m- 403:                 node.parent.right = node[0m
[34m- 404:                 return tmp[0m
[34m- 405:     [0m
[32m+ 392:     @staticmethod[0m
[32m+ 393:     def _find_replacement(self, node):[0m
[32m+ 394:         '''Find left most node of right subtree.'''[0m
[32m+ 395:         if node.right:[0m
[32m+ 396:             return self._findmin(node.right)[0m
[32m+ 397:         [0m
[32m+ 398:         elif node.parent:[0m
[32m+ 399:             if node._side() == 'left':[0m
[32m+ 400:                 return self.parent[0m
[32m+ 401:             else:[0m
[32m+ 402:                 node.parent.right = None[0m
[32m+ 403:                 tmp = self._find_replacement(node.parent)[0m
[32m+ 404:                 node.parent.right = node[0m
[32m+ 405:                 return tmp[0m
  406:     def _findmin(self, node):
  407:         '''Find min of subtree, Min is always left most node.'''
  408:         while node.left:
  409:             node = node.left
--------------------------------------------------------------------------------
[0.20203 s] [31msurvived[0m
[36m   -[0m [# 269] SDI binarySearchTree3: 
--------------------------------------------------------------------------------
  402:                 tmp = self._find_replacement(node.parent)
  403:                 node.parent.right = node
  404:                 return tmp
  405:     
[34m- 406:     def _findmin(self, node):[0m
[34m- 407:         '''Find min of subtree, Min is always left most node.'''[0m
[34m- 408:         while node.left:[0m
[34m- 409:             node = node.left[0m
[34m- 410:         return node[0m
[32m+ 406:     @staticmethod[0m
[32m+ 407:     def _findmin(self, node):[0m
[32m+ 408:         '''Find min of subtree, Min is always left most node.'''[0m
[32m+ 409:         while node.left:[0m
[32m+ 410:             node = node.left[0m
[32m+ 411:         return node[0m
--------------------------------------------------------------------------------
[0.20182 s] [31msurvived[0m
[36m   -[0m [# 270] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
    4:     '''Node class for data storage.'''
    5:     
    6:     def __init__(self, data=None, next_node=None, prev=None):
    7:         '''Initialize Node.'''
[34m-   8:         self.data = data[0m
[32m+   8:         pass[0m
    9:         self.next = next_node
   10:         self.prev = prev
   11:     
   12:     def __repr__(self):
--------------------------------------------------------------------------------
[0.18776 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_4

def test_case_4():
        str_0 = 'aX}B^sw\x0cA!<Uq;!!D9'
        queue_0 = module_0.Queue(str_0)
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.dequeue()

MIO/test_binarySearchTree3_MIO.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:143: in dequeue
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b985540a0>

>   ???
E   AttributeError: 'NodeDLL' object has no attribute 'data'

binarySearchTree3:64: AttributeError
[36m   -[0m [# 271] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
    5:     
    6:     def __init__(self, data=None, next_node=None, prev=None):
    7:         '''Initialize Node.'''
    8:         self.data = data
[34m-   9:         self.next = next_node[0m
[32m+   9:         pass[0m
   10:         self.prev = prev
   11:     
   12:     def __repr__(self):
   13:         '''String representation.'''
--------------------------------------------------------------------------------
[0.29549 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_4

def test_case_4():
        str_0 = 'aX}B^sw\x0cA!<Uq;!!D9'
        queue_0 = module_0.Queue(str_0)
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.dequeue()

MIO/test_binarySearchTree3_MIO.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:143: in dequeue
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b983a2350>

>   ???
E   AttributeError: 'NodeDLL' object has no attribute 'next'

binarySearchTree3:57: AttributeError
[36m   -[0m [# 272] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
    6:     def __init__(self, data=None, next_node=None, prev=None):
    7:         '''Initialize Node.'''
    8:         self.data = data
    9:         self.next = next_node
[34m-  10:         self.prev = prev[0m
[32m+  10:         pass[0m
   11:     
   12:     def __repr__(self):
   13:         '''String representation.'''
   14:         return 'Value: {}'.format(self.data)
--------------------------------------------------------------------------------
[0.20647 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_10

def test_case_10():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        double_linked_list_0 = module_0.DoubleLinkedList(bst_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
        assert f'{type(double_linked_list_0.tail).__module__}.{type(double_linked_list_0.tail).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_0 = double_linked_list_0.shift()

MIO/test_binarySearchTree3_MIO.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b988289a0>

>   ???
E   AttributeError: 'NodeDLL' object has no attribute 'prev'

binarySearchTree3:82: AttributeError
[36m   -[0m [# 273] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   10:         self.prev = prev
   11:     
   12:     def __repr__(self):
   13:         '''String representation.'''
[34m-  14:         return 'Value: {}'.format(self.data)[0m
[32m+  14:         pass[0m
   15: 
   16: 
   17: class DoubleLinkedList(object):
   18:     '''Double linked list impplementation.
--------------------------------------------------------------------------------
[0.24453 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_45

def test_case_45():
        node_d_l_l_0 = module_0.NodeDLL()
        var_0 = node_d_l_l_0.__repr__()
>       assert var_0 == 'Value: None'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:370: AssertionError
[36m   -[0m [# 274] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   27:     '''
   28:     
   29:     def __init__(self, data=None):
   30:         '''Initialize list.'''
[34m-  31:         self.head = None[0m
[32m+  31:         pass[0m
   32:         self.tail = None
   33:         self._length = 0
   34:         try:
   35:             for val in data:
--------------------------------------------------------------------------------
[0.19657 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_0

def test_case_0():
        bytes_0 = b'E\x9c\xce\xc8G'
>       double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)

MIO/test_binarySearchTree3_MIO.py:7: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:36: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98a11a80>, val = 69

>   ???
E   AttributeError: 'DoubleLinkedList' object has no attribute 'head'

binarySearchTree3:43: AttributeError
[36m   -[0m [# 275] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   28:     
   29:     def __init__(self, data=None):
   30:         '''Initialize list.'''
   31:         self.head = None
[34m-  32:         self.tail = None[0m
[32m+  32:         pass[0m
   33:         self._length = 0
   34:         try:
   35:             for val in data:
   36:                 self.push(val)
--------------------------------------------------------------------------------
[0.19763 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_0

def test_case_0():
        bytes_0 = b'E\x9c\xce\xc8G'
>       double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)

MIO/test_binarySearchTree3_MIO.py:7: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:36: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b9876c700>, val = 69

>   ???
E   AttributeError: 'DoubleLinkedList' object has no attribute 'tail'

binarySearchTree3:47: AttributeError
[36m   -[0m [# 276] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   29:     def __init__(self, data=None):
   30:         '''Initialize list.'''
   31:         self.head = None
   32:         self.tail = None
[34m-  33:         self._length = 0[0m
[32m+  33:         pass[0m
   34:         try:
   35:             for val in data:
   36:                 self.push(val)
   37:         except TypeError:
--------------------------------------------------------------------------------
[0.19668 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_0

def test_case_0():
        bytes_0 = b'E\x9c\xce\xc8G'
>       double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)

MIO/test_binarySearchTree3_MIO.py:7: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:36: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98a490c0>, val = 69

>   ???
E   AttributeError: 'DoubleLinkedList' object has no attribute '_length'

binarySearchTree3:49: AttributeError
[36m   -[0m [# 277] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   32:         self.tail = None
   33:         self._length = 0
   34:         try:
   35:             for val in data:
[34m-  36:                 self.push(val)[0m
[32m+  36:                 pass[0m
   37:         except TypeError:
   38:             if data:
   39:                 self.push(data)
   40:     
--------------------------------------------------------------------------------
[0.19554 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_0

def test_case_0():
        bytes_0 = b'E\x9c\xce\xc8G'
        double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
>       assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:9: AssertionError
[36m   -[0m [# 278] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   35:             for val in data:
   36:                 self.push(val)
   37:         except TypeError:
   38:             if data:
[34m-  39:                 self.push(data)[0m
[32m+  39:                 pass[0m
   40:     
   41:     def push(self, val):
   42:         '''Add val to the head of the list.'''
   43:         old_head = self.head
--------------------------------------------------------------------------------
[0.19798 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_1

def test_case_1():
        node_0 = module_0.Node()
        assert node_0.height == 1
        double_linked_list_0 = module_0.DoubleLinkedList(node_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
>       assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:17: AssertionError
[36m   -[0m [# 279] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   39:                 self.push(data)
   40:     
   41:     def push(self, val):
   42:         '''Add val to the head of the list.'''
[34m-  43:         old_head = self.head[0m
[32m+  43:         pass[0m
   44:         self.head = NodeDLL(val, next_node=old_head)
   45:         if old_head:
   46:             old_head.prev = self.head
   47:         if not (self.tail):
--------------------------------------------------------------------------------
[0.31196 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_0

def test_case_0():
        bytes_0 = b'E\x9c\xce\xc8G'
>       double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)

MIO/test_binarySearchTree3_MIO.py:7: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:36: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b986d1c00>, val = 69

>   ???
E   NameError: name 'old_head' is not defined

binarySearchTree3:44: NameError
[36m   -[0m [# 280] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   40:     
   41:     def push(self, val):
   42:         '''Add val to the head of the list.'''
   43:         old_head = self.head
[34m-  44:         self.head = NodeDLL(val, next_node=old_head)[0m
[32m+  44:         pass[0m
   45:         if old_head:
   46:             old_head.prev = self.head
   47:         if not (self.tail):
   48:             self.tail = self.head
--------------------------------------------------------------------------------
[0.19581 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_0

def test_case_0():
        bytes_0 = b'E\x9c\xce\xc8G'
        double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
>       assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:9: AssertionError
[36m   -[0m [# 281] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   42:         '''Add val to the head of the list.'''
   43:         old_head = self.head
   44:         self.head = NodeDLL(val, next_node=old_head)
   45:         if old_head:
[34m-  46:             old_head.prev = self.head[0m
[32m+  46:             pass[0m
   47:         if not (self.tail):
   48:             self.tail = self.head
   49:         self._length += 1
   50:     
--------------------------------------------------------------------------------
[0.21818 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_14

def test_case_14():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.push(double_linked_list_0)
        assert f'{type(double_linked_list_0.tail).__module__}.{type(double_linked_list_0.tail).__qualname__}' == 'binarySearchTree3.NodeDLL'
        var_1 = double_linked_list_0.push(var_0)
>       var_2 = double_linked_list_0.remove(double_linked_list_0)

MIO/test_binarySearchTree3_MIO.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98498160>
val = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98498160>

>   ???
E   AttributeError: 'NoneType' object has no attribute 'next'

binarySearchTree3:103: AttributeError
[36m   -[0m [# 282] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   44:         self.head = NodeDLL(val, next_node=old_head)
   45:         if old_head:
   46:             old_head.prev = self.head
   47:         if not (self.tail):
[34m-  48:             self.tail = self.head[0m
[32m+  48:             pass[0m
   49:         self._length += 1
   50:     
   51:     def pop(self):
   52:         '''Remove the val from the head of the list.'''
--------------------------------------------------------------------------------
[0.33013 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_0

def test_case_0():
        bytes_0 = b'E\x9c\xce\xc8G'
        double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       assert f'{type(double_linked_list_0.tail).__module__}.{type(double_linked_list_0.tail).__qualname__}' == 'binarySearchTree3.NodeDLL'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:10: AssertionError
[36m   -[0m [# 283] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   49:         self._length += 1
   50:     
   51:     def pop(self):
   52:         '''Remove the val from the head of the list.'''
[34m-  53:         to_return = self.head[0m
[32m+  53:         pass[0m
   54:         if self._length < 1:
   55:             raise IndexError('Cannot pop from an empty list.')
   56:         
   57:         new_head = self.head.next
--------------------------------------------------------------------------------
[0.19919 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_4

def test_case_4():
        str_0 = 'aX}B^sw\x0cA!<Uq;!!D9'
        queue_0 = module_0.Queue(str_0)
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.dequeue()

MIO/test_binarySearchTree3_MIO.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:143: in dequeue
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98273b50>

>   ???
E   NameError: name 'to_return' is not defined

binarySearchTree3:64: NameError
[36m   -[0m [# 284] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   53:         to_return = self.head
   54:         if self._length < 1:
   55:             raise IndexError('Cannot pop from an empty list.')
   56:         
[34m-  57:         new_head = self.head.next[0m
[32m+  57:         pass[0m
   58:         if new_head:
   59:             new_head.prev = None
   60:         self.head = new_head
   61:         self._length -= 1
--------------------------------------------------------------------------------
[0.20365 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_4

def test_case_4():
        str_0 = 'aX}B^sw\x0cA!<Uq;!!D9'
        queue_0 = module_0.Queue(str_0)
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.dequeue()

MIO/test_binarySearchTree3_MIO.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:143: in dequeue
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b981695d0>

>   ???
E   NameError: name 'new_head' is not defined

binarySearchTree3:58: NameError
[36m   -[0m [# 285] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   55:             raise IndexError('Cannot pop from an empty list.')
   56:         
   57:         new_head = self.head.next
   58:         if new_head:
[34m-  59:             new_head.prev = None[0m
[32m+  59:             pass[0m
   60:         self.head = new_head
   61:         self._length -= 1
   62:         if self._length < 1:
   63:             self.tail = None
--------------------------------------------------------------------------------
[0.19880 s] [31msurvived[0m
[36m   -[0m [# 286] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   56:         
   57:         new_head = self.head.next
   58:         if new_head:
   59:             new_head.prev = None
[34m-  60:         self.head = new_head[0m
[32m+  60:         pass[0m
   61:         self._length -= 1
   62:         if self._length < 1:
   63:             self.tail = None
   64:         return to_return.data
--------------------------------------------------------------------------------
[0.22171 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_41

def test_case_41():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.delete(bst_0)
        var_1 = bst_0.insert(var_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_2 = bst_0.breadth_first()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_2)

MIO/test_binarySearchTree3_MIO.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
binarySearchTree3:356: in breadth_first
    ???
binarySearchTree3:143: in dequeue
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98a9cf10>

>   ???
E   IndexError: Cannot pop from an empty list.

binarySearchTree3:55: IndexError
[36m   -[0m [# 287] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   59:             new_head.prev = None
   60:         self.head = new_head
   61:         self._length -= 1
   62:         if self._length < 1:
[34m-  63:             self.tail = None[0m
[32m+  63:             pass[0m
   64:         return to_return.data
   65:     
   66:     def append(self, val):
   67:         '''Add val to the tail of the list.'''
--------------------------------------------------------------------------------
[0.20155 s] [31msurvived[0m
[36m   -[0m [# 288] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   60:         self.head = new_head
   61:         self._length -= 1
   62:         if self._length < 1:
   63:             self.tail = None
[34m-  64:         return to_return.data[0m
[32m+  64:         pass[0m
   65:     
   66:     def append(self, val):
   67:         '''Add val to the tail of the list.'''
   68:         old_tail = self.tail
--------------------------------------------------------------------------------
[0.20441 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_4

def test_case_4():
        str_0 = 'aX}B^sw\x0cA!<Uq;!!D9'
        queue_0 = module_0.Queue(str_0)
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
        var_0 = queue_0.dequeue()
>       assert var_0 == '9'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:37: AssertionError
[36m   -[0m [# 289] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   64:         return to_return.data
   65:     
   66:     def append(self, val):
   67:         '''Add val to the tail of the list.'''
[34m-  68:         old_tail = self.tail[0m
[32m+  68:         pass[0m
   69:         self.tail = NodeDLL(val, prev=old_tail)
   70:         if old_tail:
   71:             old_tail.next = self.tail
   72:         if self._length < 1:
--------------------------------------------------------------------------------
[0.19232 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_7

def test_case_7():
        queue_0 = module_0.Queue()
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.enqueue(queue_0)

MIO/test_binarySearchTree3_MIO.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:139: in enqueue
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98753190>
val = <binarySearchTree3.Queue object at 0x7f9b98753160>

>   ???
E   NameError: name 'old_tail' is not defined

binarySearchTree3:69: NameError
[36m   -[0m [# 290] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   65:     
   66:     def append(self, val):
   67:         '''Add val to the tail of the list.'''
   68:         old_tail = self.tail
[34m-  69:         self.tail = NodeDLL(val, prev=old_tail)[0m
[32m+  69:         pass[0m
   70:         if old_tail:
   71:             old_tail.next = self.tail
   72:         if self._length < 1:
   73:             self.head = self.tail
--------------------------------------------------------------------------------
[0.33675 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_12

def test_case_12():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.append(double_linked_list_0)
>       assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:103: AssertionError
[36m   -[0m [# 291] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   67:         '''Add val to the tail of the list.'''
   68:         old_tail = self.tail
   69:         self.tail = NodeDLL(val, prev=old_tail)
   70:         if old_tail:
[34m-  71:             old_tail.next = self.tail[0m
[32m+  71:             pass[0m
   72:         if self._length < 1:
   73:             self.head = self.tail
   74:         self._length += 1
   75:     
--------------------------------------------------------------------------------
[0.21537 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_13

def test_case_13():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.append(double_linked_list_0)
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
        var_1 = double_linked_list_0.append(var_0)
>       var_2 = double_linked_list_0.remove(double_linked_list_0)

MIO/test_binarySearchTree3_MIO.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b982727a0>
val = <binarySearchTree3.DoubleLinkedList object at 0x7f9b982727a0>

>   ???
E   AttributeError: 'NoneType' object has no attribute 'prev'

binarySearchTree3:101: AttributeError
[36m   -[0m [# 292] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   69:         self.tail = NodeDLL(val, prev=old_tail)
   70:         if old_tail:
   71:             old_tail.next = self.tail
   72:         if self._length < 1:
[34m-  73:             self.head = self.tail[0m
[32m+  73:             pass[0m
   74:         self._length += 1
   75:     
   76:     def shift(self):
   77:         '''Remove the val from the tail of the list.'''
--------------------------------------------------------------------------------
[0.20843 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_12

def test_case_12():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.append(double_linked_list_0)
>       assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:103: AssertionError
[36m   -[0m [# 293] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   74:         self._length += 1
   75:     
   76:     def shift(self):
   77:         '''Remove the val from the tail of the list.'''
[34m-  78:         to_return = self.tail[0m
[32m+  78:         pass[0m
   79:         if self._length < 1:
   80:             raise IndexError('Cannot shift from an empty list.')
   81:         
   82:         new_tail = self.tail.prev
--------------------------------------------------------------------------------
[0.20593 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_9

def test_case_9():
        bytes_0 = b'@\x95\xef|X\x9c\x0b\xbd\x9d\xbd\x9d)\x19\xa9'
        double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
        assert f'{type(double_linked_list_0.tail).__module__}.{type(double_linked_list_0.tail).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_0 = double_linked_list_0.shift()

MIO/test_binarySearchTree3_MIO.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b9876c340>

>   ???
E   NameError: name 'to_return' is not defined

binarySearchTree3:89: NameError
[36m   -[0m [# 294] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   78:         to_return = self.tail
   79:         if self._length < 1:
   80:             raise IndexError('Cannot shift from an empty list.')
   81:         
[34m-  82:         new_tail = self.tail.prev[0m
[32m+  82:         pass[0m
   83:         if new_tail:
   84:             new_tail.next = None
   85:         self.tail = new_tail
   86:         self._length -= 1
--------------------------------------------------------------------------------
[0.19551 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_9

def test_case_9():
        bytes_0 = b'@\x95\xef|X\x9c\x0b\xbd\x9d\xbd\x9d)\x19\xa9'
        double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
        assert f'{type(double_linked_list_0.tail).__module__}.{type(double_linked_list_0.tail).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_0 = double_linked_list_0.shift()

MIO/test_binarySearchTree3_MIO.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b984a4b50>

>   ???
E   NameError: name 'new_tail' is not defined

binarySearchTree3:83: NameError
[36m   -[0m [# 295] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   80:             raise IndexError('Cannot shift from an empty list.')
   81:         
   82:         new_tail = self.tail.prev
   83:         if new_tail:
[34m-  84:             new_tail.next = None[0m
[32m+  84:             pass[0m
   85:         self.tail = new_tail
   86:         self._length -= 1
   87:         if self._length < 1:
   88:             self.tail = None
--------------------------------------------------------------------------------
[0.20221 s] [31msurvived[0m
[36m   -[0m [# 296] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   81:         
   82:         new_tail = self.tail.prev
   83:         if new_tail:
   84:             new_tail.next = None
[34m-  85:         self.tail = new_tail[0m
[32m+  85:         pass[0m
   86:         self._length -= 1
   87:         if self._length < 1:
   88:             self.tail = None
   89:         return to_return.data
--------------------------------------------------------------------------------
[0.20005 s] [31msurvived[0m
[36m   -[0m [# 297] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   84:             new_tail.next = None
   85:         self.tail = new_tail
   86:         self._length -= 1
   87:         if self._length < 1:
[34m-  88:             self.tail = None[0m
[32m+  88:             pass[0m
   89:         return to_return.data
   90:     
   91:     def remove(self, val):
   92:         '''Remove first occurance of val from list.'''
--------------------------------------------------------------------------------
[0.20115 s] [31msurvived[0m
[36m   -[0m [# 298] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   85:         self.tail = new_tail
   86:         self._length -= 1
   87:         if self._length < 1:
   88:             self.tail = None
[34m-  89:         return to_return.data[0m
[32m+  89:         pass[0m
   90:     
   91:     def remove(self, val):
   92:         '''Remove first occurance of val from list.'''
   93:         curr = self.head
--------------------------------------------------------------------------------
[0.33553 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_9

def test_case_9():
        bytes_0 = b'@\x95\xef|X\x9c\x0b\xbd\x9d\xbd\x9d)\x19\xa9'
        double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
        assert f'{type(double_linked_list_0.tail).__module__}.{type(double_linked_list_0.tail).__qualname__}' == 'binarySearchTree3.NodeDLL'
        var_0 = double_linked_list_0.shift()
>       assert var_0 == 64
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:74: AssertionError
[36m   -[0m [# 299] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   89:         return to_return.data
   90:     
   91:     def remove(self, val):
   92:         '''Remove first occurance of val from list.'''
[34m-  93:         curr = self.head[0m
[32m+  93:         pass[0m
   94:         while curr:
   95:             if curr.data is val:
   96:                 if self._length == 1:
   97:                     (self.head, self.tail) = (None, None)
--------------------------------------------------------------------------------
[0.21023 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_12

def test_case_12():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.append(double_linked_list_0)
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_1 = double_linked_list_0.remove(double_linked_list_0)

MIO/test_binarySearchTree3_MIO.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b984f06a0>
val = <binarySearchTree3.DoubleLinkedList object at 0x7f9b984f06a0>

>   ???
E   UnboundLocalError: local variable 'curr' referenced before assignment

binarySearchTree3:94: UnboundLocalError
[36m   -[0m [# 300] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   93:         curr = self.head
   94:         while curr:
   95:             if curr.data is val:
   96:                 if self._length == 1:
[34m-  97:                     (self.head, self.tail) = (None, None)[0m
[32m+  97:                     pass[0m
   98:                 elif (curr is not self.head and curr is not self.tail):
   99:                     (curr.next.prev, curr.prev.next) = (curr.prev, curr.next)
  100:                 elif curr is self.head:
  101:                     (self.head, curr.next.prev) = (curr.next, None)
--------------------------------------------------------------------------------
[0.20950 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_12

def test_case_12():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.append(double_linked_list_0)
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
        var_1 = double_linked_list_0.remove(double_linked_list_0)
>       assert double_linked_list_0.head is None
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:105: AssertionError
[36m   -[0m [# 301] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   95:             if curr.data is val:
   96:                 if self._length == 1:
   97:                     (self.head, self.tail) = (None, None)
   98:                 elif (curr is not self.head and curr is not self.tail):
[34m-  99:                     (curr.next.prev, curr.prev.next) = (curr.prev, curr.next)[0m
[32m+  99:                     pass[0m
  100:                 elif curr is self.head:
  101:                     (self.head, curr.next.prev) = (curr.next, None)
  102:                 elif curr is self.tail:
  103:                     (self.tail, curr.prev.next) = (curr.prev, None)
--------------------------------------------------------------------------------
[0.20073 s] [31msurvived[0m
[36m   -[0m [# 302] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   97:                     (self.head, self.tail) = (None, None)
   98:                 elif (curr is not self.head and curr is not self.tail):
   99:                     (curr.next.prev, curr.prev.next) = (curr.prev, curr.next)
  100:                 elif curr is self.head:
[34m- 101:                     (self.head, curr.next.prev) = (curr.next, None)[0m
[32m+ 101:                     pass[0m
  102:                 elif curr is self.tail:
  103:                     (self.tail, curr.prev.next) = (curr.prev, None)
  104:                 self._length -= 1
  105:                 return
--------------------------------------------------------------------------------
[0.19986 s] [31msurvived[0m
[36m   -[0m [# 303] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
   99:                     (curr.next.prev, curr.prev.next) = (curr.prev, curr.next)
  100:                 elif curr is self.head:
  101:                     (self.head, curr.next.prev) = (curr.next, None)
  102:                 elif curr is self.tail:
[34m- 103:                     (self.tail, curr.prev.next) = (curr.prev, None)[0m
[32m+ 103:                     pass[0m
  104:                 self._length -= 1
  105:                 return
  106:             curr = curr.next
  107:         
--------------------------------------------------------------------------------
[0.20098 s] [31msurvived[0m
[36m   -[0m [# 304] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  101:                     (self.head, curr.next.prev) = (curr.next, None)
  102:                 elif curr is self.tail:
  103:                     (self.tail, curr.prev.next) = (curr.prev, None)
  104:                 self._length -= 1
[34m- 105:                 return[0m
[32m+ 105:                 pass[0m
  106:             curr = curr.next
  107:         
  108:         raise ValueError('{} is not in the list'.format(val))
  109:     
--------------------------------------------------------------------------------
[0.21004 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_12

def test_case_12():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.append(double_linked_list_0)
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_1 = double_linked_list_0.remove(double_linked_list_0)

MIO/test_binarySearchTree3_MIO.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b988b2350>
val = <binarySearchTree3.DoubleLinkedList object at 0x7f9b988b2350>

>   ???
E   ValueError: <binarySearchTree3.DoubleLinkedList object at 0x7f9b988b2350> is not in the list

binarySearchTree3:108: ValueError
[36m   -[0m [# 305] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  102:                 elif curr is self.tail:
  103:                     (self.tail, curr.prev.next) = (curr.prev, None)
  104:                 self._length -= 1
  105:                 return
[34m- 106:             curr = curr.next[0m
[32m+ 106:             pass[0m
  107:         
  108:         raise ValueError('{} is not in the list'.format(val))
  109:     
  110:     def _repr(self):
--------------------------------------------------------------------------------
[5.00829 s] [33mtimeout[0m
[36m   -[0m [# 306] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  108:         raise ValueError('{} is not in the list'.format(val))
  109:     
  110:     def _repr(self):
  111:         '''Return list representation of dll.'''
[34m- 112:         l = [][0m
[32m+ 112:         pass[0m
  113:         while True:
  114:             try:
  115:                 popped_data = self.pop()
  116:                 l.append(popped_data)
--------------------------------------------------------------------------------
[0.31673 s] [31msurvived[0m
[36m   -[0m [# 307] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  111:         '''Return list representation of dll.'''
  112:         l = []
  113:         while True:
  114:             try:
[34m- 115:                 popped_data = self.pop()[0m
[32m+ 115:                 pass[0m
  116:                 l.append(popped_data)
  117:             except IndexError:
  118:                 break
  119:         return l
--------------------------------------------------------------------------------
[0.20120 s] [31msurvived[0m
[36m   -[0m [# 308] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  112:         l = []
  113:         while True:
  114:             try:
  115:                 popped_data = self.pop()
[34m- 116:                 l.append(popped_data)[0m
[32m+ 116:                 pass[0m
  117:             except IndexError:
  118:                 break
  119:         return l
  120: 
--------------------------------------------------------------------------------
[0.20107 s] [31msurvived[0m
[36m   -[0m [# 309] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  115:                 popped_data = self.pop()
  116:                 l.append(popped_data)
  117:             except IndexError:
  118:                 break
[34m- 119:         return l[0m
[32m+ 119:         pass[0m
  120: 
  121: class Queue(object):
  122:     '''Implementation of Queue.
  123: 
--------------------------------------------------------------------------------
[0.31529 s] [31msurvived[0m
[36m   -[0m [# 310] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  131:     '''
  132:     
  133:     def __init__(self, data=None):
  134:         '''Initialize queue data structure.'''
[34m- 135:         self._container = DoubleLinkedList(data)[0m
[32m+ 135:         pass[0m
  136:     
  137:     def enqueue(self, val):
  138:         '''Add a value to the queue.'''
  139:         self._container.append(val)
--------------------------------------------------------------------------------
[0.20129 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_4

def test_case_4():
        str_0 = 'aX}B^sw\x0cA!<Uq;!!D9'
        queue_0 = module_0.Queue(str_0)
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.dequeue()

MIO/test_binarySearchTree3_MIO.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Queue object at 0x7f9b98b2ed40>

>   ???
E   AttributeError: 'Queue' object has no attribute '_container'

binarySearchTree3:143: AttributeError
[36m   -[0m [# 311] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  135:         self._container = DoubleLinkedList(data)
  136:     
  137:     def enqueue(self, val):
  138:         '''Add a value to the queue.'''
[34m- 139:         self._container.append(val)[0m
[32m+ 139:         pass[0m
  140:     
  141:     def dequeue(self):
  142:         '''Remove a value from the front of the queue.'''
  143:         return self._container.pop()
--------------------------------------------------------------------------------
[0.23756 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_41

def test_case_41():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.delete(bst_0)
        var_1 = bst_0.insert(var_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_2 = bst_0.breadth_first()
        double_linked_list_0 = module_0.DoubleLinkedList(var_2)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
>       assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:345: AssertionError
[36m   -[0m [# 312] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  139:         self._container.append(val)
  140:     
  141:     def dequeue(self):
  142:         '''Remove a value from the front of the queue.'''
[34m- 143:         return self._container.pop()[0m
[32m+ 143:         pass[0m
  144:     
  145:     def peek(self):
  146:         '''Return the next value in the queue without dequing it.'''
  147:         try:
--------------------------------------------------------------------------------
[0.20542 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_4

def test_case_4():
        str_0 = 'aX}B^sw\x0cA!<Uq;!!D9'
        queue_0 = module_0.Queue(str_0)
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
        var_0 = queue_0.dequeue()
>       assert var_0 == '9'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:37: AssertionError
[36m   -[0m [# 313] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  144:     
  145:     def peek(self):
  146:         '''Return the next value in the queue without dequing it.'''
  147:         try:
[34m- 148:             return self._container.head.data[0m
[32m+ 148:             pass[0m
  149:         except AttributeError:
  150:             return None
  151:     
  152:     def size(self):
--------------------------------------------------------------------------------
[0.23743 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_41

def test_case_41():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.delete(bst_0)
        var_1 = bst_0.insert(var_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_2 = bst_0.breadth_first()
        double_linked_list_0 = module_0.DoubleLinkedList(var_2)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
>       assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:345: AssertionError
[36m   -[0m [# 314] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  146:         '''Return the next value in the queue without dequing it.'''
  147:         try:
  148:             return self._container.head.data
  149:         except AttributeError:
[34m- 150:             return None[0m
[32m+ 150:             pass[0m
  151:     
  152:     def size(self):
  153:         '''Return the size of the queue.'''
  154:         return self._container._length
--------------------------------------------------------------------------------
[0.20132 s] [31msurvived[0m
[36m   -[0m [# 315] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  150:             return None
  151:     
  152:     def size(self):
  153:         '''Return the size of the queue.'''
[34m- 154:         return self._container._length[0m
[32m+ 154:         pass[0m
  155: 
  156: class Node(object):
  157:     '''Node, or leaf of the BST.'''
  158:     
--------------------------------------------------------------------------------
[0.24494 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_47

def test_case_47():
        queue_0 = module_0.Queue()
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
        var_0 = queue_0.size()
>       assert var_0 == 0
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:380: AssertionError
[36m   -[0m [# 316] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  157:     '''Node, or leaf of the BST.'''
  158:     
  159:     def __init__(self, val=None, parent=None):
  160:         '''Create node object.'''
[34m- 161:         self.val = val[0m
[32m+ 161:         pass[0m
  162:         self.right = None
  163:         self.left = None
  164:         self.parent = parent
  165:         self.height = 1
--------------------------------------------------------------------------------
[0.21920 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_1 = bst_0.delete(bst_0)

MIO/test_binarySearchTree3_MIO.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:365: in delete
    ???
binarySearchTree3:288: in contains
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98a119f0>
val = <binarySearchTree3.Bst object at 0x7f9b98a119f0>

>   ???
E   AttributeError: 'Node' object has no attribute 'val'

binarySearchTree3:271: AttributeError
[36m   -[0m [# 317] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  158:     
  159:     def __init__(self, val=None, parent=None):
  160:         '''Create node object.'''
  161:         self.val = val
[34m- 162:         self.right = None[0m
[32m+ 162:         pass[0m
  163:         self.left = None
  164:         self.parent = parent
  165:         self.height = 1
  166:     
--------------------------------------------------------------------------------
[0.34689 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_1 = bst_0.delete(bst_0)

MIO/test_binarySearchTree3_MIO.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:370: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Node object at 0x7f9b98424460>

>   ???
E   AttributeError: 'Node' object has no attribute 'right'

binarySearchTree3:169: AttributeError
[36m   -[0m [# 318] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  159:     def __init__(self, val=None, parent=None):
  160:         '''Create node object.'''
  161:         self.val = val
  162:         self.right = None
[34m- 163:         self.left = None[0m
[32m+ 163:         pass[0m
  164:         self.parent = parent
  165:         self.height = 1
  166:     
  167:     def _is_leaf(self):
--------------------------------------------------------------------------------
[0.21740 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_1 = bst_0.delete(bst_0)

MIO/test_binarySearchTree3_MIO.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:370: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Node object at 0x7f9b99241f00>

>   ???
E   AttributeError: 'Node' object has no attribute 'left'

binarySearchTree3:169: AttributeError
[36m   -[0m [# 319] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  160:         '''Create node object.'''
  161:         self.val = val
  162:         self.right = None
  163:         self.left = None
[34m- 164:         self.parent = parent[0m
[32m+ 164:         pass[0m
  165:         self.height = 1
  166:     
  167:     def _is_leaf(self):
  168:         '''Return true if a leaf.'''
--------------------------------------------------------------------------------
[0.21756 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_1 = bst_0.delete(bst_0)

MIO/test_binarySearchTree3_MIO.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98441000>
val = <binarySearchTree3.Bst object at 0x7f9b98441000>

>   ???
E   AttributeError: 'Node' object has no attribute 'parent'

binarySearchTree3:371: AttributeError
[36m   -[0m [# 320] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  161:         self.val = val
  162:         self.right = None
  163:         self.left = None
  164:         self.parent = parent
[34m- 165:         self.height = 1[0m
[32m+ 165:         pass[0m
  166:     
  167:     def _is_leaf(self):
  168:         '''Return true if a leaf.'''
  169:         return not ((self.right or self.left))
--------------------------------------------------------------------------------
[0.19507 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_1

def test_case_1():
        node_0 = module_0.Node()
>       assert node_0.height == 1
E       AttributeError: 'Node' object has no attribute 'height'

MIO/test_binarySearchTree3_MIO.py:14: AttributeError
[36m   -[0m [# 321] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  165:         self.height = 1
  166:     
  167:     def _is_leaf(self):
  168:         '''Return true if a leaf.'''
[34m- 169:         return not ((self.right or self.left))[0m
[32m+ 169:         pass[0m
  170:     
  171:     def _is_interior(self):
  172:         '''Return true if a interior node.'''
  173:         return (self.right and self.left)
--------------------------------------------------------------------------------
[0.21667 s] [36mincompetent[0m

TypeError: binarySearchTree3:383: TypeError: getattr(): attribute name must be string

[36m   -[0m [# 322] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  169:         return not ((self.right or self.left))
  170:     
  171:     def _is_interior(self):
  172:         '''Return true if a interior node.'''
[34m- 173:         return (self.right and self.left)[0m
[32m+ 173:         pass[0m
  174:     
  175:     def _onlychild(self):
  176:         '''Return string depending on children.'''
  177:         if (self.left and not (self.right)):
--------------------------------------------------------------------------------
[0.20099 s] [31msurvived[0m
[36m   -[0m [# 323] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  174:     
  175:     def _onlychild(self):
  176:         '''Return string depending on children.'''
  177:         if (self.left and not (self.right)):
[34m- 178:             return 'left'[0m
[32m+ 178:             pass[0m
  179:         if (self.right and not (self.left)):
  180:             return 'right'
  181:     
  182:     def _side(self):
--------------------------------------------------------------------------------
[0.18160 s] [31msurvived[0m
[36m   -[0m [# 324] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  176:         '''Return string depending on children.'''
  177:         if (self.left and not (self.right)):
  178:             return 'left'
  179:         if (self.right and not (self.left)):
[34m- 180:             return 'right'[0m
[32m+ 180:             pass[0m
  181:     
  182:     def _side(self):
  183:         '''Return if left or right child of parent.'''
  184:         if self.parent:
--------------------------------------------------------------------------------
[0.19926 s] [31msurvived[0m
[36m   -[0m [# 325] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  181:     
  182:     def _side(self):
  183:         '''Return if left or right child of parent.'''
  184:         if self.parent:
[34m- 185:             return 'left' if self.parent.left == self else 'right'[0m
[32m+ 185:             pass[0m
  186: 
  187: 
  188: class Bst(object):
  189:     '''Binary Search Tree.
--------------------------------------------------------------------------------
[0.32729 s] [31msurvived[0m
[36m   -[0m [# 326] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  226:     '''
  227:     
  228:     def __init__(self, data=None):
  229:         '''Initialize tree.'''
[34m- 230:         self._size = 0[0m
[32m+ 230:         pass[0m
  231:         self.root = None
  232:         
  233:         if data:
  234:             for i in data:
--------------------------------------------------------------------------------
[0.21629 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
>       var_0 = bst_0.insert(bst_0)

MIO/test_binarySearchTree3_MIO.py:176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b984a6fb0>
val = <binarySearchTree3.Bst object at 0x7f9b984a6fb0>

>   ???
E   AttributeError: 'Bst' object has no attribute '_size'

binarySearchTree3:241: AttributeError
[36m   -[0m [# 327] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  227:     
  228:     def __init__(self, data=None):
  229:         '''Initialize tree.'''
  230:         self._size = 0
[34m- 231:         self.root = None[0m
[32m+ 231:         pass[0m
  232:         
  233:         if data:
  234:             for i in data:
  235:                 self.insert(i)
--------------------------------------------------------------------------------
[0.19947 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_3

def test_case_3():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
>       assert bst_0.root is None
E       AttributeError: 'Bst' object has no attribute 'root'

MIO/test_binarySearchTree3_MIO.py:29: AttributeError
[36m   -[0m [# 328] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  231:         self.root = None
  232:         
  233:         if data:
  234:             for i in data:
[34m- 235:                 self.insert(i)[0m
[32m+ 235:                 pass[0m
  236:     
  237:     def insert(self, val):
  238:         '''Insert val into BST. If val is already present will be ignored.'''
  239:         if not (self.root):
--------------------------------------------------------------------------------
[0.22056 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_21

def test_case_21():
        bytes_0 = b'z\xc7'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
>       assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:185: AssertionError
[36m   -[0m [# 329] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  236:     
  237:     def insert(self, val):
  238:         '''Insert val into BST. If val is already present will be ignored.'''
  239:         if not (self.root):
[34m- 240:             self.root = Node(val)[0m
[32m+ 240:             pass[0m
  241:             self._size += 1
  242:         else:
  243:             self._step(val, self.root)
  244:     
--------------------------------------------------------------------------------
[0.21783 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
>       assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:177: AssertionError
[36m   -[0m [# 330] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  239:         if not (self.root):
  240:             self.root = Node(val)
  241:             self._size += 1
  242:         else:
[34m- 243:             self._step(val, self.root)[0m
[32m+ 243:             pass[0m
  244:     
  245:     def _step(self, val, curr):
  246:         '''Decide left or right and returns height.'''
  247:         if val < curr.val:
--------------------------------------------------------------------------------
[0.35141 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_0 = bst_0.balance()
>       assert var_0 == -1
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:258: AssertionError
[36m   -[0m [# 331] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  244:     
  245:     def _step(self, val, curr):
  246:         '''Decide left or right and returns height.'''
  247:         if val < curr.val:
[34m- 248:             curr = self._set_child(curr, 'left', val)[0m
[32m+ 248:             pass[0m
  249:         elif val > curr.val:
  250:             curr = self._set_child(curr, 'right', val)
  251:         return curr.height
  252:     
--------------------------------------------------------------------------------
[0.19964 s] [31msurvived[0m
[36m   -[0m [# 332] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  246:         '''Decide left or right and returns height.'''
  247:         if val < curr.val:
  248:             curr = self._set_child(curr, 'left', val)
  249:         elif val > curr.val:
[34m- 250:             curr = self._set_child(curr, 'right', val)[0m
[32m+ 250:             pass[0m
  251:         return curr.height
  252:     
  253:     def _set_child(self, curr, side, val):
  254:         '''Helping.'''
--------------------------------------------------------------------------------
[0.23274 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_0 = bst_0.balance()
>       assert var_0 == -1
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:258: AssertionError
[36m   -[0m [# 333] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  247:         if val < curr.val:
  248:             curr = self._set_child(curr, 'left', val)
  249:         elif val > curr.val:
  250:             curr = self._set_child(curr, 'right', val)
[34m- 251:         return curr.height[0m
[32m+ 251:         pass[0m
  252:     
  253:     def _set_child(self, curr, side, val):
  254:         '''Helping.'''
  255:         child = getattr(curr, side)
--------------------------------------------------------------------------------
[0.34662 s] [36mincompetent[0m

TypeError: binarySearchTree3:258: TypeError: '<=' not supported between instances of 'int' and 'NoneType'

[36m   -[0m [# 334] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  251:         return curr.height
  252:     
  253:     def _set_child(self, curr, side, val):
  254:         '''Helping.'''
[34m- 255:         child = getattr(curr, side)[0m
[32m+ 255:         pass[0m
  256:         if child:
  257:             count = self._step(val, child)
  258:             if curr.height <= count:
  259:                 curr.height += 1
--------------------------------------------------------------------------------
[0.22044 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_21

def test_case_21():
        bytes_0 = b'z\xc7'
>       bst_0 = module_0.Bst(bytes_0)

MIO/test_binarySearchTree3_MIO.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:235: in __init__
    ???
binarySearchTree3:243: in insert
    ???
binarySearchTree3:250: in _step
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98a03610>
curr = <binarySearchTree3.Node object at 0x7f9b98a01c00>, side = 'right'
val = 199

>   ???
E   NameError: name 'child' is not defined

binarySearchTree3:256: NameError
[36m   -[0m [# 335] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  253:     def _set_child(self, curr, side, val):
  254:         '''Helping.'''
  255:         child = getattr(curr, side)
  256:         if child:
[34m- 257:             count = self._step(val, child)[0m
[32m+ 257:             pass[0m
  258:             if curr.height <= count:
  259:                 curr.height += 1
  260:         else:
  261:             setattr(curr, side, Node(val, curr))
--------------------------------------------------------------------------------
[0.22463 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_25

def test_case_25():
        bytes_0 = b'd~\xd8\xfc\xfd,@,$\xb91f\xe7\x92\xc2\x14\xd3H'
>       bst_0 = module_0.Bst(bytes_0)

MIO/test_binarySearchTree3_MIO.py:205: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:235: in __init__
    ???
binarySearchTree3:243: in insert
    ???
binarySearchTree3:250: in _step
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98275750>
curr = <binarySearchTree3.Node object at 0x7f9b982757e0>, side = 'right'
val = 216

>   ???
E   NameError: name 'count' is not defined

binarySearchTree3:258: NameError
[36m   -[0m [# 336] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  257:             count = self._step(val, child)
  258:             if curr.height <= count:
  259:                 curr.height += 1
  260:         else:
[34m- 261:             setattr(curr, side, Node(val, curr))[0m
[32m+ 261:             pass[0m
  262:             self._size += 1
  263:             if curr.height == 1:
  264:                 curr.height += 1
  265:         return curr
--------------------------------------------------------------------------------
[0.23124 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_0 = bst_0.balance()
>       assert var_0 == -1
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:258: AssertionError
[36m   -[0m [# 337] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  261:             setattr(curr, side, Node(val, curr))
  262:             self._size += 1
  263:             if curr.height == 1:
  264:                 curr.height += 1
[34m- 265:         return curr[0m
[32m+ 265:         pass[0m
  266:     
  267:     def search(self, val):
  268:         '''Return the node containing val.'''
  269:         curr = self.root
--------------------------------------------------------------------------------
[0.22003 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_21

def test_case_21():
        bytes_0 = b'z\xc7'
>       bst_0 = module_0.Bst(bytes_0)

MIO/test_binarySearchTree3_MIO.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:235: in __init__
    ???
binarySearchTree3:243: in insert
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98678970>, val = 199, curr = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'height'

binarySearchTree3:251: AttributeError
[36m   -[0m [# 338] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  265:         return curr
  266:     
  267:     def search(self, val):
  268:         '''Return the node containing val.'''
[34m- 269:         curr = self.root[0m
[32m+ 269:         pass[0m
  270:         while curr:
  271:             if curr.val == val:
  272:                 return curr
  273:             elif val < curr.val:
--------------------------------------------------------------------------------
[0.21786 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_1 = bst_0.delete(bst_0)

MIO/test_binarySearchTree3_MIO.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:365: in delete
    ???
binarySearchTree3:288: in contains
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98af8160>
val = <binarySearchTree3.Bst object at 0x7f9b98af8160>

>   ???
E   UnboundLocalError: local variable 'curr' referenced before assignment

binarySearchTree3:270: UnboundLocalError
[36m   -[0m [# 339] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  268:         '''Return the node containing val.'''
  269:         curr = self.root
  270:         while curr:
  271:             if curr.val == val:
[34m- 272:                 return curr[0m
[32m+ 272:                 pass[0m
  273:             elif val < curr.val:
  274:                 curr = curr.left
  275:             else:
  276:                 curr = curr.right
--------------------------------------------------------------------------------
[5.00839 s] [33mtimeout[0m
[36m   -[0m [# 340] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  270:         while curr:
  271:             if curr.val == val:
  272:                 return curr
  273:             elif val < curr.val:
[34m- 274:                 curr = curr.left[0m
[32m+ 274:                 pass[0m
  275:             else:
  276:                 curr = curr.right
  277:     
  278:     def size(self):
--------------------------------------------------------------------------------
[5.00835 s] [33mtimeout[0m
[36m   -[0m [# 341] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  272:                 return curr
  273:             elif val < curr.val:
  274:                 curr = curr.left
  275:             else:
[34m- 276:                 curr = curr.right[0m
[32m+ 276:                 pass[0m
  277:     
  278:     def size(self):
  279:         '''Return the size of the BST.'''
  280:         return self._size
--------------------------------------------------------------------------------
[5.00838 s] [33mtimeout[0m
[36m   -[0m [# 342] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  276:                 curr = curr.right
  277:     
  278:     def size(self):
  279:         '''Return the size of the BST.'''
[34m- 280:         return self._size[0m
[32m+ 280:         pass[0m
  281:     
  282:     def depth(self):
  283:         '''Return depth of the BST, representing total levels.'''
  284:         return 0 if not (self.root) else self.root.height
--------------------------------------------------------------------------------
[0.23603 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_39

def test_case_39():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.post_order()
        var_1 = bst_0.size()
>       assert var_1 == 0
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:317: AssertionError
[36m   -[0m [# 343] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  280:         return self._size
  281:     
  282:     def depth(self):
  283:         '''Return depth of the BST, representing total levels.'''
[34m- 284:         return 0 if not (self.root) else self.root.height[0m
[32m+ 284:         pass[0m
  285:     
  286:     def contains(self, val):
  287:         '''Return true if val is in the bst.'''
  288:         return self.search(val) is not None
--------------------------------------------------------------------------------
[0.22933 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_30

def test_case_30():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_1 = bst_0.depth()
>       assert var_1 == 1
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:243: AssertionError
[36m   -[0m [# 344] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  284:         return 0 if not (self.root) else self.root.height
  285:     
  286:     def contains(self, val):
  287:         '''Return true if val is in the bst.'''
[34m- 288:         return self.search(val) is not None[0m
[32m+ 288:         pass[0m
  289:     
  290:     def balance(self, tree=None):
  291:         '''Return an integer of how well the tree is balanced.
  292: 
--------------------------------------------------------------------------------
[0.33279 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_1 = bst_0.delete(bst_0)
>       assert bst_0.root is None
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:179: AssertionError
[36m   -[0m [# 345] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  295:         should return a negative value. An ideally-balanced tree should
  296:         return 0.
  297:         '''
  298:         if not tree:
[34m- 299:             tree = self.root[0m
[32m+ 299:             pass[0m
  300:             if not tree:
  301:                 return 0
  302:         
  303:         leftbranch = 0 if not (tree.left) else tree.left.height
--------------------------------------------------------------------------------
[0.23320 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_0 = bst_0.balance()
>       assert var_0 == -1
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:258: AssertionError
[36m   -[0m [# 346] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  297:         '''
  298:         if not tree:
  299:             tree = self.root
  300:             if not tree:
[34m- 301:                 return 0[0m
[32m+ 301:                 pass[0m
  302:         
  303:         leftbranch = 0 if not (tree.left) else tree.left.height
  304:         rightbranch = 0 if not (tree.right) else tree.right.height
  305:         
--------------------------------------------------------------------------------
[0.23464 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_34

def test_case_34():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
>       var_0 = bst_0.balance()

MIO/test_binarySearchTree3_MIO.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98b1fa00>, tree = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'left'

binarySearchTree3:303: AttributeError
[36m   -[0m [# 347] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  299:             tree = self.root
  300:             if not tree:
  301:                 return 0
  302:         
[34m- 303:         leftbranch = 0 if not (tree.left) else tree.left.height[0m
[32m+ 303:         pass[0m
  304:         rightbranch = 0 if not (tree.right) else tree.right.height
  305:         
  306:         return leftbranch - rightbranch
  307:     
--------------------------------------------------------------------------------
[0.22834 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_0 = bst_0.balance()

MIO/test_binarySearchTree3_MIO.py:257: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98273c10>
tree = <binarySearchTree3.Node object at 0x7f9b98271720>

>   ???
E   NameError: name 'leftbranch' is not defined

binarySearchTree3:306: NameError
[36m   -[0m [# 348] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  300:             if not tree:
  301:                 return 0
  302:         
  303:         leftbranch = 0 if not (tree.left) else tree.left.height
[34m- 304:         rightbranch = 0 if not (tree.right) else tree.right.height[0m
[32m+ 304:         pass[0m
  305:         
  306:         return leftbranch - rightbranch
  307:     
  308:     def pre_order(self, node='root'):
--------------------------------------------------------------------------------
[0.22915 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_0 = bst_0.balance()

MIO/test_binarySearchTree3_MIO.py:257: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b987a0d30>
tree = <binarySearchTree3.Node object at 0x7f9b987a0a00>

>   ???
E   NameError: name 'rightbranch' is not defined

binarySearchTree3:306: NameError
[36m   -[0m [# 349] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  302:         
  303:         leftbranch = 0 if not (tree.left) else tree.left.height
  304:         rightbranch = 0 if not (tree.right) else tree.right.height
  305:         
[34m- 306:         return leftbranch - rightbranch[0m
[32m+ 306:         pass[0m
  307:     
  308:     def pre_order(self, node='root'):
  309:         '''Depth first pre-order traversal of tree.'''
  310:         if node == 'root':
--------------------------------------------------------------------------------
[0.34749 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_0 = bst_0.balance()
>       assert var_0 == -1
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:258: AssertionError
[36m   -[0m [# 350] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  307:     
  308:     def pre_order(self, node='root'):
  309:         '''Depth first pre-order traversal of tree.'''
  310:         if node == 'root':
[34m- 311:             node = self.root[0m
[32m+ 311:             pass[0m
  312:         
  313:         if not node:
  314:             return
  315:         
--------------------------------------------------------------------------------
[0.23152 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_36

def test_case_36():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.pre_order()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b9886a8f0>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'val'

binarySearchTree3:316: AttributeError
[36m   -[0m [# 351] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  310:         if node == 'root':
  311:             node = self.root
  312:         
  313:         if not node:
[34m- 314:             return[0m
[32m+ 314:             pass[0m
  315:         
  316:         yield node.val
  317:         
  318:         for n in self.pre_order(node=node.left):
--------------------------------------------------------------------------------
[0.23444 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_36

def test_case_36():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.pre_order()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98b2c490>, node = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'val'

binarySearchTree3:316: AttributeError
[36m   -[0m [# 352] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  312:         
  313:         if not node:
  314:             return
  315:         
[34m- 316:         yield node.val[0m
[32m+ 316:         pass[0m
  317:         
  318:         for n in self.pre_order(node=node.left):
  319:             yield n
  320:         for n in self.pre_order(node=node.right):
--------------------------------------------------------------------------------
[0.33163 s] [31msurvived[0m
[36m   -[0m [# 353] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  315:         
  316:         yield node.val
  317:         
  318:         for n in self.pre_order(node=node.left):
[34m- 319:             yield n[0m
[32m+ 319:             pass[0m
  320:         for n in self.pre_order(node=node.right):
  321:             yield n
  322:     
  323:     def in_order(self, node='root'):
--------------------------------------------------------------------------------
[0.19966 s] [31msurvived[0m
[36m   -[0m [# 354] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  317:         
  318:         for n in self.pre_order(node=node.left):
  319:             yield n
  320:         for n in self.pre_order(node=node.right):
[34m- 321:             yield n[0m
[32m+ 321:             pass[0m
  322:     
  323:     def in_order(self, node='root'):
  324:         '''Depth first in-order traversal of tree.'''
  325:         if node == 'root':
--------------------------------------------------------------------------------
[0.19961 s] [31msurvived[0m
[36m   -[0m [# 355] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  322:     
  323:     def in_order(self, node='root'):
  324:         '''Depth first in-order traversal of tree.'''
  325:         if node == 'root':
[34m- 326:             node = self.root[0m
[32m+ 326:             pass[0m
  327:         
  328:         if not node:
  329:             return
  330:         
--------------------------------------------------------------------------------
[0.23534 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_38

def test_case_38():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.in_order()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:306: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b987a01f0>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

binarySearchTree3:331: AttributeError
[36m   -[0m [# 356] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  325:         if node == 'root':
  326:             node = self.root
  327:         
  328:         if not node:
[34m- 329:             return[0m
[32m+ 329:             pass[0m
  330:         
  331:         for n in self.in_order(node=node.left):
  332:             yield n
  333:         yield node.val
--------------------------------------------------------------------------------
[0.23580 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_38

def test_case_38():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.in_order()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:306: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98828f10>, node = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'left'

binarySearchTree3:331: AttributeError
[36m   -[0m [# 357] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  328:         if not node:
  329:             return
  330:         
  331:         for n in self.in_order(node=node.left):
[34m- 332:             yield n[0m
[32m+ 332:             pass[0m
  333:         yield node.val
  334:         for n in self.in_order(node=node.right):
  335:             yield n
  336:     
--------------------------------------------------------------------------------
[0.20024 s] [31msurvived[0m
[36m   -[0m [# 358] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  329:             return
  330:         
  331:         for n in self.in_order(node=node.left):
  332:             yield n
[34m- 333:         yield node.val[0m
[32m+ 333:         pass[0m
  334:         for n in self.in_order(node=node.right):
  335:             yield n
  336:     
  337:     def post_order(self, node='root'):
--------------------------------------------------------------------------------
[0.20032 s] [31msurvived[0m
[36m   -[0m [# 359] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  331:         for n in self.in_order(node=node.left):
  332:             yield n
  333:         yield node.val
  334:         for n in self.in_order(node=node.right):
[34m- 335:             yield n[0m
[32m+ 335:             pass[0m
  336:     
  337:     def post_order(self, node='root'):
  338:         '''Depth frist post_order traversal of tree.'''
  339:         if node == 'root':
--------------------------------------------------------------------------------
[0.20170 s] [31msurvived[0m
[36m   -[0m [# 360] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  336:     
  337:     def post_order(self, node='root'):
  338:         '''Depth frist post_order traversal of tree.'''
  339:         if node == 'root':
[34m- 340:             node = self.root[0m
[32m+ 340:             pass[0m
  341:         
  342:         if not node:
  343:             return
  344:         
--------------------------------------------------------------------------------
[0.36051 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_39

def test_case_39():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.post_order()
        var_1 = bst_0.size()
        assert var_1 == 0
        var_2 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:320: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b988351b0>, node = 'root'

>   ???
E   AttributeError: 'str' object has no attribute 'left'

binarySearchTree3:345: AttributeError
[36m   -[0m [# 361] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  339:         if node == 'root':
  340:             node = self.root
  341:         
  342:         if not node:
[34m- 343:             return[0m
[32m+ 343:             pass[0m
  344:         
  345:         for n in self.post_order(node=node.left):
  346:             yield n
  347:         for n in self.post_order(node=node.right):
--------------------------------------------------------------------------------
[0.23754 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_39

def test_case_39():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.post_order()
        var_1 = bst_0.size()
        assert var_1 == 0
        var_2 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:320: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
binarySearchTree3:345: in post_order
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98aa1c00>, node = None

>   ???
E   AttributeError: 'NoneType' object has no attribute 'left'

binarySearchTree3:345: AttributeError
[36m   -[0m [# 362] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  342:         if not node:
  343:             return
  344:         
  345:         for n in self.post_order(node=node.left):
[34m- 346:             yield n[0m
[32m+ 346:             pass[0m
  347:         for n in self.post_order(node=node.right):
  348:             yield n
  349:         yield node.val
  350:     
--------------------------------------------------------------------------------
[0.20070 s] [31msurvived[0m
[36m   -[0m [# 363] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  344:         
  345:         for n in self.post_order(node=node.left):
  346:             yield n
  347:         for n in self.post_order(node=node.right):
[34m- 348:             yield n[0m
[32m+ 348:             pass[0m
  349:         yield node.val
  350:     
  351:     def breadth_first(self):
  352:         '''Breadth first traversal of tree.'''
--------------------------------------------------------------------------------
[0.18230 s] [31msurvived[0m
[36m   -[0m [# 364] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  345:         for n in self.post_order(node=node.left):
  346:             yield n
  347:         for n in self.post_order(node=node.right):
  348:             yield n
[34m- 349:         yield node.val[0m
[32m+ 349:         pass[0m
  350:     
  351:     def breadth_first(self):
  352:         '''Breadth first traversal of tree.'''
  353:         q = Queue()
--------------------------------------------------------------------------------
[0.23465 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_39

def test_case_39():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.post_order()
        var_1 = bst_0.size()
        assert var_1 == 0
        var_2 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        double_linked_list_0 = module_0.DoubleLinkedList(var_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
>       assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:322: AssertionError
[36m   -[0m [# 365] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  349:         yield node.val
  350:     
  351:     def breadth_first(self):
  352:         '''Breadth first traversal of tree.'''
[34m- 353:         q = Queue()[0m
[32m+ 353:         pass[0m
  354:         q.enqueue(self.root)
  355:         while q.peek():
  356:             node = q.dequeue()
  357:             yield node.val
--------------------------------------------------------------------------------
[0.23667 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_41

def test_case_41():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.delete(bst_0)
        var_1 = bst_0.insert(var_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_2 = bst_0.breadth_first()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_2)

MIO/test_binarySearchTree3_MIO.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b985628c0>

>   ???
E   NameError: name 'q' is not defined

binarySearchTree3:354: NameError
[36m   -[0m [# 366] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  350:     
  351:     def breadth_first(self):
  352:         '''Breadth first traversal of tree.'''
  353:         q = Queue()
[34m- 354:         q.enqueue(self.root)[0m
[32m+ 354:         pass[0m
  355:         while q.peek():
  356:             node = q.dequeue()
  357:             yield node.val
  358:             if node.left:
--------------------------------------------------------------------------------
[0.23738 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_41

def test_case_41():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.delete(bst_0)
        var_1 = bst_0.insert(var_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_2 = bst_0.breadth_first()
        double_linked_list_0 = module_0.DoubleLinkedList(var_2)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
>       assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:345: AssertionError
[36m   -[0m [# 367] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  352:         '''Breadth first traversal of tree.'''
  353:         q = Queue()
  354:         q.enqueue(self.root)
  355:         while q.peek():
[34m- 356:             node = q.dequeue()[0m
[32m+ 356:             pass[0m
  357:             yield node.val
  358:             if node.left:
  359:                 q.enqueue(node.left)
  360:             if node.right:
--------------------------------------------------------------------------------
[0.23703 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_41

def test_case_41():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.delete(bst_0)
        var_1 = bst_0.insert(var_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_2 = bst_0.breadth_first()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_2)

MIO/test_binarySearchTree3_MIO.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b982f5390>

>   ???
E   NameError: name 'node' is not defined

binarySearchTree3:357: NameError
[36m   -[0m [# 368] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  353:         q = Queue()
  354:         q.enqueue(self.root)
  355:         while q.peek():
  356:             node = q.dequeue()
[34m- 357:             yield node.val[0m
[32m+ 357:             pass[0m
  358:             if node.left:
  359:                 q.enqueue(node.left)
  360:             if node.right:
  361:                 q.enqueue(node.right)
--------------------------------------------------------------------------------
[0.36491 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_41

def test_case_41():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.delete(bst_0)
        var_1 = bst_0.insert(var_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_2 = bst_0.breadth_first()
        double_linked_list_0 = module_0.DoubleLinkedList(var_2)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
>       assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:345: AssertionError
[36m   -[0m [# 369] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  355:         while q.peek():
  356:             node = q.dequeue()
  357:             yield node.val
  358:             if node.left:
[34m- 359:                 q.enqueue(node.left)[0m
[32m+ 359:                 pass[0m
  360:             if node.right:
  361:                 q.enqueue(node.right)
  362:     
  363:     def delete(self, val):
--------------------------------------------------------------------------------
[0.19949 s] [31msurvived[0m
[36m   -[0m [# 370] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  357:             yield node.val
  358:             if node.left:
  359:                 q.enqueue(node.left)
  360:             if node.right:
[34m- 361:                 q.enqueue(node.right)[0m
[32m+ 361:                 pass[0m
  362:     
  363:     def delete(self, val):
  364:         '''Remove a node from the tree.'''
  365:         if (self._size < 1 or not (self.contains(val))):
--------------------------------------------------------------------------------
[0.20022 s] [31msurvived[0m
[36m   -[0m [# 371] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  362:     
  363:     def delete(self, val):
  364:         '''Remove a node from the tree.'''
  365:         if (self._size < 1 or not (self.contains(val))):
[34m- 366:             return[0m
[32m+ 366:             pass[0m
  367:         
  368:         node = self.search(val)
  369:         
  370:         if node._is_leaf():
--------------------------------------------------------------------------------
[0.22514 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_27

def test_case_27():
        str_0 = '_N*mxW@Y-+\x0c9z|?='
        bst_0 = module_0.Bst(str_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_0 = bst_0.delete(str_0)

MIO/test_binarySearchTree3_MIO.py:220: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98ae5480>
val = '_N*mxW@Y-+\x0c9z|?='

>   ???
E   AttributeError: 'NoneType' object has no attribute '_is_leaf'

binarySearchTree3:370: AttributeError
[36m   -[0m [# 372] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  364:         '''Remove a node from the tree.'''
  365:         if (self._size < 1 or not (self.contains(val))):
  366:             return
  367:         
[34m- 368:         node = self.search(val)[0m
[32m+ 368:         pass[0m
  369:         
  370:         if node._is_leaf():
  371:             if node.parent:
  372:                 setattr(node.parent, node._side(), None)
--------------------------------------------------------------------------------
[0.21758 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_1 = bst_0.delete(bst_0)

MIO/test_binarySearchTree3_MIO.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98aa3280>
val = <binarySearchTree3.Bst object at 0x7f9b98aa3280>

>   ???
E   NameError: name 'node' is not defined

binarySearchTree3:370: NameError
[36m   -[0m [# 373] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  368:         node = self.search(val)
  369:         
  370:         if node._is_leaf():
  371:             if node.parent:
[34m- 372:                 setattr(node.parent, node._side(), None)[0m
[32m+ 372:                 pass[0m
  373:             else:
  374:                 self.root = None
  375:         
  376:         elif node._is_interior():
--------------------------------------------------------------------------------
[0.19424 s] [31msurvived[0m
[36m   -[0m [# 374] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  370:         if node._is_leaf():
  371:             if node.parent:
  372:                 setattr(node.parent, node._side(), None)
  373:             else:
[34m- 374:                 self.root = None[0m
[32m+ 374:                 pass[0m
  375:         
  376:         elif node._is_interior():
  377:             next_node = self._find_replacement(node)
  378:             self._size += 1
--------------------------------------------------------------------------------
[0.20127 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_1 = bst_0.delete(bst_0)
>       assert bst_0.root is None
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:179: AssertionError
[36m   -[0m [# 375] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  373:             else:
  374:                 self.root = None
  375:         
  376:         elif node._is_interior():
[34m- 377:             next_node = self._find_replacement(node)[0m
[32m+ 377:             pass[0m
  378:             self._size += 1
  379:             self.delete(next_node.val)
  380:             node.val = next_node.val
  381:         else:
--------------------------------------------------------------------------------
[0.18380 s] [31msurvived[0m
[36m   -[0m [# 376] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  375:         
  376:         elif node._is_interior():
  377:             next_node = self._find_replacement(node)
  378:             self._size += 1
[34m- 379:             self.delete(next_node.val)[0m
[32m+ 379:             pass[0m
  380:             node.val = next_node.val
  381:         else:
  382:             
  383:             child = getattr(node, node._onlychild())
--------------------------------------------------------------------------------
[0.32085 s] [31msurvived[0m
[36m   -[0m [# 377] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  376:         elif node._is_interior():
  377:             next_node = self._find_replacement(node)
  378:             self._size += 1
  379:             self.delete(next_node.val)
[34m- 380:             node.val = next_node.val[0m
[32m+ 380:             pass[0m
  381:         else:
  382:             
  383:             child = getattr(node, node._onlychild())
  384:             if node.parent:
--------------------------------------------------------------------------------
[0.19772 s] [31msurvived[0m
[36m   -[0m [# 378] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  379:             self.delete(next_node.val)
  380:             node.val = next_node.val
  381:         else:
  382:             
[34m- 383:             child = getattr(node, node._onlychild())[0m
[32m+ 383:             pass[0m
  384:             if node.parent:
  385:                 child.parent = node.parent
  386:                 setattr(node.parent, node._side(), child)
  387:             else:
--------------------------------------------------------------------------------
[0.20318 s] [31msurvived[0m
[36m   -[0m [# 379] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  381:         else:
  382:             
  383:             child = getattr(node, node._onlychild())
  384:             if node.parent:
[34m- 385:                 child.parent = node.parent[0m
[32m+ 385:                 pass[0m
  386:                 setattr(node.parent, node._side(), child)
  387:             else:
  388:                 self.root = child
  389:         
--------------------------------------------------------------------------------
[0.31782 s] [31msurvived[0m
[36m   -[0m [# 380] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  382:             
  383:             child = getattr(node, node._onlychild())
  384:             if node.parent:
  385:                 child.parent = node.parent
[34m- 386:                 setattr(node.parent, node._side(), child)[0m
[32m+ 386:                 pass[0m
  387:             else:
  388:                 self.root = child
  389:         
  390:         self._size -= 1
--------------------------------------------------------------------------------
[0.20154 s] [31msurvived[0m
[36m   -[0m [# 381] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  384:             if node.parent:
  385:                 child.parent = node.parent
  386:                 setattr(node.parent, node._side(), child)
  387:             else:
[34m- 388:                 self.root = child[0m
[32m+ 388:                 pass[0m
  389:         
  390:         self._size -= 1
  391:     
  392:     def _find_replacement(self, node):
--------------------------------------------------------------------------------
[0.19971 s] [31msurvived[0m
[36m   -[0m [# 382] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  391:     
  392:     def _find_replacement(self, node):
  393:         '''Find left most node of right subtree.'''
  394:         if node.right:
[34m- 395:             return self._findmin(node.right)[0m
[32m+ 395:             pass[0m
  396:         
  397:         elif node.parent:
  398:             if node._side() == 'left':
  399:                 return self.parent
--------------------------------------------------------------------------------
[0.20165 s] [31msurvived[0m
[36m   -[0m [# 383] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  395:             return self._findmin(node.right)
  396:         
  397:         elif node.parent:
  398:             if node._side() == 'left':
[34m- 399:                 return self.parent[0m
[32m+ 399:                 pass[0m
  400:             else:
  401:                 node.parent.right = None
  402:                 tmp = self._find_replacement(node.parent)
  403:                 node.parent.right = node
--------------------------------------------------------------------------------
[0.20397 s] [31msurvived[0m
[36m   -[0m [# 384] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  397:         elif node.parent:
  398:             if node._side() == 'left':
  399:                 return self.parent
  400:             else:
[34m- 401:                 node.parent.right = None[0m
[32m+ 401:                 pass[0m
  402:                 tmp = self._find_replacement(node.parent)
  403:                 node.parent.right = node
  404:                 return tmp
  405:     
--------------------------------------------------------------------------------
[0.20034 s] [31msurvived[0m
[36m   -[0m [# 385] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  398:             if node._side() == 'left':
  399:                 return self.parent
  400:             else:
  401:                 node.parent.right = None
[34m- 402:                 tmp = self._find_replacement(node.parent)[0m
[32m+ 402:                 pass[0m
  403:                 node.parent.right = node
  404:                 return tmp
  405:     
  406:     def _findmin(self, node):
--------------------------------------------------------------------------------
[0.19836 s] [31msurvived[0m
[36m   -[0m [# 386] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  399:                 return self.parent
  400:             else:
  401:                 node.parent.right = None
  402:                 tmp = self._find_replacement(node.parent)
[34m- 403:                 node.parent.right = node[0m
[32m+ 403:                 pass[0m
  404:                 return tmp
  405:     
  406:     def _findmin(self, node):
  407:         '''Find min of subtree, Min is always left most node.'''
--------------------------------------------------------------------------------
[0.20099 s] [31msurvived[0m
[36m   -[0m [# 387] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  400:             else:
  401:                 node.parent.right = None
  402:                 tmp = self._find_replacement(node.parent)
  403:                 node.parent.right = node
[34m- 404:                 return tmp[0m
[32m+ 404:                 pass[0m
  405:     
  406:     def _findmin(self, node):
  407:         '''Find min of subtree, Min is always left most node.'''
  408:         while node.left:
--------------------------------------------------------------------------------
[0.33532 s] [31msurvived[0m
[36m   -[0m [# 388] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  405:     
  406:     def _findmin(self, node):
  407:         '''Find min of subtree, Min is always left most node.'''
  408:         while node.left:
[34m- 409:             node = node.left[0m
[32m+ 409:             pass[0m
  410:         return node
--------------------------------------------------------------------------------
[0.20009 s] [31msurvived[0m
[36m   -[0m [# 389] SDL binarySearchTree3: 
--------------------------------------------------------------------------------
  406:     def _findmin(self, node):
  407:         '''Find min of subtree, Min is always left most node.'''
  408:         while node.left:
  409:             node = node.left
[34m- 410:         return node[0m
[32m+ 410:         pass[0m
--------------------------------------------------------------------------------
[0.20454 s] [31msurvived[0m
[36m   -[0m [# 390] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
    4:     '''Node class for data storage.'''
    5:     
    6:     def __init__(self, data=None, next_node=None, prev=None):
    7:         '''Initialize Node.'''
[34m-   8:         self.data = data[0m
[32m+   8:         data = data[0m
    9:         self.next = next_node
   10:         self.prev = prev
   11:     
   12:     def __repr__(self):
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 391] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
    5:     
    6:     def __init__(self, data=None, next_node=None, prev=None):
    7:         '''Initialize Node.'''
    8:         self.data = data
[34m-   9:         self.next = next_node[0m
[32m+   9:         next = next_node[0m
   10:         self.prev = prev
   11:     
   12:     def __repr__(self):
   13:         '''String representation.'''
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 392] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
    6:     def __init__(self, data=None, next_node=None, prev=None):
    7:         '''Initialize Node.'''
    8:         self.data = data
    9:         self.next = next_node
[34m-  10:         self.prev = prev[0m
[32m+  10:         prev = prev[0m
   11:     
   12:     def __repr__(self):
   13:         '''String representation.'''
   14:         return 'Value: {}'.format(self.data)
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 393] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   10:         self.prev = prev
   11:     
   12:     def __repr__(self):
   13:         '''String representation.'''
[34m-  14:         return 'Value: {}'.format(self.data)[0m
[32m+  14:         return 'Value: {}'.format(data)[0m
   15: 
   16: 
   17: class DoubleLinkedList(object):
   18:     '''Double linked list impplementation.
--------------------------------------------------------------------------------
[0.24059 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_45

def test_case_45():
        node_d_l_l_0 = module_0.NodeDLL()
>       var_0 = node_d_l_l_0.__repr__()

MIO/test_binarySearchTree3_MIO.py:369: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[NameError("name 'data' is not defined") raised in repr()] NodeDLL object at 0x7f9b98555b10>

>   ???
E   NameError: name 'data' is not defined

binarySearchTree3:14: NameError
[36m   -[0m [# 394] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   27:     '''
   28:     
   29:     def __init__(self, data=None):
   30:         '''Initialize list.'''
[34m-  31:         self.head = None[0m
[32m+  31:         head = None[0m
   32:         self.tail = None
   33:         self._length = 0
   34:         try:
   35:             for val in data:
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 395] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   28:     
   29:     def __init__(self, data=None):
   30:         '''Initialize list.'''
   31:         self.head = None
[34m-  32:         self.tail = None[0m
[32m+  32:         tail = None[0m
   33:         self._length = 0
   34:         try:
   35:             for val in data:
   36:                 self.push(val)
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 396] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   29:     def __init__(self, data=None):
   30:         '''Initialize list.'''
   31:         self.head = None
   32:         self.tail = None
[34m-  33:         self._length = 0[0m
[32m+  33:         _length = 0[0m
   34:         try:
   35:             for val in data:
   36:                 self.push(val)
   37:         except TypeError:
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 397] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   32:         self.tail = None
   33:         self._length = 0
   34:         try:
   35:             for val in data:
[34m-  36:                 self.push(val)[0m
[32m+  36:                 push(val)[0m
   37:         except TypeError:
   38:             if data:
   39:                 self.push(data)
   40:     
--------------------------------------------------------------------------------
[0.19750 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_0

def test_case_0():
        bytes_0 = b'E\x9c\xce\xc8G'
>       double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)

MIO/test_binarySearchTree3_MIO.py:7: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b984bf310>
data = b'E\x9c\xce\xc8G'

>   ???
E   NameError: name 'push' is not defined

binarySearchTree3:36: NameError
[36m   -[0m [# 398] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   35:             for val in data:
   36:                 self.push(val)
   37:         except TypeError:
   38:             if data:
[34m-  39:                 self.push(data)[0m
[32m+  39:                 push(data)[0m
   40:     
   41:     def push(self, val):
   42:         '''Add val to the head of the list.'''
   43:         old_head = self.head
--------------------------------------------------------------------------------
[0.19904 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_1

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98835420>
data = <binarySearchTree3.Node object at 0x7f9b988349a0>

>   ???
E   TypeError: 'Node' object is not iterable

binarySearchTree3:35: TypeError

During handling of the above exception, another exception occurred:

    def test_case_1():
        node_0 = module_0.Node()
        assert node_0.height == 1
>       double_linked_list_0 = module_0.DoubleLinkedList(node_0)

MIO/test_binarySearchTree3_MIO.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98835420>
data = <binarySearchTree3.Node object at 0x7f9b988349a0>

>   ???
E   NameError: name 'push' is not defined

binarySearchTree3:39: NameError
[36m   -[0m [# 399] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   39:                 self.push(data)
   40:     
   41:     def push(self, val):
   42:         '''Add val to the head of the list.'''
[34m-  43:         old_head = self.head[0m
[32m+  43:         old_head = head[0m
   44:         self.head = NodeDLL(val, next_node=old_head)
   45:         if old_head:
   46:             old_head.prev = self.head
   47:         if not (self.tail):
--------------------------------------------------------------------------------
[0.19771 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_0

def test_case_0():
        bytes_0 = b'E\x9c\xce\xc8G'
>       double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)

MIO/test_binarySearchTree3_MIO.py:7: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:36: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b982f6e30>, val = 69

>   ???
E   NameError: name 'head' is not defined

binarySearchTree3:43: NameError
[36m   -[0m [# 400] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   40:     
   41:     def push(self, val):
   42:         '''Add val to the head of the list.'''
   43:         old_head = self.head
[34m-  44:         self.head = NodeDLL(val, next_node=old_head)[0m
[32m+  44:         head = NodeDLL(val, next_node=old_head)[0m
   45:         if old_head:
   46:             old_head.prev = self.head
   47:         if not (self.tail):
   48:             self.tail = self.head
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 401] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   42:         '''Add val to the head of the list.'''
   43:         old_head = self.head
   44:         self.head = NodeDLL(val, next_node=old_head)
   45:         if old_head:
[34m-  46:             old_head.prev = self.head[0m
[32m+  46:             old_head.prev = head[0m
   47:         if not (self.tail):
   48:             self.tail = self.head
   49:         self._length += 1
   50:     
--------------------------------------------------------------------------------
[0.19529 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_0

def test_case_0():
        bytes_0 = b'E\x9c\xce\xc8G'
>       double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)

MIO/test_binarySearchTree3_MIO.py:7: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:36: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b987e4b80>, val = 156

>   ???
E   NameError: name 'head' is not defined

binarySearchTree3:46: NameError
[36m   -[0m [# 402] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   43:         old_head = self.head
   44:         self.head = NodeDLL(val, next_node=old_head)
   45:         if old_head:
   46:             old_head.prev = self.head
[34m-  47:         if not (self.tail):[0m
[32m+  47:         if not tail:[0m
   48:             self.tail = self.head
   49:         self._length += 1
   50:     
   51:     def pop(self):
--------------------------------------------------------------------------------
[0.19826 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_0

def test_case_0():
        bytes_0 = b'E\x9c\xce\xc8G'
>       double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)

MIO/test_binarySearchTree3_MIO.py:7: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:36: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98a48250>, val = 69

>   ???
E   NameError: name 'tail' is not defined

binarySearchTree3:47: NameError
[36m   -[0m [# 403] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   44:         self.head = NodeDLL(val, next_node=old_head)
   45:         if old_head:
   46:             old_head.prev = self.head
   47:         if not (self.tail):
[34m-  48:             self.tail = self.head[0m
[32m+  48:             tail = self.head[0m
   49:         self._length += 1
   50:     
   51:     def pop(self):
   52:         '''Remove the val from the head of the list.'''
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 404] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   44:         self.head = NodeDLL(val, next_node=old_head)
   45:         if old_head:
   46:             old_head.prev = self.head
   47:         if not (self.tail):
[34m-  48:             self.tail = self.head[0m
[32m+  48:             self.tail = head[0m
   49:         self._length += 1
   50:     
   51:     def pop(self):
   52:         '''Remove the val from the head of the list.'''
--------------------------------------------------------------------------------
[0.19636 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_0

def test_case_0():
        bytes_0 = b'E\x9c\xce\xc8G'
>       double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)

MIO/test_binarySearchTree3_MIO.py:7: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:36: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98d06b60>, val = 69

>   ???
E   NameError: name 'head' is not defined

binarySearchTree3:48: NameError
[36m   -[0m [# 405] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   45:         if old_head:
   46:             old_head.prev = self.head
   47:         if not (self.tail):
   48:             self.tail = self.head
[34m-  49:         self._length += 1[0m
[32m+  49:         _length += 1[0m
   50:     
   51:     def pop(self):
   52:         '''Remove the val from the head of the list.'''
   53:         to_return = self.head
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 406] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   49:         self._length += 1
   50:     
   51:     def pop(self):
   52:         '''Remove the val from the head of the list.'''
[34m-  53:         to_return = self.head[0m
[32m+  53:         to_return = head[0m
   54:         if self._length < 1:
   55:             raise IndexError('Cannot pop from an empty list.')
   56:         
   57:         new_head = self.head.next
--------------------------------------------------------------------------------
[0.20253 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_4

def test_case_4():
        str_0 = 'aX}B^sw\x0cA!<Uq;!!D9'
        queue_0 = module_0.Queue(str_0)
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.dequeue()

MIO/test_binarySearchTree3_MIO.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:143: in dequeue
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b984f21a0>

>   ???
E   NameError: name 'head' is not defined

binarySearchTree3:53: NameError
[36m   -[0m [# 407] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   50:     
   51:     def pop(self):
   52:         '''Remove the val from the head of the list.'''
   53:         to_return = self.head
[34m-  54:         if self._length < 1:[0m
[32m+  54:         if _length < 1:[0m
   55:             raise IndexError('Cannot pop from an empty list.')
   56:         
   57:         new_head = self.head.next
   58:         if new_head:
--------------------------------------------------------------------------------
[0.20107 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_4

def test_case_4():
        str_0 = 'aX}B^sw\x0cA!<Uq;!!D9'
        queue_0 = module_0.Queue(str_0)
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.dequeue()

MIO/test_binarySearchTree3_MIO.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:143: in dequeue
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98aaf700>

>   ???
E   NameError: name '_length' is not defined

binarySearchTree3:54: NameError
[36m   -[0m [# 408] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   53:         to_return = self.head
   54:         if self._length < 1:
   55:             raise IndexError('Cannot pop from an empty list.')
   56:         
[34m-  57:         new_head = self.head.next[0m
[32m+  57:         new_head = head.next[0m
   58:         if new_head:
   59:             new_head.prev = None
   60:         self.head = new_head
   61:         self._length -= 1
--------------------------------------------------------------------------------
[0.20305 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_4

def test_case_4():
        str_0 = 'aX}B^sw\x0cA!<Uq;!!D9'
        queue_0 = module_0.Queue(str_0)
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.dequeue()

MIO/test_binarySearchTree3_MIO.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:143: in dequeue
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b983bd1e0>

>   ???
E   NameError: name 'head' is not defined

binarySearchTree3:57: NameError
[36m   -[0m [# 409] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   56:         
   57:         new_head = self.head.next
   58:         if new_head:
   59:             new_head.prev = None
[34m-  60:         self.head = new_head[0m
[32m+  60:         head = new_head[0m
   61:         self._length -= 1
   62:         if self._length < 1:
   63:             self.tail = None
   64:         return to_return.data
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 410] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   57:         new_head = self.head.next
   58:         if new_head:
   59:             new_head.prev = None
   60:         self.head = new_head
[34m-  61:         self._length -= 1[0m
[32m+  61:         _length -= 1[0m
   62:         if self._length < 1:
   63:             self.tail = None
   64:         return to_return.data
   65:     
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 411] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   58:         if new_head:
   59:             new_head.prev = None
   60:         self.head = new_head
   61:         self._length -= 1
[34m-  62:         if self._length < 1:[0m
[32m+  62:         if _length < 1:[0m
   63:             self.tail = None
   64:         return to_return.data
   65:     
   66:     def append(self, val):
--------------------------------------------------------------------------------
[0.31347 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_4

def test_case_4():
        str_0 = 'aX}B^sw\x0cA!<Uq;!!D9'
        queue_0 = module_0.Queue(str_0)
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.dequeue()

MIO/test_binarySearchTree3_MIO.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:143: in dequeue
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b9845b790>

>   ???
E   NameError: name '_length' is not defined

binarySearchTree3:62: NameError
[36m   -[0m [# 412] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   59:             new_head.prev = None
   60:         self.head = new_head
   61:         self._length -= 1
   62:         if self._length < 1:
[34m-  63:             self.tail = None[0m
[32m+  63:             tail = None[0m
   64:         return to_return.data
   65:     
   66:     def append(self, val):
   67:         '''Add val to the tail of the list.'''
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 413] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   64:         return to_return.data
   65:     
   66:     def append(self, val):
   67:         '''Add val to the tail of the list.'''
[34m-  68:         old_tail = self.tail[0m
[32m+  68:         old_tail = tail[0m
   69:         self.tail = NodeDLL(val, prev=old_tail)
   70:         if old_tail:
   71:             old_tail.next = self.tail
   72:         if self._length < 1:
--------------------------------------------------------------------------------
[0.20942 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_7

def test_case_7():
        queue_0 = module_0.Queue()
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.enqueue(queue_0)

MIO/test_binarySearchTree3_MIO.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:139: in enqueue
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b989e2a70>
val = <binarySearchTree3.Queue object at 0x7f9b989e2a40>

>   ???
E   NameError: name 'tail' is not defined

binarySearchTree3:68: NameError
[36m   -[0m [# 414] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   65:     
   66:     def append(self, val):
   67:         '''Add val to the tail of the list.'''
   68:         old_tail = self.tail
[34m-  69:         self.tail = NodeDLL(val, prev=old_tail)[0m
[32m+  69:         tail = NodeDLL(val, prev=old_tail)[0m
   70:         if old_tail:
   71:             old_tail.next = self.tail
   72:         if self._length < 1:
   73:             self.head = self.tail
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 415] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   67:         '''Add val to the tail of the list.'''
   68:         old_tail = self.tail
   69:         self.tail = NodeDLL(val, prev=old_tail)
   70:         if old_tail:
[34m-  71:             old_tail.next = self.tail[0m
[32m+  71:             old_tail.next = tail[0m
   72:         if self._length < 1:
   73:             self.head = self.tail
   74:         self._length += 1
   75:     
--------------------------------------------------------------------------------
[0.21021 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_8

def test_case_8():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.push(double_linked_list_0)
        assert f'{type(double_linked_list_0.tail).__module__}.{type(double_linked_list_0.tail).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_1 = double_linked_list_0.append(double_linked_list_0)

MIO/test_binarySearchTree3_MIO.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98270670>
val = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98270670>

>   ???
E   NameError: name 'tail' is not defined

binarySearchTree3:71: NameError
[36m   -[0m [# 416] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   68:         old_tail = self.tail
   69:         self.tail = NodeDLL(val, prev=old_tail)
   70:         if old_tail:
   71:             old_tail.next = self.tail
[34m-  72:         if self._length < 1:[0m
[32m+  72:         if _length < 1:[0m
   73:             self.head = self.tail
   74:         self._length += 1
   75:     
   76:     def shift(self):
--------------------------------------------------------------------------------
[0.21128 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_7

def test_case_7():
        queue_0 = module_0.Queue()
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.enqueue(queue_0)

MIO/test_binarySearchTree3_MIO.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:139: in enqueue
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b987a87f0>
val = <binarySearchTree3.Queue object at 0x7f9b987a8820>

>   ???
E   NameError: name '_length' is not defined

binarySearchTree3:72: NameError
[36m   -[0m [# 417] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   69:         self.tail = NodeDLL(val, prev=old_tail)
   70:         if old_tail:
   71:             old_tail.next = self.tail
   72:         if self._length < 1:
[34m-  73:             self.head = self.tail[0m
[32m+  73:             head = self.tail[0m
   74:         self._length += 1
   75:     
   76:     def shift(self):
   77:         '''Remove the val from the tail of the list.'''
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 418] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   69:         self.tail = NodeDLL(val, prev=old_tail)
   70:         if old_tail:
   71:             old_tail.next = self.tail
   72:         if self._length < 1:
[34m-  73:             self.head = self.tail[0m
[32m+  73:             self.head = tail[0m
   74:         self._length += 1
   75:     
   76:     def shift(self):
   77:         '''Remove the val from the tail of the list.'''
--------------------------------------------------------------------------------
[0.21015 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_7

def test_case_7():
        queue_0 = module_0.Queue()
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.enqueue(queue_0)

MIO/test_binarySearchTree3_MIO.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:139: in enqueue
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98828b80>
val = <binarySearchTree3.Queue object at 0x7f9b9882b970>

>   ???
E   NameError: name 'tail' is not defined

binarySearchTree3:73: NameError
[36m   -[0m [# 419] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   70:         if old_tail:
   71:             old_tail.next = self.tail
   72:         if self._length < 1:
   73:             self.head = self.tail
[34m-  74:         self._length += 1[0m
[32m+  74:         _length += 1[0m
   75:     
   76:     def shift(self):
   77:         '''Remove the val from the tail of the list.'''
   78:         to_return = self.tail
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 420] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   74:         self._length += 1
   75:     
   76:     def shift(self):
   77:         '''Remove the val from the tail of the list.'''
[34m-  78:         to_return = self.tail[0m
[32m+  78:         to_return = tail[0m
   79:         if self._length < 1:
   80:             raise IndexError('Cannot shift from an empty list.')
   81:         
   82:         new_tail = self.tail.prev
--------------------------------------------------------------------------------
[0.20622 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_9

def test_case_9():
        bytes_0 = b'@\x95\xef|X\x9c\x0b\xbd\x9d\xbd\x9d)\x19\xa9'
        double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
        assert f'{type(double_linked_list_0.tail).__module__}.{type(double_linked_list_0.tail).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_0 = double_linked_list_0.shift()

MIO/test_binarySearchTree3_MIO.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b988d5ab0>

>   ???
E   NameError: name 'tail' is not defined

binarySearchTree3:78: NameError
[36m   -[0m [# 421] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   75:     
   76:     def shift(self):
   77:         '''Remove the val from the tail of the list.'''
   78:         to_return = self.tail
[34m-  79:         if self._length < 1:[0m
[32m+  79:         if _length < 1:[0m
   80:             raise IndexError('Cannot shift from an empty list.')
   81:         
   82:         new_tail = self.tail.prev
   83:         if new_tail:
--------------------------------------------------------------------------------
[0.20593 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_9

def test_case_9():
        bytes_0 = b'@\x95\xef|X\x9c\x0b\xbd\x9d\xbd\x9d)\x19\xa9'
        double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
        assert f'{type(double_linked_list_0.tail).__module__}.{type(double_linked_list_0.tail).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_0 = double_linked_list_0.shift()

MIO/test_binarySearchTree3_MIO.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b989b6920>

>   ???
E   NameError: name '_length' is not defined

binarySearchTree3:79: NameError
[36m   -[0m [# 422] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   78:         to_return = self.tail
   79:         if self._length < 1:
   80:             raise IndexError('Cannot shift from an empty list.')
   81:         
[34m-  82:         new_tail = self.tail.prev[0m
[32m+  82:         new_tail = tail.prev[0m
   83:         if new_tail:
   84:             new_tail.next = None
   85:         self.tail = new_tail
   86:         self._length -= 1
--------------------------------------------------------------------------------
[0.33483 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_9

def test_case_9():
        bytes_0 = b'@\x95\xef|X\x9c\x0b\xbd\x9d\xbd\x9d)\x19\xa9'
        double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
        assert f'{type(double_linked_list_0.tail).__module__}.{type(double_linked_list_0.tail).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_0 = double_linked_list_0.shift()

MIO/test_binarySearchTree3_MIO.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b989e2d40>

>   ???
E   NameError: name 'tail' is not defined

binarySearchTree3:82: NameError
[36m   -[0m [# 423] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   81:         
   82:         new_tail = self.tail.prev
   83:         if new_tail:
   84:             new_tail.next = None
[34m-  85:         self.tail = new_tail[0m
[32m+  85:         tail = new_tail[0m
   86:         self._length -= 1
   87:         if self._length < 1:
   88:             self.tail = None
   89:         return to_return.data
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 424] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   82:         new_tail = self.tail.prev
   83:         if new_tail:
   84:             new_tail.next = None
   85:         self.tail = new_tail
[34m-  86:         self._length -= 1[0m
[32m+  86:         _length -= 1[0m
   87:         if self._length < 1:
   88:             self.tail = None
   89:         return to_return.data
   90:     
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 425] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   83:         if new_tail:
   84:             new_tail.next = None
   85:         self.tail = new_tail
   86:         self._length -= 1
[34m-  87:         if self._length < 1:[0m
[32m+  87:         if _length < 1:[0m
   88:             self.tail = None
   89:         return to_return.data
   90:     
   91:     def remove(self, val):
--------------------------------------------------------------------------------
[0.20367 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_9

def test_case_9():
        bytes_0 = b'@\x95\xef|X\x9c\x0b\xbd\x9d\xbd\x9d)\x19\xa9'
        double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
        assert f'{type(double_linked_list_0.tail).__module__}.{type(double_linked_list_0.tail).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_0 = double_linked_list_0.shift()

MIO/test_binarySearchTree3_MIO.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98aae020>

>   ???
E   NameError: name '_length' is not defined

binarySearchTree3:87: NameError
[36m   -[0m [# 426] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   84:             new_tail.next = None
   85:         self.tail = new_tail
   86:         self._length -= 1
   87:         if self._length < 1:
[34m-  88:             self.tail = None[0m
[32m+  88:             tail = None[0m
   89:         return to_return.data
   90:     
   91:     def remove(self, val):
   92:         '''Remove first occurance of val from list.'''
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 427] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   89:         return to_return.data
   90:     
   91:     def remove(self, val):
   92:         '''Remove first occurance of val from list.'''
[34m-  93:         curr = self.head[0m
[32m+  93:         curr = head[0m
   94:         while curr:
   95:             if curr.data is val:
   96:                 if self._length == 1:
   97:                     (self.head, self.tail) = (None, None)
--------------------------------------------------------------------------------
[0.20627 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_12

def test_case_12():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.append(double_linked_list_0)
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_1 = double_linked_list_0.remove(double_linked_list_0)

MIO/test_binarySearchTree3_MIO.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98ab4a60>
val = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98ab4a60>

>   ???
E   NameError: name 'head' is not defined

binarySearchTree3:93: NameError
[36m   -[0m [# 428] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   92:         '''Remove first occurance of val from list.'''
   93:         curr = self.head
   94:         while curr:
   95:             if curr.data is val:
[34m-  96:                 if self._length == 1:[0m
[32m+  96:                 if _length == 1:[0m
   97:                     (self.head, self.tail) = (None, None)
   98:                 elif (curr is not self.head and curr is not self.tail):
   99:                     (curr.next.prev, curr.prev.next) = (curr.prev, curr.next)
  100:                 elif curr is self.head:
--------------------------------------------------------------------------------
[0.20746 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_12

def test_case_12():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.append(double_linked_list_0)
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_1 = double_linked_list_0.remove(double_linked_list_0)

MIO/test_binarySearchTree3_MIO.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b988b01f0>
val = <binarySearchTree3.DoubleLinkedList object at 0x7f9b988b01f0>

>   ???
E   NameError: name '_length' is not defined

binarySearchTree3:96: NameError
[36m   -[0m [# 429] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   93:         curr = self.head
   94:         while curr:
   95:             if curr.data is val:
   96:                 if self._length == 1:
[34m-  97:                     (self.head, self.tail) = (None, None)[0m
[32m+  97:                     (head, self.tail) = (None, None)[0m
   98:                 elif (curr is not self.head and curr is not self.tail):
   99:                     (curr.next.prev, curr.prev.next) = (curr.prev, curr.next)
  100:                 elif curr is self.head:
  101:                     (self.head, curr.next.prev) = (curr.next, None)
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 430] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   93:         curr = self.head
   94:         while curr:
   95:             if curr.data is val:
   96:                 if self._length == 1:
[34m-  97:                     (self.head, self.tail) = (None, None)[0m
[32m+  97:                     (self.head, tail) = (None, None)[0m
   98:                 elif (curr is not self.head and curr is not self.tail):
   99:                     (curr.next.prev, curr.prev.next) = (curr.prev, curr.next)
  100:                 elif curr is self.head:
  101:                     (self.head, curr.next.prev) = (curr.next, None)
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 431] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   94:         while curr:
   95:             if curr.data is val:
   96:                 if self._length == 1:
   97:                     (self.head, self.tail) = (None, None)
[34m-  98:                 elif (curr is not self.head and curr is not self.tail):[0m
[32m+  98:                 elif (curr is not head and curr is not self.tail):[0m
   99:                     (curr.next.prev, curr.prev.next) = (curr.prev, curr.next)
  100:                 elif curr is self.head:
  101:                     (self.head, curr.next.prev) = (curr.next, None)
  102:                 elif curr is self.tail:
--------------------------------------------------------------------------------
[0.21213 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_13

def test_case_13():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.append(double_linked_list_0)
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
        var_1 = double_linked_list_0.append(var_0)
>       var_2 = double_linked_list_0.remove(double_linked_list_0)

MIO/test_binarySearchTree3_MIO.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b984639a0>
val = <binarySearchTree3.DoubleLinkedList object at 0x7f9b984639a0>

>   ???
E   NameError: name 'head' is not defined

binarySearchTree3:98: NameError
[36m   -[0m [# 432] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   94:         while curr:
   95:             if curr.data is val:
   96:                 if self._length == 1:
   97:                     (self.head, self.tail) = (None, None)
[34m-  98:                 elif (curr is not self.head and curr is not self.tail):[0m
[32m+  98:                 elif (curr is not self.head and curr is not tail):[0m
   99:                     (curr.next.prev, curr.prev.next) = (curr.prev, curr.next)
  100:                 elif curr is self.head:
  101:                     (self.head, curr.next.prev) = (curr.next, None)
  102:                 elif curr is self.tail:
--------------------------------------------------------------------------------
[0.21328 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_14

def test_case_14():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.push(double_linked_list_0)
        assert f'{type(double_linked_list_0.tail).__module__}.{type(double_linked_list_0.tail).__qualname__}' == 'binarySearchTree3.NodeDLL'
        var_1 = double_linked_list_0.push(var_0)
>       var_2 = double_linked_list_0.remove(double_linked_list_0)

MIO/test_binarySearchTree3_MIO.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98ab4070>
val = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98ab4070>

>   ???
E   NameError: name 'tail' is not defined

binarySearchTree3:98: NameError
[36m   -[0m [# 433] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   96:                 if self._length == 1:
   97:                     (self.head, self.tail) = (None, None)
   98:                 elif (curr is not self.head and curr is not self.tail):
   99:                     (curr.next.prev, curr.prev.next) = (curr.prev, curr.next)
[34m- 100:                 elif curr is self.head:[0m
[32m+ 100:                 elif curr is head:[0m
  101:                     (self.head, curr.next.prev) = (curr.next, None)
  102:                 elif curr is self.tail:
  103:                     (self.tail, curr.prev.next) = (curr.prev, None)
  104:                 self._length -= 1
--------------------------------------------------------------------------------
[0.21101 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_13

def test_case_13():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.append(double_linked_list_0)
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
        var_1 = double_linked_list_0.append(var_0)
>       var_2 = double_linked_list_0.remove(double_linked_list_0)

MIO/test_binarySearchTree3_MIO.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b989bd0f0>
val = <binarySearchTree3.DoubleLinkedList object at 0x7f9b989bd0f0>

>   ???
E   NameError: name 'head' is not defined

binarySearchTree3:100: NameError
[36m   -[0m [# 434] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   97:                     (self.head, self.tail) = (None, None)
   98:                 elif (curr is not self.head and curr is not self.tail):
   99:                     (curr.next.prev, curr.prev.next) = (curr.prev, curr.next)
  100:                 elif curr is self.head:
[34m- 101:                     (self.head, curr.next.prev) = (curr.next, None)[0m
[32m+ 101:                     (head, curr.next.prev) = (curr.next, None)[0m
  102:                 elif curr is self.tail:
  103:                     (self.tail, curr.prev.next) = (curr.prev, None)
  104:                 self._length -= 1
  105:                 return
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 435] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   98:                 elif (curr is not self.head and curr is not self.tail):
   99:                     (curr.next.prev, curr.prev.next) = (curr.prev, curr.next)
  100:                 elif curr is self.head:
  101:                     (self.head, curr.next.prev) = (curr.next, None)
[34m- 102:                 elif curr is self.tail:[0m
[32m+ 102:                 elif curr is tail:[0m
  103:                     (self.tail, curr.prev.next) = (curr.prev, None)
  104:                 self._length -= 1
  105:                 return
  106:             curr = curr.next
--------------------------------------------------------------------------------
[0.21569 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_14

def test_case_14():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.push(double_linked_list_0)
        assert f'{type(double_linked_list_0.tail).__module__}.{type(double_linked_list_0.tail).__qualname__}' == 'binarySearchTree3.NodeDLL'
        var_1 = double_linked_list_0.push(var_0)
>       var_2 = double_linked_list_0.remove(double_linked_list_0)

MIO/test_binarySearchTree3_MIO.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98381930>
val = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98381930>

>   ???
E   NameError: name 'tail' is not defined

binarySearchTree3:102: NameError
[36m   -[0m [# 436] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
   99:                     (curr.next.prev, curr.prev.next) = (curr.prev, curr.next)
  100:                 elif curr is self.head:
  101:                     (self.head, curr.next.prev) = (curr.next, None)
  102:                 elif curr is self.tail:
[34m- 103:                     (self.tail, curr.prev.next) = (curr.prev, None)[0m
[32m+ 103:                     (tail, curr.prev.next) = (curr.prev, None)[0m
  104:                 self._length -= 1
  105:                 return
  106:             curr = curr.next
  107:         
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 437] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  100:                 elif curr is self.head:
  101:                     (self.head, curr.next.prev) = (curr.next, None)
  102:                 elif curr is self.tail:
  103:                     (self.tail, curr.prev.next) = (curr.prev, None)
[34m- 104:                 self._length -= 1[0m
[32m+ 104:                 _length -= 1[0m
  105:                 return
  106:             curr = curr.next
  107:         
  108:         raise ValueError('{} is not in the list'.format(val))
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 438] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  111:         '''Return list representation of dll.'''
  112:         l = []
  113:         while True:
  114:             try:
[34m- 115:                 popped_data = self.pop()[0m
[32m+ 115:                 popped_data = pop()[0m
  116:                 l.append(popped_data)
  117:             except IndexError:
  118:                 break
  119:         return l
--------------------------------------------------------------------------------
[0.31964 s] [31msurvived[0m
[36m   -[0m [# 439] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  131:     '''
  132:     
  133:     def __init__(self, data=None):
  134:         '''Initialize queue data structure.'''
[34m- 135:         self._container = DoubleLinkedList(data)[0m
[32m+ 135:         _container = DoubleLinkedList(data)[0m
  136:     
  137:     def enqueue(self, val):
  138:         '''Add a value to the queue.'''
  139:         self._container.append(val)
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 440] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  135:         self._container = DoubleLinkedList(data)
  136:     
  137:     def enqueue(self, val):
  138:         '''Add a value to the queue.'''
[34m- 139:         self._container.append(val)[0m
[32m+ 139:         _container.append(val)[0m
  140:     
  141:     def dequeue(self):
  142:         '''Remove a value from the front of the queue.'''
  143:         return self._container.pop()
--------------------------------------------------------------------------------
[0.20777 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_7

def test_case_7():
        queue_0 = module_0.Queue()
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.enqueue(queue_0)

MIO/test_binarySearchTree3_MIO.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Queue object at 0x7f9b987529b0>
val = <binarySearchTree3.Queue object at 0x7f9b987529b0>

>   ???
E   NameError: name '_container' is not defined

binarySearchTree3:139: NameError
[36m   -[0m [# 441] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  139:         self._container.append(val)
  140:     
  141:     def dequeue(self):
  142:         '''Remove a value from the front of the queue.'''
[34m- 143:         return self._container.pop()[0m
[32m+ 143:         return _container.pop()[0m
  144:     
  145:     def peek(self):
  146:         '''Return the next value in the queue without dequing it.'''
  147:         try:
--------------------------------------------------------------------------------
[0.19884 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_4

def test_case_4():
        str_0 = 'aX}B^sw\x0cA!<Uq;!!D9'
        queue_0 = module_0.Queue(str_0)
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.dequeue()

MIO/test_binarySearchTree3_MIO.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Queue object at 0x7f9b983a1180>

>   ???
E   NameError: name '_container' is not defined

binarySearchTree3:143: NameError
[36m   -[0m [# 442] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  144:     
  145:     def peek(self):
  146:         '''Return the next value in the queue without dequing it.'''
  147:         try:
[34m- 148:             return self._container.head.data[0m
[32m+ 148:             return _container.head.data[0m
  149:         except AttributeError:
  150:             return None
  151:     
  152:     def size(self):
--------------------------------------------------------------------------------
[0.22083 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_19

def test_case_19():
        queue_0 = module_0.Queue()
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.peek()

MIO/test_binarySearchTree3_MIO.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Queue object at 0x7f9b98554310>

>   ???
E   NameError: name '_container' is not defined

binarySearchTree3:148: NameError
[36m   -[0m [# 443] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  150:             return None
  151:     
  152:     def size(self):
  153:         '''Return the size of the queue.'''
[34m- 154:         return self._container._length[0m
[32m+ 154:         return _container._length[0m
  155: 
  156: class Node(object):
  157:     '''Node, or leaf of the BST.'''
  158:     
--------------------------------------------------------------------------------
[0.22308 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_47

def test_case_47():
        queue_0 = module_0.Queue()
        assert f'{type(queue_0).__module__}.{type(queue_0).__qualname__}' == 'binarySearchTree3.Queue'
>       var_0 = queue_0.size()

MIO/test_binarySearchTree3_MIO.py:379: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Queue object at 0x7f9b98976b00>

>   ???
E   NameError: name '_container' is not defined

binarySearchTree3:154: NameError
[36m   -[0m [# 444] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  157:     '''Node, or leaf of the BST.'''
  158:     
  159:     def __init__(self, val=None, parent=None):
  160:         '''Create node object.'''
[34m- 161:         self.val = val[0m
[32m+ 161:         val = val[0m
  162:         self.right = None
  163:         self.left = None
  164:         self.parent = parent
  165:         self.height = 1
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 445] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  158:     
  159:     def __init__(self, val=None, parent=None):
  160:         '''Create node object.'''
  161:         self.val = val
[34m- 162:         self.right = None[0m
[32m+ 162:         right = None[0m
  163:         self.left = None
  164:         self.parent = parent
  165:         self.height = 1
  166:     
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 446] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  159:     def __init__(self, val=None, parent=None):
  160:         '''Create node object.'''
  161:         self.val = val
  162:         self.right = None
[34m- 163:         self.left = None[0m
[32m+ 163:         left = None[0m
  164:         self.parent = parent
  165:         self.height = 1
  166:     
  167:     def _is_leaf(self):
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 447] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  160:         '''Create node object.'''
  161:         self.val = val
  162:         self.right = None
  163:         self.left = None
[34m- 164:         self.parent = parent[0m
[32m+ 164:         parent = parent[0m
  165:         self.height = 1
  166:     
  167:     def _is_leaf(self):
  168:         '''Return true if a leaf.'''
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 448] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  161:         self.val = val
  162:         self.right = None
  163:         self.left = None
  164:         self.parent = parent
[34m- 165:         self.height = 1[0m
[32m+ 165:         height = 1[0m
  166:     
  167:     def _is_leaf(self):
  168:         '''Return true if a leaf.'''
  169:         return not ((self.right or self.left))
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 449] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  165:         self.height = 1
  166:     
  167:     def _is_leaf(self):
  168:         '''Return true if a leaf.'''
[34m- 169:         return not ((self.right or self.left))[0m
[32m+ 169:         return not ((right or self.left))[0m
  170:     
  171:     def _is_interior(self):
  172:         '''Return true if a interior node.'''
  173:         return (self.right and self.left)
--------------------------------------------------------------------------------
[0.34336 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_1 = bst_0.delete(bst_0)

MIO/test_binarySearchTree3_MIO.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:370: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Node object at 0x7f9b98834130>

>   ???
E   NameError: name 'right' is not defined

binarySearchTree3:169: NameError
[36m   -[0m [# 450] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  165:         self.height = 1
  166:     
  167:     def _is_leaf(self):
  168:         '''Return true if a leaf.'''
[34m- 169:         return not ((self.right or self.left))[0m
[32m+ 169:         return not ((self.right or left))[0m
  170:     
  171:     def _is_interior(self):
  172:         '''Return true if a interior node.'''
  173:         return (self.right and self.left)
--------------------------------------------------------------------------------
[0.21586 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_1 = bst_0.delete(bst_0)

MIO/test_binarySearchTree3_MIO.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:370: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Node object at 0x7f9b9867b8e0>

>   ???
E   NameError: name 'left' is not defined

binarySearchTree3:169: NameError
[36m   -[0m [# 451] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  169:         return not ((self.right or self.left))
  170:     
  171:     def _is_interior(self):
  172:         '''Return true if a interior node.'''
[34m- 173:         return (self.right and self.left)[0m
[32m+ 173:         return (right and self.left)[0m
  174:     
  175:     def _onlychild(self):
  176:         '''Return string depending on children.'''
  177:         if (self.left and not (self.right)):
--------------------------------------------------------------------------------
[0.21904 s] [31msurvived[0m
[36m   -[0m [# 452] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  169:         return not ((self.right or self.left))
  170:     
  171:     def _is_interior(self):
  172:         '''Return true if a interior node.'''
[34m- 173:         return (self.right and self.left)[0m
[32m+ 173:         return (self.right and left)[0m
  174:     
  175:     def _onlychild(self):
  176:         '''Return string depending on children.'''
  177:         if (self.left and not (self.right)):
--------------------------------------------------------------------------------
[0.18172 s] [31msurvived[0m
[36m   -[0m [# 453] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  173:         return (self.right and self.left)
  174:     
  175:     def _onlychild(self):
  176:         '''Return string depending on children.'''
[34m- 177:         if (self.left and not (self.right)):[0m
[32m+ 177:         if (left and not (self.right)):[0m
  178:             return 'left'
  179:         if (self.right and not (self.left)):
  180:             return 'right'
  181:     
--------------------------------------------------------------------------------
[0.19093 s] [31msurvived[0m
[36m   -[0m [# 454] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  173:         return (self.right and self.left)
  174:     
  175:     def _onlychild(self):
  176:         '''Return string depending on children.'''
[34m- 177:         if (self.left and not (self.right)):[0m
[32m+ 177:         if (self.left and not right):[0m
  178:             return 'left'
  179:         if (self.right and not (self.left)):
  180:             return 'right'
  181:     
--------------------------------------------------------------------------------
[0.19242 s] [31msurvived[0m
[36m   -[0m [# 455] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  175:     def _onlychild(self):
  176:         '''Return string depending on children.'''
  177:         if (self.left and not (self.right)):
  178:             return 'left'
[34m- 179:         if (self.right and not (self.left)):[0m
[32m+ 179:         if (right and not (self.left)):[0m
  180:             return 'right'
  181:     
  182:     def _side(self):
  183:         '''Return if left or right child of parent.'''
--------------------------------------------------------------------------------
[0.19329 s] [31msurvived[0m
[36m   -[0m [# 456] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  175:     def _onlychild(self):
  176:         '''Return string depending on children.'''
  177:         if (self.left and not (self.right)):
  178:             return 'left'
[34m- 179:         if (self.right and not (self.left)):[0m
[32m+ 179:         if (self.right and not left):[0m
  180:             return 'right'
  181:     
  182:     def _side(self):
  183:         '''Return if left or right child of parent.'''
--------------------------------------------------------------------------------
[0.19907 s] [31msurvived[0m
[36m   -[0m [# 457] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  180:             return 'right'
  181:     
  182:     def _side(self):
  183:         '''Return if left or right child of parent.'''
[34m- 184:         if self.parent:[0m
[32m+ 184:         if parent:[0m
  185:             return 'left' if self.parent.left == self else 'right'
  186: 
  187: 
  188: class Bst(object):
--------------------------------------------------------------------------------
[0.32989 s] [31msurvived[0m
[36m   -[0m [# 458] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  181:     
  182:     def _side(self):
  183:         '''Return if left or right child of parent.'''
  184:         if self.parent:
[34m- 185:             return 'left' if self.parent.left == self else 'right'[0m
[32m+ 185:             return 'left' if parent.left == self else 'right'[0m
  186: 
  187: 
  188: class Bst(object):
  189:     '''Binary Search Tree.
--------------------------------------------------------------------------------
[0.19931 s] [31msurvived[0m
[36m   -[0m [# 459] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  226:     '''
  227:     
  228:     def __init__(self, data=None):
  229:         '''Initialize tree.'''
[34m- 230:         self._size = 0[0m
[32m+ 230:         _size = 0[0m
  231:         self.root = None
  232:         
  233:         if data:
  234:             for i in data:
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 460] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  227:     
  228:     def __init__(self, data=None):
  229:         '''Initialize tree.'''
  230:         self._size = 0
[34m- 231:         self.root = None[0m
[32m+ 231:         root = None[0m
  232:         
  233:         if data:
  234:             for i in data:
  235:                 self.insert(i)
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 461] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  231:         self.root = None
  232:         
  233:         if data:
  234:             for i in data:
[34m- 235:                 self.insert(i)[0m
[32m+ 235:                 insert(i)[0m
  236:     
  237:     def insert(self, val):
  238:         '''Insert val into BST. If val is already present will be ignored.'''
  239:         if not (self.root):
--------------------------------------------------------------------------------
[0.19862 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_21

def test_case_21():
        bytes_0 = b'z\xc7'
>       bst_0 = module_0.Bst(bytes_0)

MIO/test_binarySearchTree3_MIO.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98271a80>, data = b'z\xc7'

>   ???
E   NameError: name 'insert' is not defined

binarySearchTree3:235: NameError
[36m   -[0m [# 462] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  235:                 self.insert(i)
  236:     
  237:     def insert(self, val):
  238:         '''Insert val into BST. If val is already present will be ignored.'''
[34m- 239:         if not (self.root):[0m
[32m+ 239:         if not root:[0m
  240:             self.root = Node(val)
  241:             self._size += 1
  242:         else:
  243:             self._step(val, self.root)
--------------------------------------------------------------------------------
[0.21656 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
>       var_0 = bst_0.insert(bst_0)

MIO/test_binarySearchTree3_MIO.py:176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b987a8340>
val = <binarySearchTree3.Bst object at 0x7f9b987a8340>

>   ???
E   NameError: name 'root' is not defined

binarySearchTree3:239: NameError
[36m   -[0m [# 463] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  236:     
  237:     def insert(self, val):
  238:         '''Insert val into BST. If val is already present will be ignored.'''
  239:         if not (self.root):
[34m- 240:             self.root = Node(val)[0m
[32m+ 240:             root = Node(val)[0m
  241:             self._size += 1
  242:         else:
  243:             self._step(val, self.root)
  244:     
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 464] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  237:     def insert(self, val):
  238:         '''Insert val into BST. If val is already present will be ignored.'''
  239:         if not (self.root):
  240:             self.root = Node(val)
[34m- 241:             self._size += 1[0m
[32m+ 241:             _size += 1[0m
  242:         else:
  243:             self._step(val, self.root)
  244:     
  245:     def _step(self, val, curr):
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 465] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  239:         if not (self.root):
  240:             self.root = Node(val)
  241:             self._size += 1
  242:         else:
[34m- 243:             self._step(val, self.root)[0m
[32m+ 243:             _step(val, self.root)[0m
  244:     
  245:     def _step(self, val, curr):
  246:         '''Decide left or right and returns height.'''
  247:         if val < curr.val:
--------------------------------------------------------------------------------
[0.34911 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_21

def test_case_21():
        bytes_0 = b'z\xc7'
>       bst_0 = module_0.Bst(bytes_0)

MIO/test_binarySearchTree3_MIO.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:235: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b982f76a0>, val = 199

>   ???
E   NameError: name '_step' is not defined

binarySearchTree3:243: NameError
[36m   -[0m [# 466] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  239:         if not (self.root):
  240:             self.root = Node(val)
  241:             self._size += 1
  242:         else:
[34m- 243:             self._step(val, self.root)[0m
[32m+ 243:             self._step(val, root)[0m
  244:     
  245:     def _step(self, val, curr):
  246:         '''Decide left or right and returns height.'''
  247:         if val < curr.val:
--------------------------------------------------------------------------------
[0.21612 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_21

def test_case_21():
        bytes_0 = b'z\xc7'
>       bst_0 = module_0.Bst(bytes_0)

MIO/test_binarySearchTree3_MIO.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:235: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b9838af50>, val = 199

>   ???
E   NameError: name 'root' is not defined

binarySearchTree3:243: NameError
[36m   -[0m [# 467] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  244:     
  245:     def _step(self, val, curr):
  246:         '''Decide left or right and returns height.'''
  247:         if val < curr.val:
[34m- 248:             curr = self._set_child(curr, 'left', val)[0m
[32m+ 248:             curr = _set_child(curr, 'left', val)[0m
  249:         elif val > curr.val:
  250:             curr = self._set_child(curr, 'right', val)
  251:         return curr.height
  252:     
--------------------------------------------------------------------------------
[0.22211 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_25

def test_case_25():
        bytes_0 = b'd~\xd8\xfc\xfd,@,$\xb91f\xe7\x92\xc2\x14\xd3H'
>       bst_0 = module_0.Bst(bytes_0)

MIO/test_binarySearchTree3_MIO.py:205: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:235: in __init__
    ???
binarySearchTree3:243: in insert
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b982151e0>, val = 44
curr = <binarySearchTree3.Node object at 0x7f9b98215270>

>   ???
E   NameError: name '_set_child' is not defined

binarySearchTree3:248: NameError
[36m   -[0m [# 468] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  246:         '''Decide left or right and returns height.'''
  247:         if val < curr.val:
  248:             curr = self._set_child(curr, 'left', val)
  249:         elif val > curr.val:
[34m- 250:             curr = self._set_child(curr, 'right', val)[0m
[32m+ 250:             curr = _set_child(curr, 'right', val)[0m
  251:         return curr.height
  252:     
  253:     def _set_child(self, curr, side, val):
  254:         '''Helping.'''
--------------------------------------------------------------------------------
[0.19923 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_21

def test_case_21():
        bytes_0 = b'z\xc7'
>       bst_0 = module_0.Bst(bytes_0)

MIO/test_binarySearchTree3_MIO.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:235: in __init__
    ???
binarySearchTree3:243: in insert
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98a15450>, val = 199
curr = <binarySearchTree3.Node object at 0x7f9b98a17d90>

>   ???
E   NameError: name '_set_child' is not defined

binarySearchTree3:250: NameError
[36m   -[0m [# 469] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  253:     def _set_child(self, curr, side, val):
  254:         '''Helping.'''
  255:         child = getattr(curr, side)
  256:         if child:
[34m- 257:             count = self._step(val, child)[0m
[32m+ 257:             count = _step(val, child)[0m
  258:             if curr.height <= count:
  259:                 curr.height += 1
  260:         else:
  261:             setattr(curr, side, Node(val, curr))
--------------------------------------------------------------------------------
[0.22164 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_25

def test_case_25():
        bytes_0 = b'd~\xd8\xfc\xfd,@,$\xb91f\xe7\x92\xc2\x14\xd3H'
>       bst_0 = module_0.Bst(bytes_0)

MIO/test_binarySearchTree3_MIO.py:205: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:235: in __init__
    ???
binarySearchTree3:243: in insert
    ???
binarySearchTree3:250: in _step
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b987e4be0>
curr = <binarySearchTree3.Node object at 0x7f9b987e4e20>, side = 'right'
val = 216

>   ???
E   NameError: name '_step' is not defined

binarySearchTree3:257: NameError
[36m   -[0m [# 470] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  258:             if curr.height <= count:
  259:                 curr.height += 1
  260:         else:
  261:             setattr(curr, side, Node(val, curr))
[34m- 262:             self._size += 1[0m
[32m+ 262:             _size += 1[0m
  263:             if curr.height == 1:
  264:                 curr.height += 1
  265:         return curr
  266:     
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 471] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  265:         return curr
  266:     
  267:     def search(self, val):
  268:         '''Return the node containing val.'''
[34m- 269:         curr = self.root[0m
[32m+ 269:         curr = root[0m
  270:         while curr:
  271:             if curr.val == val:
  272:                 return curr
  273:             elif val < curr.val:
--------------------------------------------------------------------------------
[0.21646 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_1 = bst_0.delete(bst_0)

MIO/test_binarySearchTree3_MIO.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:365: in delete
    ???
binarySearchTree3:288: in contains
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98a9e230>
val = <binarySearchTree3.Bst object at 0x7f9b98a9e230>

>   ???
E   NameError: name 'root' is not defined

binarySearchTree3:269: NameError
[36m   -[0m [# 472] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  276:                 curr = curr.right
  277:     
  278:     def size(self):
  279:         '''Return the size of the BST.'''
[34m- 280:         return self._size[0m
[32m+ 280:         return _size[0m
  281:     
  282:     def depth(self):
  283:         '''Return depth of the BST, representing total levels.'''
  284:         return 0 if not (self.root) else self.root.height
--------------------------------------------------------------------------------
[0.23415 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_39

def test_case_39():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.post_order()
>       var_1 = bst_0.size()

MIO/test_binarySearchTree3_MIO.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98a03220>

>   ???
E   NameError: name '_size' is not defined

binarySearchTree3:280: NameError
[36m   -[0m [# 473] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  280:         return self._size
  281:     
  282:     def depth(self):
  283:         '''Return depth of the BST, representing total levels.'''
[34m- 284:         return 0 if not (self.root) else self.root.height[0m
[32m+ 284:         return 0 if not root else self.root.height[0m
  285:     
  286:     def contains(self, val):
  287:         '''Return true if val is in the bst.'''
  288:         return self.search(val) is not None
--------------------------------------------------------------------------------
[0.34190 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_30

def test_case_30():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_1 = bst_0.depth()

MIO/test_binarySearchTree3_MIO.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b9885e950>

>   ???
E   NameError: name 'root' is not defined

binarySearchTree3:284: NameError
[36m   -[0m [# 474] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  280:         return self._size
  281:     
  282:     def depth(self):
  283:         '''Return depth of the BST, representing total levels.'''
[34m- 284:         return 0 if not (self.root) else self.root.height[0m
[32m+ 284:         return 0 if not (self.root) else root.height[0m
  285:     
  286:     def contains(self, val):
  287:         '''Return true if val is in the bst.'''
  288:         return self.search(val) is not None
--------------------------------------------------------------------------------
[0.22567 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_30

def test_case_30():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_1 = bst_0.depth()

MIO/test_binarySearchTree3_MIO.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b987e61a0>

>   ???
E   NameError: name 'root' is not defined

binarySearchTree3:284: NameError
[36m   -[0m [# 475] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  284:         return 0 if not (self.root) else self.root.height
  285:     
  286:     def contains(self, val):
  287:         '''Return true if val is in the bst.'''
[34m- 288:         return self.search(val) is not None[0m
[32m+ 288:         return search(val) is not None[0m
  289:     
  290:     def balance(self, tree=None):
  291:         '''Return an integer of how well the tree is balanced.
  292: 
--------------------------------------------------------------------------------
[0.19886 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_1 = bst_0.delete(bst_0)

MIO/test_binarySearchTree3_MIO.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:365: in delete
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98374b20>
val = <binarySearchTree3.Bst object at 0x7f9b98374b20>

>   ???
E   NameError: name 'search' is not defined

binarySearchTree3:288: NameError
[36m   -[0m [# 476] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  295:         should return a negative value. An ideally-balanced tree should
  296:         return 0.
  297:         '''
  298:         if not tree:
[34m- 299:             tree = self.root[0m
[32m+ 299:             tree = root[0m
  300:             if not tree:
  301:                 return 0
  302:         
  303:         leftbranch = 0 if not (tree.left) else tree.left.height
--------------------------------------------------------------------------------
[0.33705 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_32

def test_case_32():
        bytes_0 = b'j\xc4u.d\x0btT\x1f\xc1"\x0c.w\x85'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_0 = bst_0.balance()

MIO/test_binarySearchTree3_MIO.py:257: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b9882a890>, tree = None

>   ???
E   NameError: name 'root' is not defined

binarySearchTree3:299: NameError
[36m   -[0m [# 477] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  307:     
  308:     def pre_order(self, node='root'):
  309:         '''Depth first pre-order traversal of tree.'''
  310:         if node == 'root':
[34m- 311:             node = self.root[0m
[32m+ 311:             node = root[0m
  312:         
  313:         if not node:
  314:             return
  315:         
--------------------------------------------------------------------------------
[0.22996 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_36

def test_case_36():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.pre_order()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98a01b10>, node = 'root'

>   ???
E   NameError: name 'root' is not defined

binarySearchTree3:311: NameError
[36m   -[0m [# 478] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  314:             return
  315:         
  316:         yield node.val
  317:         
[34m- 318:         for n in self.pre_order(node=node.left):[0m
[32m+ 318:         for n in pre_order(node=node.left):[0m
  319:             yield n
  320:         for n in self.pre_order(node=node.right):
  321:             yield n
  322:     
--------------------------------------------------------------------------------
[0.19324 s] [31msurvived[0m
[36m   -[0m [# 479] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  316:         yield node.val
  317:         
  318:         for n in self.pre_order(node=node.left):
  319:             yield n
[34m- 320:         for n in self.pre_order(node=node.right):[0m
[32m+ 320:         for n in pre_order(node=node.right):[0m
  321:             yield n
  322:     
  323:     def in_order(self, node='root'):
  324:         '''Depth first in-order traversal of tree.'''
--------------------------------------------------------------------------------
[0.18486 s] [31msurvived[0m
[36m   -[0m [# 480] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  322:     
  323:     def in_order(self, node='root'):
  324:         '''Depth first in-order traversal of tree.'''
  325:         if node == 'root':
[34m- 326:             node = self.root[0m
[32m+ 326:             node = root[0m
  327:         
  328:         if not node:
  329:             return
  330:         
--------------------------------------------------------------------------------
[0.23628 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_38

def test_case_38():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.in_order()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:306: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b987a17e0>, node = 'root'

>   ???
E   NameError: name 'root' is not defined

binarySearchTree3:326: NameError
[36m   -[0m [# 481] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  327:         
  328:         if not node:
  329:             return
  330:         
[34m- 331:         for n in self.in_order(node=node.left):[0m
[32m+ 331:         for n in in_order(node=node.left):[0m
  332:             yield n
  333:         yield node.val
  334:         for n in self.in_order(node=node.right):
  335:             yield n
--------------------------------------------------------------------------------
[0.19878 s] [31msurvived[0m
[36m   -[0m [# 482] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  330:         
  331:         for n in self.in_order(node=node.left):
  332:             yield n
  333:         yield node.val
[34m- 334:         for n in self.in_order(node=node.right):[0m
[32m+ 334:         for n in in_order(node=node.right):[0m
  335:             yield n
  336:     
  337:     def post_order(self, node='root'):
  338:         '''Depth frist post_order traversal of tree.'''
--------------------------------------------------------------------------------
[0.20052 s] [31msurvived[0m
[36m   -[0m [# 483] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  336:     
  337:     def post_order(self, node='root'):
  338:         '''Depth frist post_order traversal of tree.'''
  339:         if node == 'root':
[34m- 340:             node = self.root[0m
[32m+ 340:             node = root[0m
  341:         
  342:         if not node:
  343:             return
  344:         
--------------------------------------------------------------------------------
[0.23540 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_39

def test_case_39():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.post_order()
        var_1 = bst_0.size()
        assert var_1 == 0
        var_2 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:320: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98a13820>, node = 'root'

>   ???
E   NameError: name 'root' is not defined

binarySearchTree3:340: NameError
[36m   -[0m [# 484] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  341:         
  342:         if not node:
  343:             return
  344:         
[34m- 345:         for n in self.post_order(node=node.left):[0m
[32m+ 345:         for n in post_order(node=node.left):[0m
  346:             yield n
  347:         for n in self.post_order(node=node.right):
  348:             yield n
  349:         yield node.val
--------------------------------------------------------------------------------
[0.36118 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_39

def test_case_39():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.post_order()
        var_1 = bst_0.size()
        assert var_1 == 0
        var_2 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:320: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b987a3280>
node = <binarySearchTree3.Node object at 0x7f9b987a1420>

>   ???
E   NameError: name 'post_order' is not defined

binarySearchTree3:345: NameError
[36m   -[0m [# 485] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  343:             return
  344:         
  345:         for n in self.post_order(node=node.left):
  346:             yield n
[34m- 347:         for n in self.post_order(node=node.right):[0m
[32m+ 347:         for n in post_order(node=node.right):[0m
  348:             yield n
  349:         yield node.val
  350:     
  351:     def breadth_first(self):
--------------------------------------------------------------------------------
[0.23472 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_39

def test_case_39():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.post_order()
        var_1 = bst_0.size()
        assert var_1 == 0
        var_2 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       double_linked_list_0 = module_0.DoubleLinkedList(var_0)

MIO/test_binarySearchTree3_MIO.py:320: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98389330>
node = <binarySearchTree3.Node object at 0x7f9b9838b7c0>

>   ???
E   NameError: name 'post_order' is not defined

binarySearchTree3:347: NameError
[36m   -[0m [# 486] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  350:     
  351:     def breadth_first(self):
  352:         '''Breadth first traversal of tree.'''
  353:         q = Queue()
[34m- 354:         q.enqueue(self.root)[0m
[32m+ 354:         q.enqueue(root)[0m
  355:         while q.peek():
  356:             node = q.dequeue()
  357:             yield node.val
  358:             if node.left:
--------------------------------------------------------------------------------
[0.24064 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_41

def test_case_41():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.delete(bst_0)
        var_1 = bst_0.insert(var_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_2 = bst_0.breadth_first()
>       double_linked_list_0 = module_0.DoubleLinkedList(var_2)

MIO/test_binarySearchTree3_MIO.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree3:35: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98440280>

>   ???
E   NameError: name 'root' is not defined

binarySearchTree3:354: NameError
[36m   -[0m [# 487] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  361:                 q.enqueue(node.right)
  362:     
  363:     def delete(self, val):
  364:         '''Remove a node from the tree.'''
[34m- 365:         if (self._size < 1 or not (self.contains(val))):[0m
[32m+ 365:         if (_size < 1 or not (self.contains(val))):[0m
  366:             return
  367:         
  368:         node = self.search(val)
  369:         
--------------------------------------------------------------------------------
[0.21659 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_1 = bst_0.delete(bst_0)

MIO/test_binarySearchTree3_MIO.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98a9e6e0>
val = <binarySearchTree3.Bst object at 0x7f9b98a9e6e0>

>   ???
E   NameError: name '_size' is not defined

binarySearchTree3:365: NameError
[36m   -[0m [# 488] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  361:                 q.enqueue(node.right)
  362:     
  363:     def delete(self, val):
  364:         '''Remove a node from the tree.'''
[34m- 365:         if (self._size < 1 or not (self.contains(val))):[0m
[32m+ 365:         if (self._size < 1 or not (contains(val))):[0m
  366:             return
  367:         
  368:         node = self.search(val)
  369:         
--------------------------------------------------------------------------------
[0.21533 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_1 = bst_0.delete(bst_0)

MIO/test_binarySearchTree3_MIO.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b98aa3a30>
val = <binarySearchTree3.Bst object at 0x7f9b98aa3a30>

>   ???
E   NameError: name 'contains' is not defined

binarySearchTree3:365: NameError
[36m   -[0m [# 489] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  364:         '''Remove a node from the tree.'''
  365:         if (self._size < 1 or not (self.contains(val))):
  366:             return
  367:         
[34m- 368:         node = self.search(val)[0m
[32m+ 368:         node = search(val)[0m
  369:         
  370:         if node._is_leaf():
  371:             if node.parent:
  372:                 setattr(node.parent, node._side(), None)
--------------------------------------------------------------------------------
[0.33928 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
>       var_1 = bst_0.delete(bst_0)

MIO/test_binarySearchTree3_MIO.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.Bst object at 0x7f9b988e2020>
val = <binarySearchTree3.Bst object at 0x7f9b988e2020>

>   ???
E   NameError: name 'search' is not defined

binarySearchTree3:368: NameError
[36m   -[0m [# 490] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  370:         if node._is_leaf():
  371:             if node.parent:
  372:                 setattr(node.parent, node._side(), None)
  373:             else:
[34m- 374:                 self.root = None[0m
[32m+ 374:                 root = None[0m
  375:         
  376:         elif node._is_interior():
  377:             next_node = self._find_replacement(node)
  378:             self._size += 1
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 491] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  373:             else:
  374:                 self.root = None
  375:         
  376:         elif node._is_interior():
[34m- 377:             next_node = self._find_replacement(node)[0m
[32m+ 377:             next_node = _find_replacement(node)[0m
  378:             self._size += 1
  379:             self.delete(next_node.val)
  380:             node.val = next_node.val
  381:         else:
--------------------------------------------------------------------------------
[0.20005 s] [31msurvived[0m
[36m   -[0m [# 492] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  374:                 self.root = None
  375:         
  376:         elif node._is_interior():
  377:             next_node = self._find_replacement(node)
[34m- 378:             self._size += 1[0m
[32m+ 378:             _size += 1[0m
  379:             self.delete(next_node.val)
  380:             node.val = next_node.val
  381:         else:
  382:             
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 493] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  375:         
  376:         elif node._is_interior():
  377:             next_node = self._find_replacement(node)
  378:             self._size += 1
[34m- 379:             self.delete(next_node.val)[0m
[32m+ 379:             delete(next_node.val)[0m
  380:             node.val = next_node.val
  381:         else:
  382:             
  383:             child = getattr(node, node._onlychild())
--------------------------------------------------------------------------------
[0.20018 s] [31msurvived[0m
[36m   -[0m [# 494] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  384:             if node.parent:
  385:                 child.parent = node.parent
  386:                 setattr(node.parent, node._side(), child)
  387:             else:
[34m- 388:                 self.root = child[0m
[32m+ 388:                 root = child[0m
  389:         
  390:         self._size -= 1
  391:     
  392:     def _find_replacement(self, node):
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 495] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  386:                 setattr(node.parent, node._side(), child)
  387:             else:
  388:                 self.root = child
  389:         
[34m- 390:         self._size -= 1[0m
[32m+ 390:         _size -= 1[0m
  391:     
  392:     def _find_replacement(self, node):
  393:         '''Find left most node of right subtree.'''
  394:         if node.right:
--------------------------------------------------------------------------------
[0.00000 s] [36mincompetent[0m

ValueError: expression must have Store context but has Load instead

[36m   -[0m [# 496] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  391:     
  392:     def _find_replacement(self, node):
  393:         '''Find left most node of right subtree.'''
  394:         if node.right:
[34m- 395:             return self._findmin(node.right)[0m
[32m+ 395:             return _findmin(node.right)[0m
  396:         
  397:         elif node.parent:
  398:             if node._side() == 'left':
  399:                 return self.parent
--------------------------------------------------------------------------------
[0.20180 s] [31msurvived[0m
[36m   -[0m [# 497] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  395:             return self._findmin(node.right)
  396:         
  397:         elif node.parent:
  398:             if node._side() == 'left':
[34m- 399:                 return self.parent[0m
[32m+ 399:                 return parent[0m
  400:             else:
  401:                 node.parent.right = None
  402:                 tmp = self._find_replacement(node.parent)
  403:                 node.parent.right = node
--------------------------------------------------------------------------------
[0.20050 s] [31msurvived[0m
[36m   -[0m [# 498] SVD binarySearchTree3: 
--------------------------------------------------------------------------------
  398:             if node._side() == 'left':
  399:                 return self.parent
  400:             else:
  401:                 node.parent.right = None
[34m- 402:                 tmp = self._find_replacement(node.parent)[0m
[32m+ 402:                 tmp = _find_replacement(node.parent)[0m
  403:                 node.parent.right = node
  404:                 return tmp
  405:     
  406:     def _findmin(self, node):
--------------------------------------------------------------------------------
[0.19901 s] [31msurvived[0m
[36m   -[0m [# 499] ZIL binarySearchTree3: 
--------------------------------------------------------------------------------
   32:         self.tail = None
   33:         self._length = 0
   34:         try:
   35:             for val in data:
[34m-  36:                 self.push(val)[0m
[32m+  36:                 break[0m
   37:         except TypeError:
   38:             if data:
   39:                 self.push(data)
   40:     
--------------------------------------------------------------------------------
[0.19407 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_0

def test_case_0():
        bytes_0 = b'E\x9c\xce\xc8G'
        double_linked_list_0 = module_0.DoubleLinkedList(bytes_0)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
>       assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:9: AssertionError
[36m   -[0m [# 500] ZIL binarySearchTree3: 
--------------------------------------------------------------------------------
   91:     def remove(self, val):
   92:         '''Remove first occurance of val from list.'''
   93:         curr = self.head
   94:         while curr:
[34m-  95:             if curr.data is val:[0m
[34m-  96:                 if self._length == 1:[0m
[34m-  97:                     (self.head, self.tail) = (None, None)[0m
[34m-  98:                 elif (curr is not self.head and curr is not self.tail):[0m
[34m-  99:                     (curr.next.prev, curr.prev.next) = (curr.prev, curr.next)[0m
[34m- 100:                 elif curr is self.head:[0m
[34m- 101:                     (self.head, curr.next.prev) = (curr.next, None)[0m
[34m- 102:                 elif curr is self.tail:[0m
[34m- 103:                     (self.tail, curr.prev.next) = (curr.prev, None)[0m
[34m- 104:                 self._length -= 1[0m
[34m- 105:                 return[0m
[34m- 106:             curr = curr.next[0m
[32m+  95:             break[0m
[32m+  96:         [0m
[32m+  97:         [0m
[32m+  98:         [0m
[32m+  99:         [0m
[32m+ 100:         [0m
[32m+ 101:         [0m
[32m+ 102:         [0m
[32m+ 103:         [0m
[32m+ 104:         [0m
[32m+ 105:         [0m
[32m+ 106:         [0m
  107:         
  108:         raise ValueError('{} is not in the list'.format(val))
  109:     
  110:     def _repr(self):
--------------------------------------------------------------------------------
[0.34046 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_12

def test_case_12():
        double_linked_list_0 = module_0.DoubleLinkedList()
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
        assert double_linked_list_0.head is None
        assert double_linked_list_0.tail is None
        var_0 = double_linked_list_0.append(double_linked_list_0)
        assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
>       var_1 = double_linked_list_0.remove(double_linked_list_0)

MIO/test_binarySearchTree3_MIO.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98750d60>
val = <binarySearchTree3.DoubleLinkedList object at 0x7f9b98750d60>

>   ???
E   ValueError: <binarySearchTree3.DoubleLinkedList object at 0x7f9b98750d60> is not in the list

binarySearchTree3:108: ValueError
[36m   -[0m [# 501] ZIL binarySearchTree3: 
--------------------------------------------------------------------------------
  110:     def _repr(self):
  111:         '''Return list representation of dll.'''
  112:         l = []
  113:         while True:
[34m- 114:             try:[0m
[34m- 115:                 popped_data = self.pop()[0m
[34m- 116:                 l.append(popped_data)[0m
[34m- 117:             except IndexError:[0m
[34m- 118:                 break[0m
[32m+ 114:             break[0m
[32m+ 115:         [0m
[32m+ 116:         [0m
[32m+ 117:         [0m
[32m+ 118:         [0m
  119:         return l
  120: 
  121: class Queue(object):
  122:     '''Implementation of Queue.
--------------------------------------------------------------------------------
[0.19745 s] [31msurvived[0m
[36m   -[0m [# 502] ZIL binarySearchTree3: 
--------------------------------------------------------------------------------
  231:         self.root = None
  232:         
  233:         if data:
  234:             for i in data:
[34m- 235:                 self.insert(i)[0m
[32m+ 235:                 break[0m
  236:     
  237:     def insert(self, val):
  238:         '''Insert val into BST. If val is already present will be ignored.'''
  239:         if not (self.root):
--------------------------------------------------------------------------------
[0.21983 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_21

def test_case_21():
        bytes_0 = b'z\xc7'
        bst_0 = module_0.Bst(bytes_0)
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
>       assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:185: AssertionError
[36m   -[0m [# 503] ZIL binarySearchTree3: 
--------------------------------------------------------------------------------
  267:     def search(self, val):
  268:         '''Return the node containing val.'''
  269:         curr = self.root
  270:         while curr:
[34m- 271:             if curr.val == val:[0m
[34m- 272:                 return curr[0m
[34m- 273:             elif val < curr.val:[0m
[34m- 274:                 curr = curr.left[0m
[34m- 275:             else:[0m
[34m- 276:                 curr = curr.right[0m
[32m+ 271:             break[0m
[32m+ 272:     [0m
[32m+ 273:     [0m
[32m+ 274:     [0m
[32m+ 275:     [0m
[32m+ 276:     [0m
  277:     
  278:     def size(self):
  279:         '''Return the size of the BST.'''
  280:         return self._size
--------------------------------------------------------------------------------
[0.20814 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_20

def test_case_20():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.insert(bst_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_1 = bst_0.delete(bst_0)
>       assert bst_0.root is None
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:179: AssertionError
[36m   -[0m [# 504] ZIL binarySearchTree3: 
--------------------------------------------------------------------------------
  315:         
  316:         yield node.val
  317:         
  318:         for n in self.pre_order(node=node.left):
[34m- 319:             yield n[0m
[32m+ 319:             break[0m
  320:         for n in self.pre_order(node=node.right):
  321:             yield n
  322:     
  323:     def in_order(self, node='root'):
--------------------------------------------------------------------------------
[0.19990 s] [31msurvived[0m
[36m   -[0m [# 505] ZIL binarySearchTree3: 
--------------------------------------------------------------------------------
  317:         
  318:         for n in self.pre_order(node=node.left):
  319:             yield n
  320:         for n in self.pre_order(node=node.right):
[34m- 321:             yield n[0m
[32m+ 321:             break[0m
  322:     
  323:     def in_order(self, node='root'):
  324:         '''Depth first in-order traversal of tree.'''
  325:         if node == 'root':
--------------------------------------------------------------------------------
[0.20125 s] [31msurvived[0m
[36m   -[0m [# 506] ZIL binarySearchTree3: 
--------------------------------------------------------------------------------
  328:         if not node:
  329:             return
  330:         
  331:         for n in self.in_order(node=node.left):
[34m- 332:             yield n[0m
[32m+ 332:             break[0m
  333:         yield node.val
  334:         for n in self.in_order(node=node.right):
  335:             yield n
  336:     
--------------------------------------------------------------------------------
[0.18783 s] [31msurvived[0m
[36m   -[0m [# 507] ZIL binarySearchTree3: 
--------------------------------------------------------------------------------
  331:         for n in self.in_order(node=node.left):
  332:             yield n
  333:         yield node.val
  334:         for n in self.in_order(node=node.right):
[34m- 335:             yield n[0m
[32m+ 335:             break[0m
  336:     
  337:     def post_order(self, node='root'):
  338:         '''Depth frist post_order traversal of tree.'''
  339:         if node == 'root':
--------------------------------------------------------------------------------
[0.19925 s] [31msurvived[0m
[36m   -[0m [# 508] ZIL binarySearchTree3: 
--------------------------------------------------------------------------------
  342:         if not node:
  343:             return
  344:         
  345:         for n in self.post_order(node=node.left):
[34m- 346:             yield n[0m
[32m+ 346:             break[0m
  347:         for n in self.post_order(node=node.right):
  348:             yield n
  349:         yield node.val
  350:     
--------------------------------------------------------------------------------
[0.33325 s] [31msurvived[0m
[36m   -[0m [# 509] ZIL binarySearchTree3: 
--------------------------------------------------------------------------------
  344:         
  345:         for n in self.post_order(node=node.left):
  346:             yield n
  347:         for n in self.post_order(node=node.right):
[34m- 348:             yield n[0m
[32m+ 348:             break[0m
  349:         yield node.val
  350:     
  351:     def breadth_first(self):
  352:         '''Breadth first traversal of tree.'''
--------------------------------------------------------------------------------
[0.19854 s] [31msurvived[0m
[36m   -[0m [# 510] ZIL binarySearchTree3: 
--------------------------------------------------------------------------------
  352:         '''Breadth first traversal of tree.'''
  353:         q = Queue()
  354:         q.enqueue(self.root)
  355:         while q.peek():
[34m- 356:             node = q.dequeue()[0m
[34m- 357:             yield node.val[0m
[34m- 358:             if node.left:[0m
[34m- 359:                 q.enqueue(node.left)[0m
[34m- 360:             if node.right:[0m
[34m- 361:                 q.enqueue(node.right)[0m
[32m+ 356:             break[0m
[32m+ 357:     [0m
[32m+ 358:     [0m
[32m+ 359:     [0m
[32m+ 360:     [0m
[32m+ 361:     [0m
  362:     
  363:     def delete(self, val):
  364:         '''Remove a node from the tree.'''
  365:         if (self._size < 1 or not (self.contains(val))):
--------------------------------------------------------------------------------
[0.23652 s] [32mkilled[0m by MIO/test_binarySearchTree3_MIO.py::test_case_41

def test_case_41():
        bst_0 = module_0.Bst()
        assert f'{type(bst_0).__module__}.{type(bst_0).__qualname__}' == 'binarySearchTree3.Bst'
        assert bst_0.root is None
        var_0 = bst_0.delete(bst_0)
        var_1 = bst_0.insert(var_0)
        assert f'{type(bst_0.root).__module__}.{type(bst_0.root).__qualname__}' == 'binarySearchTree3.Node'
        var_2 = bst_0.breadth_first()
        double_linked_list_0 = module_0.DoubleLinkedList(var_2)
        assert f'{type(double_linked_list_0).__module__}.{type(double_linked_list_0).__qualname__}' == 'binarySearchTree3.DoubleLinkedList'
>       assert f'{type(double_linked_list_0.head).__module__}.{type(double_linked_list_0.head).__qualname__}' == 'binarySearchTree3.NodeDLL'
E       AssertionError

MIO/test_binarySearchTree3_MIO.py:345: AssertionError
[36m   -[0m [# 511] ZIL binarySearchTree3: 
--------------------------------------------------------------------------------
  405:     
  406:     def _findmin(self, node):
  407:         '''Find min of subtree, Min is always left most node.'''
  408:         while node.left:
[34m- 409:             node = node.left[0m
[32m+ 409:             break[0m
  410:         return node
--------------------------------------------------------------------------------
[0.20087 s] [31msurvived[0m
[34m[*][0m Mutation score [336.44846 s]: [1m[34m59.9%[0m
[36m   -[0m all: 511
[36m   -[0m killed: 256 (50.1%)
[36m   -[0m survived: 174 (34.1%)
[36m   -[0m incompetent: 77 (15.1%)
[36m   -[0m timeout: 4 (0.8%)
