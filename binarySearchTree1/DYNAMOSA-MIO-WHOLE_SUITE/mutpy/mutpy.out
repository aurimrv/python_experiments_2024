[*] Start mutation process:
   - targets: binarySearchTree1.py
   - tests: ./DYNAMOSA-MIO-WHOLE_SUITE
[*] 84 tests passed:
   - test_binarySearchTree1_MIO [0.08797 s]
   - test_binarySearchTree1_DYNAMOSA [0.05631 s]
   - test_binarySearchTree1_WHOLE_SUITE [0.09579 s]
[*] Start mutants generation and execution:
   - [#   1] AOR binarySearchTree1: 
--------------------------------------------------------------------------------
   64:         if self.left:
   65:             leftS = str(self.left)
   66:         if self.right:
   67:             rightS = str(self.right)
-  68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
+  68:         return ((((('(L:' - leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
   69:     
   70:     def inorder(self):
   71:         '''In order traversal generator of tree rooted at given node.'''
   72:         if self.left:
--------------------------------------------------------------------------------
[0.08953 s] incompetent

TypeError: binarySearchTree1:68: TypeError: unsupported operand type(s) for -: 'str' and 'str'

   - [#   2] AOR binarySearchTree1: 
--------------------------------------------------------------------------------
   64:         if self.left:
   65:             leftS = str(self.left)
   66:         if self.right:
   67:             rightS = str(self.right)
-  68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
+  68:         return ((((('(L:' + leftS) - ' ') + str(self.value)) + ' R:') + rightS) + ')'
   69:     
   70:     def inorder(self):
   71:         '''In order traversal generator of tree rooted at given node.'''
   72:         if self.left:
--------------------------------------------------------------------------------
[0.09913 s] incompetent

TypeError: binarySearchTree1:68: TypeError: unsupported operand type(s) for -: 'str' and 'str'

   - [#   3] AOR binarySearchTree1: 
--------------------------------------------------------------------------------
   64:         if self.left:
   65:             leftS = str(self.left)
   66:         if self.right:
   67:             rightS = str(self.right)
-  68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
+  68:         return ((((('(L:' + leftS) + ' ') - str(self.value)) + ' R:') + rightS) + ')'
   69:     
   70:     def inorder(self):
   71:         '''In order traversal generator of tree rooted at given node.'''
   72:         if self.left:
--------------------------------------------------------------------------------
[0.08967 s] incompetent

TypeError: binarySearchTree1:68: TypeError: unsupported operand type(s) for -: 'str' and 'str'

   - [#   4] AOR binarySearchTree1: 
--------------------------------------------------------------------------------
   64:         if self.left:
   65:             leftS = str(self.left)
   66:         if self.right:
   67:             rightS = str(self.right)
-  68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
+  68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) - ' R:') + rightS) + ')'
   69:     
   70:     def inorder(self):
   71:         '''In order traversal generator of tree rooted at given node.'''
   72:         if self.left:
--------------------------------------------------------------------------------
[0.09069 s] incompetent

TypeError: binarySearchTree1:68: TypeError: unsupported operand type(s) for -: 'str' and 'str'

   - [#   5] AOR binarySearchTree1: 
--------------------------------------------------------------------------------
   64:         if self.left:
   65:             leftS = str(self.left)
   66:         if self.right:
   67:             rightS = str(self.right)
-  68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
+  68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') - rightS) + ')'
   69:     
   70:     def inorder(self):
   71:         '''In order traversal generator of tree rooted at given node.'''
   72:         if self.left:
--------------------------------------------------------------------------------
[0.08801 s] incompetent

TypeError: binarySearchTree1:68: TypeError: unsupported operand type(s) for -: 'str' and 'str'

   - [#   6] AOR binarySearchTree1: 
--------------------------------------------------------------------------------
   64:         if self.left:
   65:             leftS = str(self.left)
   66:         if self.right:
   67:             rightS = str(self.right)
-  68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
+  68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) - ')'
   69:     
   70:     def inorder(self):
   71:         '''In order traversal generator of tree rooted at given node.'''
   72:         if self.left:
--------------------------------------------------------------------------------
[0.09206 s] incompetent

TypeError: binarySearchTree1:68: TypeError: unsupported operand type(s) for -: 'str' and 'str'

   - [#   7] AOR binarySearchTree1: 
--------------------------------------------------------------------------------
  136:         if self.root is None:
  137:             return None
  138:         
  139:         best = node = self.root
- 140:         distance = abs(self.root.value - target)
+ 140:         distance = abs(self.root.value + target)
  141:         while node:
  142:             if abs(node.value - target) < distance:
  143:                 distance = abs(node.value - target)
  144:                 best = node
--------------------------------------------------------------------------------
[0.10816 s] survived
   - [#   8] AOR binarySearchTree1: 
--------------------------------------------------------------------------------
  138:         
  139:         best = node = self.root
  140:         distance = abs(self.root.value - target)
  141:         while node:
- 142:             if abs(node.value - target) < distance:
+ 142:             if abs(node.value + target) < distance:
  143:                 distance = abs(node.value - target)
  144:                 best = node
  145:             if target < node.value:
  146:                 node = node.left
--------------------------------------------------------------------------------
[0.12619 s] survived
   - [#   9] AOR binarySearchTree1: 
--------------------------------------------------------------------------------
  139:         best = node = self.root
  140:         distance = abs(self.root.value - target)
  141:         while node:
  142:             if abs(node.value - target) < distance:
- 143:                 distance = abs(node.value - target)
+ 143:                 distance = abs(node.value + target)
  144:                 best = node
  145:             if target < node.value:
  146:                 node = node.left
  147:             elif target > node.value:
--------------------------------------------------------------------------------
[0.11456 s] survived
   - [#  10] AOR binarySearchTree1: 
--------------------------------------------------------------------------------
  159:     
  160:     def __repr__(self):
  161:         if self.root is None:
  162:             return 'binary:()'
- 163:         return 'binary:' + str(self.root)
+ 163:         return 'binary:' - str(self.root)
  164: 
  165: '''
  166: Change Log:
  167: -----------
--------------------------------------------------------------------------------
[0.12536 s] incompetent

TypeError: binarySearchTree1:163: TypeError: unsupported operand type(s) for -: 'str' and 'str'

   - [#  11] CDI binarySearchTree1: 
--------------------------------------------------------------------------------
    4:     Author: George Heineman    
    5: '''
    6: class BinaryNode:
    7:     
-   8:     def __init__(self, value):
-   9:         '''Create binary node.'''
-  10:         self.value = value
-  11:         self.left = None
-  12:         self.right = None
-  13:     
+   8:     @classmethod
+   9:     def __init__(self, value):
+  10:         '''Create binary node.'''
+  11:         self.value = value
+  12:         self.left = None
+  13:         self.right = None
   14:     def add(self, val):
   15:         '''
   16:         Add a new node to the tree with value. Respond based on Set semantics
   17:         '''
--------------------------------------------------------------------------------
[0.10478 s] incompetent

TypeError: binarySearchTree1:122: TypeError: '<' not supported between instances of 'list' and 'NoneType'

   - [#  12] CDI binarySearchTree1: 
--------------------------------------------------------------------------------
   10:         self.value = value
   11:         self.left = None
   12:         self.right = None
   13:     
-  14:     def add(self, val):
-  15:         '''
-  16:         Add a new node to the tree with value. Respond based on Set semantics
-  17:         '''
-  18:         if val <= self.value:
-  19:             self.left = self.addToSubTree(self.left, val)
-  20:         elif val > self.value:
-  21:             self.right = self.addToSubTree(self.right, val)
-  22:     
+  14:     @classmethod
+  15:     def add(self, val):
+  16:         '''
+  17:         Add a new node to the tree with value. Respond based on Set semantics
+  18:         '''
+  19:         if val <= self.value:
+  20:             self.left = self.addToSubTree(self.left, val)
+  21:         elif val > self.value:
+  22:             self.right = self.addToSubTree(self.right, val)
   23:     def addToSubTree(self, parent, val):
   24:         '''Add val to parent subtree (if exists) and return root of that subtree.'''
   25:         if parent is None:
   26:             return BinaryNode(val)
--------------------------------------------------------------------------------
[0.09224 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_0

def test_case_0():
        bool_0 = True
        bool_1 = False
        binary_node_0 = module_0.BinaryNode(bool_1)
>       var_0 = binary_node_0.add(bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:10: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree1.BinaryNode'>, val = True

>   ???
E   AttributeError: type object 'BinaryNode' has no attribute 'value'

binarySearchTree1:19: AttributeError
   - [#  13] CDI binarySearchTree1: 
--------------------------------------------------------------------------------
   19:             self.left = self.addToSubTree(self.left, val)
   20:         elif val > self.value:
   21:             self.right = self.addToSubTree(self.right, val)
   22:     
-  23:     def addToSubTree(self, parent, val):
-  24:         '''Add val to parent subtree (if exists) and return root of that subtree.'''
-  25:         if parent is None:
-  26:             return BinaryNode(val)
-  27:         
-  28:         parent.add(val)
-  29:         return parent
-  30:     
+  23:     @classmethod
+  24:     def addToSubTree(self, parent, val):
+  25:         '''Add val to parent subtree (if exists) and return root of that subtree.'''
+  26:         if parent is None:
+  27:             return BinaryNode(val)
+  28:         
+  29:         parent.add(val)
+  30:         return parent
   31:     def remove(self, val):
   32:         '''
   33:          Remove val of self from BinaryTree. 
   34:         '''
--------------------------------------------------------------------------------
[0.14379 s] survived
   - [#  14] CDI binarySearchTree1: 
--------------------------------------------------------------------------------
   27:         
   28:         parent.add(val)
   29:         return parent
   30:     
-  31:     def remove(self, val):
-  32:         '''
-  33:          Remove val of self from BinaryTree. 
-  34:         '''
-  35:         if val < self.value:
-  36:             self.left = self.removeFromParent(self.left, val)
-  37:         elif val > self.value:
-  38:             self.right = self.removeFromParent(self.right, val)
-  39:         else:
-  40:             if self.left is None:
-  41:                 return self.right
-  42:             
-  43:             child = self.left
-  44:             while child.right:
-  45:                 child = child.right
-  46:             
-  47:             childKey = child.value
-  48:             self.left = self.removeFromParent(self.left, childKey)
-  49:             self.value = childKey
-  50:         
-  51:         return self
-  52:     
+  31:     @classmethod
+  32:     def remove(self, val):
+  33:         '''
+  34:          Remove val of self from BinaryTree. 
+  35:         '''
+  36:         if val < self.value:
+  37:             self.left = self.removeFromParent(self.left, val)
+  38:         elif val > self.value:
+  39:             self.right = self.removeFromParent(self.right, val)
+  40:         else:
+  41:             if self.left is None:
+  42:                 return self.right
+  43:             
+  44:             child = self.left
+  45:             while child.right:
+  46:                 child = child.right
+  47:             
+  48:             childKey = child.value
+  49:             self.left = self.removeFromParent(self.left, childKey)
+  50:             self.value = childKey
+  51:         
+  52:         return self
   53:     def removeFromParent(self, parent, val):
   54:         '''Helper method for remove. Ensures proper behavior when removing node that 
   55:         has children.'''
   56:         if parent:
--------------------------------------------------------------------------------
[0.09459 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_2

def test_case_2():
        bool_0 = True
        bool_1 = False
        binary_node_0 = module_0.BinaryNode(bool_1)
>       var_0 = binary_node_0.remove(bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree1.BinaryNode'>, val = True

>   ???
E   AttributeError: type object 'BinaryNode' has no attribute 'value'

binarySearchTree1:36: AttributeError
   - [#  15] CDI binarySearchTree1: 
--------------------------------------------------------------------------------
   49:             self.value = childKey
   50:         
   51:         return self
   52:     
-  53:     def removeFromParent(self, parent, val):
-  54:         '''Helper method for remove. Ensures proper behavior when removing node that 
-  55:         has children.'''
-  56:         if parent:
-  57:             return parent.remove(val)
-  58:         return None
-  59:     
+  53:     @classmethod
+  54:     def removeFromParent(self, parent, val):
+  55:         '''Helper method for remove. Ensures proper behavior when removing node that 
+  56:         has children.'''
+  57:         if parent:
+  58:             return parent.remove(val)
+  59:         return None
   60:     def __repr__(self):
   61:         '''Useful debugging function to produce linear tree representation.'''
   62:         leftS = ''
   63:         rightS = ''
--------------------------------------------------------------------------------
[0.12446 s] survived
   - [#  16] CDI binarySearchTree1: 
--------------------------------------------------------------------------------
   56:         if parent:
   57:             return parent.remove(val)
   58:         return None
   59:     
-  60:     def __repr__(self):
-  61:         '''Useful debugging function to produce linear tree representation.'''
-  62:         leftS = ''
-  63:         rightS = ''
-  64:         if self.left:
-  65:             leftS = str(self.left)
-  66:         if self.right:
-  67:             rightS = str(self.right)
-  68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
-  69:     
+  60:     @classmethod
+  61:     def __repr__(self):
+  62:         '''Useful debugging function to produce linear tree representation.'''
+  63:         leftS = ''
+  64:         rightS = ''
+  65:         if self.left:
+  66:             leftS = str(self.left)
+  67:         if self.right:
+  68:             rightS = str(self.right)
+  69:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
   70:     def inorder(self):
   71:         '''In order traversal generator of tree rooted at given node.'''
   72:         if self.left:
   73:             for v in self.left.inorder():
--------------------------------------------------------------------------------
[0.09109 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_7

def test_case_7():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_node_0.removeFromParent(binary_node_0, bool_0)
        assert binary_node_0.left is None
        assert var_0.left is None
        assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_1.value is False
        assert var_1.left is None
        assert var_1.right is None
        bool_1 = True
        binary_tree_0 = module_0.BinaryTree()
        var_2 = var_0.addToSubTree(var_0, bool_1)
        assert f'{type(binary_node_0.right).__module__}.{type(binary_node_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.right).__module__}.{type(var_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_1.right).__module__}.{type(var_1.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_2.value is False
        assert var_2.left is None
        assert f'{type(var_2.right).__module__}.{type(var_2.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_3 = var_0.__repr__()

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree1.BinaryNode'>

>   ???
E   AttributeError: type object 'BinaryNode' has no attribute 'left'

binarySearchTree1:65: AttributeError
   - [#  17] CDI binarySearchTree1: 
--------------------------------------------------------------------------------
   66:         if self.right:
   67:             rightS = str(self.right)
   68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
   69:     
-  70:     def inorder(self):
-  71:         '''In order traversal generator of tree rooted at given node.'''
-  72:         if self.left:
-  73:             for v in self.left.inorder():
-  74:                 yield v
-  75:         
-  76:         yield self.value
-  77:         
-  78:         if self.right:
-  79:             for v in self.right.inorder():
-  80:                 yield v
-  81: 
+  70:     @classmethod
+  71:     def inorder(self):
+  72:         '''In order traversal generator of tree rooted at given node.'''
+  73:         if self.left:
+  74:             for v in self.left.inorder():
+  75:                 yield v
+  76:         
+  77:         yield self.value
+  78:         
+  79:         if self.right:
+  80:             for v in self.right.inorder():
+  81:                 yield v
   82: class BinaryTree:
   83:     
   84:     def __init__(self):
   85:         '''Create empty binary tree.'''
--------------------------------------------------------------------------------
[0.10984 s] survived
   - [#  18] CDI binarySearchTree1: 
--------------------------------------------------------------------------------
   80:                 yield v
   81: 
   82: class BinaryTree:
   83:     
-  84:     def __init__(self):
-  85:         '''Create empty binary tree.'''
-  86:         self.root = None
-  87:     
+  84:     @classmethod
+  85:     def __init__(self):
+  86:         '''Create empty binary tree.'''
+  87:         self.root = None
   88:     def add(self, value):
   89:         '''Insert value into proper location in Binary Tree.'''
   90:         if self.root is None:
   91:             self.root = BinaryNode(value)
--------------------------------------------------------------------------------
[0.11001 s] survived
   - [#  19] CDI binarySearchTree1: 
--------------------------------------------------------------------------------
   84:     def __init__(self):
   85:         '''Create empty binary tree.'''
   86:         self.root = None
   87:     
-  88:     def add(self, value):
-  89:         '''Insert value into proper location in Binary Tree.'''
-  90:         if self.root is None:
-  91:             self.root = BinaryNode(value)
-  92:         else:
-  93:             self.root.add(value)
-  94:     
+  88:     @classmethod
+  89:     def add(self, value):
+  90:         '''Insert value into proper location in Binary Tree.'''
+  91:         if self.root is None:
+  92:             self.root = BinaryNode(value)
+  93:         else:
+  94:             self.root.add(value)
   95:     def remove(self, val):
   96:         '''Remove value from tree.'''
   97:         if self.root:
   98:             self.root = self.root.remove(val)
--------------------------------------------------------------------------------
[0.11639 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_10

def test_case_10():
        binary_tree_0 = module_0.BinaryTree()
>       var_0 = binary_tree_0.add(binary_tree_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:110: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree1.BinaryTree'>, value = binary:()

>   ???
E   AttributeError: type object 'BinaryTree' has no attribute 'root'

binarySearchTree1:91: AttributeError
   - [#  20] CDI binarySearchTree1: 
--------------------------------------------------------------------------------
   91:             self.root = BinaryNode(value)
   92:         else:
   93:             self.root.add(value)
   94:     
-  95:     def remove(self, val):
-  96:         '''Remove value from tree.'''
-  97:         if self.root:
-  98:             self.root = self.root.remove(val)
-  99:     
+  95:     @classmethod
+  96:     def remove(self, val):
+  97:         '''Remove value from tree.'''
+  98:         if self.root:
+  99:             self.root = self.root.remove(val)
  100:     def getMin(self):
  101:         '''Returns minimum value.'''
  102:         if self.root is None:
  103:             raise ValueError('Binary Tree is empty')
--------------------------------------------------------------------------------
[0.12842 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_14

def test_case_14():
        binary_tree_0 = module_0.BinaryTree()
>       var_0 = binary_tree_0.remove(binary_tree_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree1.BinaryTree'>, val = binary:()

>   ???
E   AttributeError: type object 'BinaryTree' has no attribute 'root'

binarySearchTree1:98: AttributeError
   - [#  21] CDI binarySearchTree1: 
--------------------------------------------------------------------------------
   96:         '''Remove value from tree.'''
   97:         if self.root:
   98:             self.root = self.root.remove(val)
   99:     
- 100:     def getMin(self):
- 101:         '''Returns minimum value.'''
- 102:         if self.root is None:
- 103:             raise ValueError('Binary Tree is empty')
- 104:         n = self.root
- 105:         while n.left != None:
- 106:             n = n.left
- 107:         return n.value
- 108:     
+ 100:     @classmethod
+ 101:     def getMin(self):
+ 102:         '''Returns minimum value.'''
+ 103:         if self.root is None:
+ 104:             raise ValueError('Binary Tree is empty')
+ 105:         n = self.root
+ 106:         while n.left != None:
+ 107:             n = n.left
+ 108:         return n.value
  109:     def getMax(self):
  110:         '''Returns maximum value.'''
  111:         if self.root is None:
  112:             raise ValueError('Binary Tree is empty')
--------------------------------------------------------------------------------
[0.09568 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_15

def test_case_15():
        binary_tree_0 = module_0.BinaryTree()
        binary_tree_1 = module_0.BinaryTree()
        var_0 = binary_tree_0.__repr__()
        assert var_0 == 'binary:()'
        var_1 = binary_tree_0.add(var_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_2 = binary_tree_0.add(var_0)
        var_3 = binary_tree_0.__iter__()
        var_4 = var_3.__repr__()
>       var_5 = binary_tree_0.getMin()

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree1.BinaryTree'>

>   ???
E   AttributeError: type object 'BinaryTree' has no attribute 'root'

binarySearchTree1:103: AttributeError
   - [#  22] CDI binarySearchTree1: 
--------------------------------------------------------------------------------
  105:         while n.left != None:
  106:             n = n.left
  107:         return n.value
  108:     
- 109:     def getMax(self):
- 110:         '''Returns maximum value.'''
- 111:         if self.root is None:
- 112:             raise ValueError('Binary Tree is empty')
- 113:         n = self.root
- 114:         while n.right != None:
- 115:             n = n.right
- 116:         return n.value
- 117:     
+ 109:     @classmethod
+ 110:     def getMax(self):
+ 111:         '''Returns maximum value.'''
+ 112:         if self.root is None:
+ 113:             raise ValueError('Binary Tree is empty')
+ 114:         n = self.root
+ 115:         while n.right != None:
+ 116:             n = n.right
+ 117:         return n.value
  118:     def __contains__(self, target):
  119:         '''Check whether BST contains target value.'''
  120:         node = self.root
  121:         while node:
--------------------------------------------------------------------------------
[0.09930 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_18

def test_case_18():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.add(binary_tree_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_1 = binary_tree_0.getMax()

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree1.BinaryTree'>

>   ???
E   AttributeError: type object 'BinaryTree' has no attribute 'root'

binarySearchTree1:112: AttributeError
   - [#  23] CDI binarySearchTree1: 
--------------------------------------------------------------------------------
  114:         while n.right != None:
  115:             n = n.right
  116:         return n.value
  117:     
- 118:     def __contains__(self, target):
- 119:         '''Check whether BST contains target value.'''
- 120:         node = self.root
- 121:         while node:
- 122:             if target < node.value:
- 123:                 node = node.left
- 124:             elif target > node.value:
- 125:                 node = node.right
- 126:             else:
- 127:                 return True
- 128:         
- 129:         return False
- 130:     
+ 118:     @classmethod
+ 119:     def __contains__(self, target):
+ 120:         '''Check whether BST contains target value.'''
+ 121:         node = self.root
+ 122:         while node:
+ 123:             if target < node.value:
+ 124:                 node = node.left
+ 125:             elif target > node.value:
+ 126:                 node = node.right
+ 127:             else:
+ 128:                 return True
+ 129:         
+ 130:         return False
  131:     def closest(self, target):
  132:         '''
  133:         Return value closest to target. If there are several, then
  134:         return one of them.
--------------------------------------------------------------------------------
[0.09987 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_20

def test_case_20():
        binary_tree_0 = module_0.BinaryTree()
        set_0 = {binary_tree_0}
        var_0 = binary_tree_0.add(set_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_1 = binary_tree_0.__contains__(set_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree1.BinaryTree'>
target = {binary:(L: {binary:(L: set(...) R:)} R:)}

>   ???
E   AttributeError: type object 'BinaryTree' has no attribute 'root'

binarySearchTree1:121: AttributeError
   - [#  24] CDI binarySearchTree1: 
--------------------------------------------------------------------------------
  127:                 return True
  128:         
  129:         return False
  130:     
- 131:     def closest(self, target):
- 132:         '''
- 133:         Return value closest to target. If there are several, then
- 134:         return one of them.
- 135:         '''
- 136:         if self.root is None:
- 137:             return None
- 138:         
- 139:         best = node = self.root
- 140:         distance = abs(self.root.value - target)
- 141:         while node:
- 142:             if abs(node.value - target) < distance:
- 143:                 distance = abs(node.value - target)
- 144:                 best = node
- 145:             if target < node.value:
- 146:                 node = node.left
- 147:             elif target > node.value:
- 148:                 node = node.right
- 149:             else:
- 150:                 return target
- 151:         
- 152:         return best.value
- 153:     
+ 131:     @classmethod
+ 132:     def closest(self, target):
+ 133:         '''
+ 134:         Return value closest to target. If there are several, then
+ 135:         return one of them.
+ 136:         '''
+ 137:         if self.root is None:
+ 138:             return None
+ 139:         
+ 140:         best = node = self.root
+ 141:         distance = abs(self.root.value - target)
+ 142:         while node:
+ 143:             if abs(node.value - target) < distance:
+ 144:                 distance = abs(node.value - target)
+ 145:                 best = node
+ 146:             if target < node.value:
+ 147:                 node = node.left
+ 148:             elif target > node.value:
+ 149:                 node = node.right
+ 150:             else:
+ 151:                 return target
+ 152:         
+ 153:         return best.value
  154:     def __iter__(self):
  155:         '''In order traversal of elements in the tree.'''
  156:         if self.root:
  157:             for e in self.root.inorder():
--------------------------------------------------------------------------------
[0.10120 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_23

def test_case_23():
        bool_0 = True
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.add(bool_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_1 = binary_tree_0.closest(bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree1.BinaryTree'>, target = True

>   ???
E   AttributeError: type object 'BinaryTree' has no attribute 'root'

binarySearchTree1:137: AttributeError
   - [#  25] CDI binarySearchTree1: 
--------------------------------------------------------------------------------
  150:                 return target
  151:         
  152:         return best.value
  153:     
- 154:     def __iter__(self):
- 155:         '''In order traversal of elements in the tree.'''
- 156:         if self.root:
- 157:             for e in self.root.inorder():
- 158:                 yield e
- 159:     
+ 154:     @classmethod
+ 155:     def __iter__(self):
+ 156:         '''In order traversal of elements in the tree.'''
+ 157:         if self.root:
+ 158:             for e in self.root.inorder():
+ 159:                 yield e
  160:     def __repr__(self):
  161:         if self.root is None:
  162:             return 'binary:()'
  163:         return 'binary:' + str(self.root)
--------------------------------------------------------------------------------
[0.10794 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_26

def test_case_26():
        binary_tree_0 = module_0.BinaryTree()
>       object_0 = module_1.object(*binary_tree_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree1.BinaryTree'>

>   ???
E   AttributeError: type object 'BinaryTree' has no attribute 'root'

binarySearchTree1:157: AttributeError
   - [#  26] CDI binarySearchTree1: 
--------------------------------------------------------------------------------
  156:         if self.root:
  157:             for e in self.root.inorder():
  158:                 yield e
  159:     
- 160:     def __repr__(self):
- 161:         if self.root is None:
- 162:             return 'binary:()'
- 163:         return 'binary:' + str(self.root)
- 164: 
+ 160:     @classmethod
+ 161:     def __repr__(self):
+ 162:         if self.root is None:
+ 163:             return 'binary:()'
+ 164:         return 'binary:' + str(self.root)
  165: '''
  166: Change Log:
  167: -----------
  168: 
--------------------------------------------------------------------------------
[0.12563 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_15

def test_case_15():
        binary_tree_0 = module_0.BinaryTree()
        binary_tree_1 = module_0.BinaryTree()
>       var_0 = binary_tree_0.__repr__()

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <class 'binarySearchTree1.BinaryTree'>

>   ???
E   AttributeError: type object 'BinaryTree' has no attribute 'root'

binarySearchTree1:162: AttributeError
   - [#  27] COI binarySearchTree1: 
--------------------------------------------------------------------------------
   14:     def add(self, val):
   15:         '''
   16:         Add a new node to the tree with value. Respond based on Set semantics
   17:         '''
-  18:         if val <= self.value:
+  18:         if not (val <= self.value):
   19:             self.left = self.addToSubTree(self.left, val)
   20:         elif val > self.value:
   21:             self.right = self.addToSubTree(self.right, val)
   22:     
--------------------------------------------------------------------------------
[0.10984 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_0

def test_case_0():
        bool_0 = True
        bool_1 = False
        binary_node_0 = module_0.BinaryNode(bool_1)
        var_0 = binary_node_0.add(bool_0)
>       assert f'{type(binary_node_0.right).__module__}.{type(binary_node_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:11: AssertionError
   - [#  28] COI binarySearchTree1: 
--------------------------------------------------------------------------------
   16:         Add a new node to the tree with value. Respond based on Set semantics
   17:         '''
   18:         if val <= self.value:
   19:             self.left = self.addToSubTree(self.left, val)
-  20:         elif val > self.value:
+  20:         elif not (val > self.value):
   21:             self.right = self.addToSubTree(self.right, val)
   22:     
   23:     def addToSubTree(self, parent, val):
   24:         '''Add val to parent subtree (if exists) and return root of that subtree.'''
--------------------------------------------------------------------------------
[0.09649 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_0

def test_case_0():
        bool_0 = True
        bool_1 = False
        binary_node_0 = module_0.BinaryNode(bool_1)
        var_0 = binary_node_0.add(bool_0)
>       assert f'{type(binary_node_0.right).__module__}.{type(binary_node_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:11: AssertionError
   - [#  29] COI binarySearchTree1: 
--------------------------------------------------------------------------------
   21:             self.right = self.addToSubTree(self.right, val)
   22:     
   23:     def addToSubTree(self, parent, val):
   24:         '''Add val to parent subtree (if exists) and return root of that subtree.'''
-  25:         if parent is None:
+  25:         if not (parent is None):
   26:             return BinaryNode(val)
   27:         
   28:         parent.add(val)
   29:         return parent
--------------------------------------------------------------------------------
[0.08782 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_0

def test_case_0():
        bool_0 = True
        bool_1 = False
        binary_node_0 = module_0.BinaryNode(bool_1)
>       var_0 = binary_node_0.add(bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:10: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree1:21: in add
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (L: False R:), parent = None, val = True

>   ???
E   AttributeError: 'NoneType' object has no attribute 'add'

binarySearchTree1:28: AttributeError
   - [#  30] COI binarySearchTree1: 
--------------------------------------------------------------------------------
   31:     def remove(self, val):
   32:         '''
   33:          Remove val of self from BinaryTree. 
   34:         '''
-  35:         if val < self.value:
+  35:         if not (val < self.value):
   36:             self.left = self.removeFromParent(self.left, val)
   37:         elif val > self.value:
   38:             self.right = self.removeFromParent(self.right, val)
   39:         else:
--------------------------------------------------------------------------------
[0.09228 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_4

def test_case_4():
        bool_0 = True
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = var_0.removeFromParent(binary_node_0, bool_0)
>       assert binary_node_0.left is None
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:42: AssertionError
   - [#  31] COI binarySearchTree1: 
--------------------------------------------------------------------------------
   33:          Remove val of self from BinaryTree. 
   34:         '''
   35:         if val < self.value:
   36:             self.left = self.removeFromParent(self.left, val)
-  37:         elif val > self.value:
+  37:         elif not (val > self.value):
   38:             self.right = self.removeFromParent(self.right, val)
   39:         else:
   40:             if self.left is None:
   41:                 return self.right
--------------------------------------------------------------------------------
[0.09183 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_2

def test_case_2():
        bool_0 = True
        bool_1 = False
        binary_node_0 = module_0.BinaryNode(bool_1)
        var_0 = binary_node_0.remove(bool_0)
>       assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'binarySearchTree1.BinaryNode'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:25: AssertionError
   - [#  32] COI binarySearchTree1: 
--------------------------------------------------------------------------------
   36:             self.left = self.removeFromParent(self.left, val)
   37:         elif val > self.value:
   38:             self.right = self.removeFromParent(self.right, val)
   39:         else:
-  40:             if self.left is None:
+  40:             if not (self.left is None):
   41:                 return self.right
   42:             
   43:             child = self.left
   44:             while child.right:
--------------------------------------------------------------------------------
[0.11686 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_3

def test_case_3():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
>       var_0 = binary_node_0.removeFromParent(binary_node_0, bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree1:57: in removeFromParent
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (L: False R:), val = False

>   ???
E   AttributeError: 'NoneType' object has no attribute 'right'

binarySearchTree1:44: AttributeError
   - [#  33] COI binarySearchTree1: 
--------------------------------------------------------------------------------
   40:             if self.left is None:
   41:                 return self.right
   42:             
   43:             child = self.left
-  44:             while child.right:
+  44:             while not (child.right):
   45:                 child = child.right
   46:             
   47:             childKey = child.value
   48:             self.left = self.removeFromParent(self.left, childKey)
--------------------------------------------------------------------------------
[0.10900 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_4

def test_case_4():
        bool_0 = True
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_1 = var_0.removeFromParent(binary_node_0, bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree1:57: in removeFromParent
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (L:(L: True R:) True R:), val = True

>   ???
E   AttributeError: 'NoneType' object has no attribute 'right'

binarySearchTree1:44: AttributeError
   - [#  34] COI binarySearchTree1: 
--------------------------------------------------------------------------------
   52:     
   53:     def removeFromParent(self, parent, val):
   54:         '''Helper method for remove. Ensures proper behavior when removing node that 
   55:         has children.'''
-  56:         if parent:
+  56:         if not parent:
   57:             return parent.remove(val)
   58:         return None
   59:     
   60:     def __repr__(self):
--------------------------------------------------------------------------------
[0.08573 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_2

def test_case_2():
        bool_0 = True
        bool_1 = False
        binary_node_0 = module_0.BinaryNode(bool_1)
>       var_0 = binary_node_0.remove(bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree1:38: in remove
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (L: False R:), parent = None, val = True

>   ???
E   AttributeError: 'NoneType' object has no attribute 'remove'

binarySearchTree1:57: AttributeError
   - [#  35] COI binarySearchTree1: 
--------------------------------------------------------------------------------
   60:     def __repr__(self):
   61:         '''Useful debugging function to produce linear tree representation.'''
   62:         leftS = ''
   63:         rightS = ''
-  64:         if self.left:
+  64:         if not (self.left):
   65:             leftS = str(self.left)
   66:         if self.right:
   67:             rightS = str(self.right)
   68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
--------------------------------------------------------------------------------
[0.09531 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_7

def test_case_7():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_node_0.removeFromParent(binary_node_0, bool_0)
        assert binary_node_0.left is None
        assert var_0.left is None
        assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_1.value is False
        assert var_1.left is None
        assert var_1.right is None
        bool_1 = True
        binary_tree_0 = module_0.BinaryTree()
        var_2 = var_0.addToSubTree(var_0, bool_1)
        assert f'{type(binary_node_0.right).__module__}.{type(binary_node_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.right).__module__}.{type(var_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_1.right).__module__}.{type(var_1.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_2.value is False
        assert var_2.left is None
        assert f'{type(var_2.right).__module__}.{type(var_2.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = var_0.__repr__()
>       assert var_3 == '(L: False R:(L: True R:))'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:89: AssertionError
   - [#  36] COI binarySearchTree1: 
--------------------------------------------------------------------------------
   62:         leftS = ''
   63:         rightS = ''
   64:         if self.left:
   65:             leftS = str(self.left)
-  66:         if self.right:
+  66:         if not (self.right):
   67:             rightS = str(self.right)
   68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
   69:     
   70:     def inorder(self):
--------------------------------------------------------------------------------
[0.09559 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_7

def test_case_7():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_node_0.removeFromParent(binary_node_0, bool_0)
        assert binary_node_0.left is None
        assert var_0.left is None
        assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_1.value is False
        assert var_1.left is None
        assert var_1.right is None
        bool_1 = True
        binary_tree_0 = module_0.BinaryTree()
        var_2 = var_0.addToSubTree(var_0, bool_1)
        assert f'{type(binary_node_0.right).__module__}.{type(binary_node_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.right).__module__}.{type(var_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_1.right).__module__}.{type(var_1.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_2.value is False
        assert var_2.left is None
        assert f'{type(var_2.right).__module__}.{type(var_2.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = var_0.__repr__()
>       assert var_3 == '(L: False R:(L: True R:))'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:89: AssertionError
   - [#  37] COI binarySearchTree1: 
--------------------------------------------------------------------------------
   68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
   69:     
   70:     def inorder(self):
   71:         '''In order traversal generator of tree rooted at given node.'''
-  72:         if self.left:
+  72:         if not (self.left):
   73:             for v in self.left.inorder():
   74:                 yield v
   75:         
   76:         yield self.value
--------------------------------------------------------------------------------
[0.12164 s] survived
   - [#  38] COI binarySearchTree1: 
--------------------------------------------------------------------------------
   74:                 yield v
   75:         
   76:         yield self.value
   77:         
-  78:         if self.right:
+  78:         if not (self.right):
   79:             for v in self.right.inorder():
   80:                 yield v
   81: 
   82: class BinaryTree:
--------------------------------------------------------------------------------
[0.12116 s] survived
   - [#  39] COI binarySearchTree1: 
--------------------------------------------------------------------------------
   86:         self.root = None
   87:     
   88:     def add(self, value):
   89:         '''Insert value into proper location in Binary Tree.'''
-  90:         if self.root is None:
+  90:         if not (self.root is None):
   91:             self.root = BinaryNode(value)
   92:         else:
   93:             self.root.add(value)
   94:     
--------------------------------------------------------------------------------
[0.14749 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_10

def test_case_10():
        binary_tree_0 = module_0.BinaryTree()
>       var_0 = binary_tree_0.add(binary_tree_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:110: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = binary:(), value = binary:()

>   ???
E   AttributeError: 'NoneType' object has no attribute 'add'

binarySearchTree1:93: AttributeError
   - [#  40] COI binarySearchTree1: 
--------------------------------------------------------------------------------
   93:             self.root.add(value)
   94:     
   95:     def remove(self, val):
   96:         '''Remove value from tree.'''
-  97:         if self.root:
+  97:         if not (self.root):
   98:             self.root = self.root.remove(val)
   99:     
  100:     def getMin(self):
  101:         '''Returns minimum value.'''
--------------------------------------------------------------------------------
[0.09897 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_14

def test_case_14():
        binary_tree_0 = module_0.BinaryTree()
>       var_0 = binary_tree_0.remove(binary_tree_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = binary:(), val = binary:()

>   ???
E   AttributeError: 'NoneType' object has no attribute 'remove'

binarySearchTree1:98: AttributeError
   - [#  41] COI binarySearchTree1: 
--------------------------------------------------------------------------------
   98:             self.root = self.root.remove(val)
   99:     
  100:     def getMin(self):
  101:         '''Returns minimum value.'''
- 102:         if self.root is None:
+ 102:         if not (self.root is None):
  103:             raise ValueError('Binary Tree is empty')
  104:         n = self.root
  105:         while n.left != None:
  106:             n = n.left
--------------------------------------------------------------------------------
[0.09922 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_15

def test_case_15():
        binary_tree_0 = module_0.BinaryTree()
        binary_tree_1 = module_0.BinaryTree()
        var_0 = binary_tree_0.__repr__()
        assert var_0 == 'binary:()'
        var_1 = binary_tree_0.add(var_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_2 = binary_tree_0.add(var_0)
        var_3 = binary_tree_0.__iter__()
        var_4 = var_3.__repr__()
>       var_5 = binary_tree_0.getMin()

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = binary:(L:(L: binary:() R:) binary:() R:)

>   ???
E   ValueError: Binary Tree is empty

binarySearchTree1:103: ValueError
   - [#  42] COI binarySearchTree1: 
--------------------------------------------------------------------------------
  101:         '''Returns minimum value.'''
  102:         if self.root is None:
  103:             raise ValueError('Binary Tree is empty')
  104:         n = self.root
- 105:         while n.left != None:
+ 105:         while not (n.left != None):
  106:             n = n.left
  107:         return n.value
  108:     
  109:     def getMax(self):
--------------------------------------------------------------------------------
[0.10024 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_16

def test_case_16():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.add(binary_tree_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_1 = binary_tree_0.getMin()

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[RecursionError('maximum recursion depth exceeded while getting the str of an object') raised in repr()] BinaryTree object at 0x7fa525560a60>

>   ???
E   AttributeError: 'NoneType' object has no attribute 'left'

binarySearchTree1:105: AttributeError
   - [#  43] COI binarySearchTree1: 
--------------------------------------------------------------------------------
  107:         return n.value
  108:     
  109:     def getMax(self):
  110:         '''Returns maximum value.'''
- 111:         if self.root is None:
+ 111:         if not (self.root is None):
  112:             raise ValueError('Binary Tree is empty')
  113:         n = self.root
  114:         while n.right != None:
  115:             n = n.right
--------------------------------------------------------------------------------
[0.09919 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_18

def test_case_18():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.add(binary_tree_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_1 = binary_tree_0.getMax()

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[RecursionError('maximum recursion depth exceeded while getting the str of an object') raised in repr()] BinaryTree object at 0x7fa525201b70>

>   ???
E   ValueError: Binary Tree is empty

binarySearchTree1:112: ValueError
   - [#  44] COI binarySearchTree1: 
--------------------------------------------------------------------------------
  110:         '''Returns maximum value.'''
  111:         if self.root is None:
  112:             raise ValueError('Binary Tree is empty')
  113:         n = self.root
- 114:         while n.right != None:
+ 114:         while not (n.right != None):
  115:             n = n.right
  116:         return n.value
  117:     
  118:     def __contains__(self, target):
--------------------------------------------------------------------------------
[0.09783 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_18

def test_case_18():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.add(binary_tree_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_1 = binary_tree_0.getMax()

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[RecursionError('maximum recursion depth exceeded while getting the str of an object') raised in repr()] BinaryTree object at 0x7fa524e8a4a0>

>   ???
E   AttributeError: 'NoneType' object has no attribute 'right'

binarySearchTree1:114: AttributeError
   - [#  45] COI binarySearchTree1: 
--------------------------------------------------------------------------------
  117:     
  118:     def __contains__(self, target):
  119:         '''Check whether BST contains target value.'''
  120:         node = self.root
- 121:         while node:
+ 121:         while not node:
  122:             if target < node.value:
  123:                 node = node.left
  124:             elif target > node.value:
  125:                 node = node.right
--------------------------------------------------------------------------------
[0.13713 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_20

def test_case_20():
        binary_tree_0 = module_0.BinaryTree()
        set_0 = {binary_tree_0}
        var_0 = binary_tree_0.add(set_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_tree_0.__contains__(set_0)
>       assert var_1 is True
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:177: AssertionError
   - [#  46] COI binarySearchTree1: 
--------------------------------------------------------------------------------
  118:     def __contains__(self, target):
  119:         '''Check whether BST contains target value.'''
  120:         node = self.root
  121:         while node:
- 122:             if target < node.value:
+ 122:             if not (target < node.value):
  123:                 node = node.left
  124:             elif target > node.value:
  125:                 node = node.right
  126:             else:
--------------------------------------------------------------------------------
[0.10435 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_20

def test_case_20():
        binary_tree_0 = module_0.BinaryTree()
        set_0 = {binary_tree_0}
        var_0 = binary_tree_0.add(set_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_tree_0.__contains__(set_0)
>       assert var_1 is True
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:177: AssertionError
   - [#  47] COI binarySearchTree1: 
--------------------------------------------------------------------------------
  120:         node = self.root
  121:         while node:
  122:             if target < node.value:
  123:                 node = node.left
- 124:             elif target > node.value:
+ 124:             elif not (target > node.value):
  125:                 node = node.right
  126:             else:
  127:                 return True
  128:         
--------------------------------------------------------------------------------
[0.10397 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_20

def test_case_20():
        binary_tree_0 = module_0.BinaryTree()
        set_0 = {binary_tree_0}
        var_0 = binary_tree_0.add(set_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_tree_0.__contains__(set_0)
>       assert var_1 is True
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:177: AssertionError
   - [#  48] COI binarySearchTree1: 
--------------------------------------------------------------------------------
  132:         '''
  133:         Return value closest to target. If there are several, then
  134:         return one of them.
  135:         '''
- 136:         if self.root is None:
+ 136:         if not (self.root is None):
  137:             return None
  138:         
  139:         best = node = self.root
  140:         distance = abs(self.root.value - target)
--------------------------------------------------------------------------------
[0.10565 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_23

def test_case_23():
        bool_0 = True
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.add(bool_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_tree_0.closest(bool_0)
>       assert var_1 is True
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:195: AssertionError
   - [#  49] COI binarySearchTree1: 
--------------------------------------------------------------------------------
  137:             return None
  138:         
  139:         best = node = self.root
  140:         distance = abs(self.root.value - target)
- 141:         while node:
+ 141:         while not node:
  142:             if abs(node.value - target) < distance:
  143:                 distance = abs(node.value - target)
  144:                 best = node
  145:             if target < node.value:
--------------------------------------------------------------------------------
[0.13552 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py::test_case_22

def test_case_22():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.closest(binary_tree_0)
        var_1 = binary_tree_0.__contains__(var_0)
        assert var_1 is False
        var_2 = binary_tree_0.add(var_1)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = binary_tree_0.__contains__(var_1)
        assert var_3 is True
        var_4 = binary_tree_0.add(var_3)
        var_5 = binary_tree_0.getMax()
        assert var_5 is True
        var_6 = binary_tree_0.closest(var_5)
>       assert var_6 is True
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py:251: AssertionError
   - [#  50] COI binarySearchTree1: 
--------------------------------------------------------------------------------
  138:         
  139:         best = node = self.root
  140:         distance = abs(self.root.value - target)
  141:         while node:
- 142:             if abs(node.value - target) < distance:
+ 142:             if not (abs(node.value - target) < distance):
  143:                 distance = abs(node.value - target)
  144:                 best = node
  145:             if target < node.value:
  146:                 node = node.left
--------------------------------------------------------------------------------
[0.10707 s] survived
   - [#  51] COI binarySearchTree1: 
--------------------------------------------------------------------------------
  141:         while node:
  142:             if abs(node.value - target) < distance:
  143:                 distance = abs(node.value - target)
  144:                 best = node
- 145:             if target < node.value:
+ 145:             if not (target < node.value):
  146:                 node = node.left
  147:             elif target > node.value:
  148:                 node = node.right
  149:             else:
--------------------------------------------------------------------------------
[0.14226 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_WHOLE_SUITE.py::test_case_13

def test_case_13():
        bool_0 = True
        binary_node_0 = module_0.BinaryNode(bool_0)
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.add(bool_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        none_type_0 = None
        bool_1 = False
        var_1 = binary_tree_0.__contains__(bool_1)
        assert var_1 is False
        bool_2 = False
        set_0 = {bool_2}
        var_2 = binary_tree_0.getMax()
        assert var_2 is True
        var_3 = binary_tree_0.closest(bool_2)
>       assert var_3 is True
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_WHOLE_SUITE.py:139: AssertionError
   - [#  52] COI binarySearchTree1: 
--------------------------------------------------------------------------------
  143:                 distance = abs(node.value - target)
  144:                 best = node
  145:             if target < node.value:
  146:                 node = node.left
- 147:             elif target > node.value:
+ 147:             elif not (target > node.value):
  148:                 node = node.right
  149:             else:
  150:                 return target
  151:         
--------------------------------------------------------------------------------
[0.13875 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_WHOLE_SUITE.py::test_case_18

def test_case_18():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.__contains__(binary_tree_0)
        assert var_0 is False
        var_1 = binary_tree_0.add(var_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_2 = binary_tree_0.__contains__(var_0)
        assert var_2 is True
        binary_node_0 = module_0.BinaryNode(var_0)
        var_3 = binary_tree_0.getMin()
        assert var_3 is False
        var_4 = binary_tree_0.closest(var_2)
>       assert var_4 is False
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_WHOLE_SUITE.py:203: AssertionError
   - [#  53] COI binarySearchTree1: 
--------------------------------------------------------------------------------
  152:         return best.value
  153:     
  154:     def __iter__(self):
  155:         '''In order traversal of elements in the tree.'''
- 156:         if self.root:
+ 156:         if not (self.root):
  157:             for e in self.root.inorder():
  158:                 yield e
  159:     
  160:     def __repr__(self):
--------------------------------------------------------------------------------
[0.10915 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_26

def test_case_26():
        binary_tree_0 = module_0.BinaryTree()
>       object_0 = module_1.object(*binary_tree_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = binary:()

>   ???
E   AttributeError: 'NoneType' object has no attribute 'inorder'

binarySearchTree1:157: AttributeError
   - [#  54] COI binarySearchTree1: 
--------------------------------------------------------------------------------
  157:             for e in self.root.inorder():
  158:                 yield e
  159:     
  160:     def __repr__(self):
- 161:         if self.root is None:
+ 161:         if not (self.root is None):
  162:             return 'binary:()'
  163:         return 'binary:' + str(self.root)
  164: 
  165: '''
--------------------------------------------------------------------------------
[0.09771 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_15

def test_case_15():
        binary_tree_0 = module_0.BinaryTree()
        binary_tree_1 = module_0.BinaryTree()
        var_0 = binary_tree_0.__repr__()
>       assert var_0 == 'binary:()'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:136: AssertionError
   - [#  55] CRP binarySearchTree1: 
--------------------------------------------------------------------------------
   58:         return None
   59:     
   60:     def __repr__(self):
   61:         '''Useful debugging function to produce linear tree representation.'''
-  62:         leftS = ''
+  62:         leftS = 'mutpy'
   63:         rightS = ''
   64:         if self.left:
   65:             leftS = str(self.left)
   66:         if self.right:
--------------------------------------------------------------------------------
[0.09345 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_7

def test_case_7():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_node_0.removeFromParent(binary_node_0, bool_0)
        assert binary_node_0.left is None
        assert var_0.left is None
        assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_1.value is False
        assert var_1.left is None
        assert var_1.right is None
        bool_1 = True
        binary_tree_0 = module_0.BinaryTree()
        var_2 = var_0.addToSubTree(var_0, bool_1)
        assert f'{type(binary_node_0.right).__module__}.{type(binary_node_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.right).__module__}.{type(var_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_1.right).__module__}.{type(var_1.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_2.value is False
        assert var_2.left is None
        assert f'{type(var_2.right).__module__}.{type(var_2.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = var_0.__repr__()
>       assert var_3 == '(L: False R:(L: True R:))'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:89: AssertionError
   - [#  56] CRP binarySearchTree1: 
--------------------------------------------------------------------------------
   59:     
   60:     def __repr__(self):
   61:         '''Useful debugging function to produce linear tree representation.'''
   62:         leftS = ''
-  63:         rightS = ''
+  63:         rightS = 'mutpy'
   64:         if self.left:
   65:             leftS = str(self.left)
   66:         if self.right:
   67:             rightS = str(self.right)
--------------------------------------------------------------------------------
[0.09618 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_7

def test_case_7():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_node_0.removeFromParent(binary_node_0, bool_0)
        assert binary_node_0.left is None
        assert var_0.left is None
        assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_1.value is False
        assert var_1.left is None
        assert var_1.right is None
        bool_1 = True
        binary_tree_0 = module_0.BinaryTree()
        var_2 = var_0.addToSubTree(var_0, bool_1)
        assert f'{type(binary_node_0.right).__module__}.{type(binary_node_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.right).__module__}.{type(var_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_1.right).__module__}.{type(var_1.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_2.value is False
        assert var_2.left is None
        assert f'{type(var_2.right).__module__}.{type(var_2.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = var_0.__repr__()
>       assert var_3 == '(L: False R:(L: True R:))'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:89: AssertionError
   - [#  57] CRP binarySearchTree1: 
--------------------------------------------------------------------------------
   64:         if self.left:
   65:             leftS = str(self.left)
   66:         if self.right:
   67:             rightS = str(self.right)
-  68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
+  68:         return ((((('mutpy' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
   69:     
   70:     def inorder(self):
   71:         '''In order traversal generator of tree rooted at given node.'''
   72:         if self.left:
--------------------------------------------------------------------------------
[0.11381 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_7

def test_case_7():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_node_0.removeFromParent(binary_node_0, bool_0)
        assert binary_node_0.left is None
        assert var_0.left is None
        assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_1.value is False
        assert var_1.left is None
        assert var_1.right is None
        bool_1 = True
        binary_tree_0 = module_0.BinaryTree()
        var_2 = var_0.addToSubTree(var_0, bool_1)
        assert f'{type(binary_node_0.right).__module__}.{type(binary_node_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.right).__module__}.{type(var_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_1.right).__module__}.{type(var_1.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_2.value is False
        assert var_2.left is None
        assert f'{type(var_2.right).__module__}.{type(var_2.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = var_0.__repr__()
>       assert var_3 == '(L: False R:(L: True R:))'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:89: AssertionError
   - [#  58] CRP binarySearchTree1: 
--------------------------------------------------------------------------------
   64:         if self.left:
   65:             leftS = str(self.left)
   66:         if self.right:
   67:             rightS = str(self.right)
-  68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
+  68:         return ((((('' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
   69:     
   70:     def inorder(self):
   71:         '''In order traversal generator of tree rooted at given node.'''
   72:         if self.left:
--------------------------------------------------------------------------------
[0.09537 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_7

def test_case_7():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_node_0.removeFromParent(binary_node_0, bool_0)
        assert binary_node_0.left is None
        assert var_0.left is None
        assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_1.value is False
        assert var_1.left is None
        assert var_1.right is None
        bool_1 = True
        binary_tree_0 = module_0.BinaryTree()
        var_2 = var_0.addToSubTree(var_0, bool_1)
        assert f'{type(binary_node_0.right).__module__}.{type(binary_node_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.right).__module__}.{type(var_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_1.right).__module__}.{type(var_1.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_2.value is False
        assert var_2.left is None
        assert f'{type(var_2.right).__module__}.{type(var_2.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = var_0.__repr__()
>       assert var_3 == '(L: False R:(L: True R:))'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:89: AssertionError
   - [#  59] CRP binarySearchTree1: 
--------------------------------------------------------------------------------
   64:         if self.left:
   65:             leftS = str(self.left)
   66:         if self.right:
   67:             rightS = str(self.right)
-  68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
+  68:         return ((((('(L:' + leftS) + 'mutpy') + str(self.value)) + ' R:') + rightS) + ')'
   69:     
   70:     def inorder(self):
   71:         '''In order traversal generator of tree rooted at given node.'''
   72:         if self.left:
--------------------------------------------------------------------------------
[0.09181 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_7

def test_case_7():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_node_0.removeFromParent(binary_node_0, bool_0)
        assert binary_node_0.left is None
        assert var_0.left is None
        assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_1.value is False
        assert var_1.left is None
        assert var_1.right is None
        bool_1 = True
        binary_tree_0 = module_0.BinaryTree()
        var_2 = var_0.addToSubTree(var_0, bool_1)
        assert f'{type(binary_node_0.right).__module__}.{type(binary_node_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.right).__module__}.{type(var_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_1.right).__module__}.{type(var_1.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_2.value is False
        assert var_2.left is None
        assert f'{type(var_2.right).__module__}.{type(var_2.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = var_0.__repr__()
>       assert var_3 == '(L: False R:(L: True R:))'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:89: AssertionError
   - [#  60] CRP binarySearchTree1: 
--------------------------------------------------------------------------------
   64:         if self.left:
   65:             leftS = str(self.left)
   66:         if self.right:
   67:             rightS = str(self.right)
-  68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
+  68:         return ((((('(L:' + leftS) + '') + str(self.value)) + ' R:') + rightS) + ')'
   69:     
   70:     def inorder(self):
   71:         '''In order traversal generator of tree rooted at given node.'''
   72:         if self.left:
--------------------------------------------------------------------------------
[0.09574 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_7

def test_case_7():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_node_0.removeFromParent(binary_node_0, bool_0)
        assert binary_node_0.left is None
        assert var_0.left is None
        assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_1.value is False
        assert var_1.left is None
        assert var_1.right is None
        bool_1 = True
        binary_tree_0 = module_0.BinaryTree()
        var_2 = var_0.addToSubTree(var_0, bool_1)
        assert f'{type(binary_node_0.right).__module__}.{type(binary_node_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.right).__module__}.{type(var_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_1.right).__module__}.{type(var_1.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_2.value is False
        assert var_2.left is None
        assert f'{type(var_2.right).__module__}.{type(var_2.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = var_0.__repr__()
>       assert var_3 == '(L: False R:(L: True R:))'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:89: AssertionError
   - [#  61] CRP binarySearchTree1: 
--------------------------------------------------------------------------------
   64:         if self.left:
   65:             leftS = str(self.left)
   66:         if self.right:
   67:             rightS = str(self.right)
-  68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
+  68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + 'mutpy') + rightS) + ')'
   69:     
   70:     def inorder(self):
   71:         '''In order traversal generator of tree rooted at given node.'''
   72:         if self.left:
--------------------------------------------------------------------------------
[0.13673 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_7

def test_case_7():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_node_0.removeFromParent(binary_node_0, bool_0)
        assert binary_node_0.left is None
        assert var_0.left is None
        assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_1.value is False
        assert var_1.left is None
        assert var_1.right is None
        bool_1 = True
        binary_tree_0 = module_0.BinaryTree()
        var_2 = var_0.addToSubTree(var_0, bool_1)
        assert f'{type(binary_node_0.right).__module__}.{type(binary_node_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.right).__module__}.{type(var_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_1.right).__module__}.{type(var_1.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_2.value is False
        assert var_2.left is None
        assert f'{type(var_2.right).__module__}.{type(var_2.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = var_0.__repr__()
>       assert var_3 == '(L: False R:(L: True R:))'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:89: AssertionError
   - [#  62] CRP binarySearchTree1: 
--------------------------------------------------------------------------------
   64:         if self.left:
   65:             leftS = str(self.left)
   66:         if self.right:
   67:             rightS = str(self.right)
-  68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
+  68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + '') + rightS) + ')'
   69:     
   70:     def inorder(self):
   71:         '''In order traversal generator of tree rooted at given node.'''
   72:         if self.left:
--------------------------------------------------------------------------------
[0.12423 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_7

def test_case_7():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_node_0.removeFromParent(binary_node_0, bool_0)
        assert binary_node_0.left is None
        assert var_0.left is None
        assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_1.value is False
        assert var_1.left is None
        assert var_1.right is None
        bool_1 = True
        binary_tree_0 = module_0.BinaryTree()
        var_2 = var_0.addToSubTree(var_0, bool_1)
        assert f'{type(binary_node_0.right).__module__}.{type(binary_node_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.right).__module__}.{type(var_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_1.right).__module__}.{type(var_1.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_2.value is False
        assert var_2.left is None
        assert f'{type(var_2.right).__module__}.{type(var_2.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = var_0.__repr__()
>       assert var_3 == '(L: False R:(L: True R:))'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:89: AssertionError
   - [#  63] CRP binarySearchTree1: 
--------------------------------------------------------------------------------
   64:         if self.left:
   65:             leftS = str(self.left)
   66:         if self.right:
   67:             rightS = str(self.right)
-  68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
+  68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + 'mutpy'
   69:     
   70:     def inorder(self):
   71:         '''In order traversal generator of tree rooted at given node.'''
   72:         if self.left:
--------------------------------------------------------------------------------
[0.09715 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_7

def test_case_7():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_node_0.removeFromParent(binary_node_0, bool_0)
        assert binary_node_0.left is None
        assert var_0.left is None
        assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_1.value is False
        assert var_1.left is None
        assert var_1.right is None
        bool_1 = True
        binary_tree_0 = module_0.BinaryTree()
        var_2 = var_0.addToSubTree(var_0, bool_1)
        assert f'{type(binary_node_0.right).__module__}.{type(binary_node_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.right).__module__}.{type(var_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_1.right).__module__}.{type(var_1.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_2.value is False
        assert var_2.left is None
        assert f'{type(var_2.right).__module__}.{type(var_2.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = var_0.__repr__()
>       assert var_3 == '(L: False R:(L: True R:))'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:89: AssertionError
   - [#  64] CRP binarySearchTree1: 
--------------------------------------------------------------------------------
   64:         if self.left:
   65:             leftS = str(self.left)
   66:         if self.right:
   67:             rightS = str(self.right)
-  68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
+  68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ''
   69:     
   70:     def inorder(self):
   71:         '''In order traversal generator of tree rooted at given node.'''
   72:         if self.left:
--------------------------------------------------------------------------------
[0.09422 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_7

def test_case_7():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_node_0.removeFromParent(binary_node_0, bool_0)
        assert binary_node_0.left is None
        assert var_0.left is None
        assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_1.value is False
        assert var_1.left is None
        assert var_1.right is None
        bool_1 = True
        binary_tree_0 = module_0.BinaryTree()
        var_2 = var_0.addToSubTree(var_0, bool_1)
        assert f'{type(binary_node_0.right).__module__}.{type(binary_node_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.right).__module__}.{type(var_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_1.right).__module__}.{type(var_1.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_2.value is False
        assert var_2.left is None
        assert f'{type(var_2.right).__module__}.{type(var_2.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = var_0.__repr__()
>       assert var_3 == '(L: False R:(L: True R:))'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:89: AssertionError
   - [#  65] CRP binarySearchTree1: 
--------------------------------------------------------------------------------
   99:     
  100:     def getMin(self):
  101:         '''Returns minimum value.'''
  102:         if self.root is None:
- 103:             raise ValueError('Binary Tree is empty')
+ 103:             raise ValueError('mutpy')
  104:         n = self.root
  105:         while n.left != None:
  106:             n = n.left
  107:         return n.value
--------------------------------------------------------------------------------
[0.15565 s] survived
   - [#  66] CRP binarySearchTree1: 
--------------------------------------------------------------------------------
   99:     
  100:     def getMin(self):
  101:         '''Returns minimum value.'''
  102:         if self.root is None:
- 103:             raise ValueError('Binary Tree is empty')
+ 103:             raise ValueError('')
  104:         n = self.root
  105:         while n.left != None:
  106:             n = n.left
  107:         return n.value
--------------------------------------------------------------------------------
[0.11550 s] survived
   - [#  67] CRP binarySearchTree1: 
--------------------------------------------------------------------------------
  108:     
  109:     def getMax(self):
  110:         '''Returns maximum value.'''
  111:         if self.root is None:
- 112:             raise ValueError('Binary Tree is empty')
+ 112:             raise ValueError('mutpy')
  113:         n = self.root
  114:         while n.right != None:
  115:             n = n.right
  116:         return n.value
--------------------------------------------------------------------------------
[0.15655 s] survived
   - [#  68] CRP binarySearchTree1: 
--------------------------------------------------------------------------------
  108:     
  109:     def getMax(self):
  110:         '''Returns maximum value.'''
  111:         if self.root is None:
- 112:             raise ValueError('Binary Tree is empty')
+ 112:             raise ValueError('')
  113:         n = self.root
  114:         while n.right != None:
  115:             n = n.right
  116:         return n.value
--------------------------------------------------------------------------------
[0.10942 s] survived
   - [#  69] CRP binarySearchTree1: 
--------------------------------------------------------------------------------
  158:                 yield e
  159:     
  160:     def __repr__(self):
  161:         if self.root is None:
- 162:             return 'binary:()'
+ 162:             return 'mutpy'
  163:         return 'binary:' + str(self.root)
  164: 
  165: '''
  166: Change Log:
--------------------------------------------------------------------------------
[0.10106 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_15

def test_case_15():
        binary_tree_0 = module_0.BinaryTree()
        binary_tree_1 = module_0.BinaryTree()
        var_0 = binary_tree_0.__repr__()
>       assert var_0 == 'binary:()'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:136: AssertionError
   - [#  70] CRP binarySearchTree1: 
--------------------------------------------------------------------------------
  158:                 yield e
  159:     
  160:     def __repr__(self):
  161:         if self.root is None:
- 162:             return 'binary:()'
+ 162:             return ''
  163:         return 'binary:' + str(self.root)
  164: 
  165: '''
  166: Change Log:
--------------------------------------------------------------------------------
[0.14132 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_15

def test_case_15():
        binary_tree_0 = module_0.BinaryTree()
        binary_tree_1 = module_0.BinaryTree()
        var_0 = binary_tree_0.__repr__()
>       assert var_0 == 'binary:()'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:136: AssertionError
   - [#  71] CRP binarySearchTree1: 
--------------------------------------------------------------------------------
  159:     
  160:     def __repr__(self):
  161:         if self.root is None:
  162:             return 'binary:()'
- 163:         return 'binary:' + str(self.root)
+ 163:         return 'mutpy' + str(self.root)
  164: 
  165: '''
  166: Change Log:
  167: -----------
--------------------------------------------------------------------------------
[0.12981 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py::test_case_9

def test_case_9():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.remove(binary_tree_0)
        var_1 = binary_tree_0.__contains__(var_0)
        assert var_1 is False
        var_2 = binary_tree_0.add(var_1)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = binary_tree_0.add(var_1)
        var_4 = binary_tree_0.__repr__()
>       assert var_4 == 'binary:(L:(L: False R:) False R:)'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py:77: AssertionError
   - [#  72] CRP binarySearchTree1: 
--------------------------------------------------------------------------------
  159:     
  160:     def __repr__(self):
  161:         if self.root is None:
  162:             return 'binary:()'
- 163:         return 'binary:' + str(self.root)
+ 163:         return '' + str(self.root)
  164: 
  165: '''
  166: Change Log:
  167: -----------
--------------------------------------------------------------------------------
[0.16255 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py::test_case_9

def test_case_9():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.remove(binary_tree_0)
        var_1 = binary_tree_0.__contains__(var_0)
        assert var_1 is False
        var_2 = binary_tree_0.add(var_1)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = binary_tree_0.add(var_1)
        var_4 = binary_tree_0.__repr__()
>       assert var_4 == 'binary:(L:(L: False R:) False R:)'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py:77: AssertionError
   - [#  73] CRP binarySearchTree1: 
--------------------------------------------------------------------------------
  161:         if self.root is None:
  162:             return 'binary:()'
  163:         return 'binary:' + str(self.root)
  164: 
- 165: '''
- 166: Change Log:
- 167: -----------
- 168: 
- 169: '''
+ 165: '''mutpy'''
--------------------------------------------------------------------------------
[0.12376 s] survived
   - [#  74] CRP binarySearchTree1: 
--------------------------------------------------------------------------------
  161:         if self.root is None:
  162:             return 'binary:()'
  163:         return 'binary:' + str(self.root)
  164: 
- 165: '''
- 166: Change Log:
- 167: -----------
- 168: 
- 169: '''
+ 165: ''''''
--------------------------------------------------------------------------------
[0.11374 s] survived
   - [#  75] OIL binarySearchTree1: 
--------------------------------------------------------------------------------
   42:             
   43:             child = self.left
   44:             while child.right:
   45:                 child = child.right
-  46:             
+  46:                 break
   47:             childKey = child.value
   48:             self.left = self.removeFromParent(self.left, childKey)
   49:             self.value = childKey
   50:         
--------------------------------------------------------------------------------
[0.13363 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py::test_case_28

def test_case_28():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.closest(binary_tree_0)
        var_1 = binary_tree_0.__contains__(var_0)
        assert var_1 is False
        int_0 = 3380
        var_2 = binary_tree_0.add(int_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = binary_tree_0.add(var_1)
        var_4 = binary_tree_0.__contains__(var_1)
        assert var_4 is True
        var_5 = binary_tree_0.add(var_4)
        var_6 = binary_tree_0.getMax()
        assert var_6 == 3380
        var_7 = binary_tree_0.closest(var_6)
        var_8 = var_3.__repr__()
        var_9 = binary_tree_0.add(var_7)
        var_10 = binary_tree_0.remove(var_7)
        var_11 = binary_tree_0.__repr__()
>       assert var_11 == 'binary:(L:(L: False R:(L: True R:)) 3380 R:)'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py:357: AssertionError
   - [#  76] OIL binarySearchTree1: 
--------------------------------------------------------------------------------
   71:         '''In order traversal generator of tree rooted at given node.'''
   72:         if self.left:
   73:             for v in self.left.inorder():
   74:                 yield v
-  75:         
+  75:                 break
   76:         yield self.value
   77:         
   78:         if self.right:
   79:             for v in self.right.inorder():
--------------------------------------------------------------------------------
[0.10711 s] survived
   - [#  77] OIL binarySearchTree1: 
--------------------------------------------------------------------------------
   77:         
   78:         if self.right:
   79:             for v in self.right.inorder():
   80:                 yield v
-  81: 
+  81:                 break
   82: class BinaryTree:
   83:     
   84:     def __init__(self):
   85:         '''Create empty binary tree.'''
--------------------------------------------------------------------------------
[0.10601 s] survived
   - [#  78] OIL binarySearchTree1: 
--------------------------------------------------------------------------------
  103:             raise ValueError('Binary Tree is empty')
  104:         n = self.root
  105:         while n.left != None:
  106:             n = n.left
- 107:         return n.value
- 108:     
+ 107:             break
+ 108:         return n.value
  109:     def getMax(self):
  110:         '''Returns maximum value.'''
  111:         if self.root is None:
  112:             raise ValueError('Binary Tree is empty')
--------------------------------------------------------------------------------
[0.10986 s] survived
   - [#  79] OIL binarySearchTree1: 
--------------------------------------------------------------------------------
  112:             raise ValueError('Binary Tree is empty')
  113:         n = self.root
  114:         while n.right != None:
  115:             n = n.right
- 116:         return n.value
- 117:     
+ 116:             break
+ 117:         return n.value
  118:     def __contains__(self, target):
  119:         '''Check whether BST contains target value.'''
  120:         node = self.root
  121:         while node:
--------------------------------------------------------------------------------
[0.13438 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py::test_case_30

def test_case_30():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.closest(binary_tree_0)
        var_1 = binary_tree_0.__contains__(var_0)
        assert var_1 is False
        int_0 = -4493
        var_2 = binary_tree_0.add(int_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = binary_tree_0.add(var_1)
        var_4 = binary_tree_0.__contains__(var_1)
        assert var_4 is True
        var_5 = binary_tree_0.add(var_4)
        var_6 = binary_tree_0.getMax()
>       assert var_6 is True
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py:390: AssertionError
   - [#  80] OIL binarySearchTree1: 
--------------------------------------------------------------------------------
  123:                 node = node.left
  124:             elif target > node.value:
  125:                 node = node.right
  126:             else:
- 127:                 return True
+ 127:                 return Truebreak
  128:         
  129:         return False
  130:     
  131:     def closest(self, target):
--------------------------------------------------------------------------------
[0.18376 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py::test_case_27

def test_case_27():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.closest(binary_tree_0)
        var_1 = binary_tree_0.__contains__(var_0)
        assert var_1 is False
        var_2 = binary_tree_0.add(var_1)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = binary_tree_0.__contains__(var_1)
        assert var_3 is True
        var_4 = binary_tree_0.add(var_3)
        var_5 = binary_tree_0.getMax()
        assert var_5 is True
        var_6 = var_5.__repr__()
        assert var_6 == 'True'
        var_7 = binary_tree_0.__contains__(var_3)
>       assert var_7 is True
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py:336: AssertionError
   - [#  81] OIL binarySearchTree1: 
--------------------------------------------------------------------------------
  146:                 node = node.left
  147:             elif target > node.value:
  148:                 node = node.right
  149:             else:
- 150:                 return target
+ 150:                 return targetbreak
  151:         
  152:         return best.value
  153:     
  154:     def __iter__(self):
--------------------------------------------------------------------------------
[0.14624 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py::test_case_22

def test_case_22():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.closest(binary_tree_0)
        var_1 = binary_tree_0.__contains__(var_0)
        assert var_1 is False
        var_2 = binary_tree_0.add(var_1)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = binary_tree_0.__contains__(var_1)
        assert var_3 is True
        var_4 = binary_tree_0.add(var_3)
        var_5 = binary_tree_0.getMax()
        assert var_5 is True
        var_6 = binary_tree_0.closest(var_5)
>       assert var_6 is True
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py:251: AssertionError
   - [#  82] OIL binarySearchTree1: 
--------------------------------------------------------------------------------
  155:         '''In order traversal of elements in the tree.'''
  156:         if self.root:
  157:             for e in self.root.inorder():
  158:                 yield e
- 159:     
+ 159:                 break
  160:     def __repr__(self):
  161:         if self.root is None:
  162:             return 'binary:()'
  163:         return 'binary:' + str(self.root)
--------------------------------------------------------------------------------
[0.10850 s] survived
   - [#  83] RIL binarySearchTree1: 
--------------------------------------------------------------------------------
   69:     
   70:     def inorder(self):
   71:         '''In order traversal generator of tree rooted at given node.'''
   72:         if self.left:
-  73:             for v in self.left.inorder():
+  73:             for v in reversed(self.left.inorder()):
   74:                 yield v
   75:         
   76:         yield self.value
   77:         
--------------------------------------------------------------------------------
[0.12271 s] survived
   - [#  84] RIL binarySearchTree1: 
--------------------------------------------------------------------------------
   75:         
   76:         yield self.value
   77:         
   78:         if self.right:
-  79:             for v in self.right.inorder():
+  79:             for v in reversed(self.right.inorder()):
   80:                 yield v
   81: 
   82: class BinaryTree:
   83:     
--------------------------------------------------------------------------------
[0.11520 s] survived
   - [#  85] RIL binarySearchTree1: 
--------------------------------------------------------------------------------
  153:     
  154:     def __iter__(self):
  155:         '''In order traversal of elements in the tree.'''
  156:         if self.root:
- 157:             for e in self.root.inorder():
+ 157:             for e in reversed(self.root.inorder()):
  158:                 yield e
  159:     
  160:     def __repr__(self):
  161:         if self.root is None:
--------------------------------------------------------------------------------
[0.13334 s] survived
   - [#  86] ROR binarySearchTree1: 
--------------------------------------------------------------------------------
   14:     def add(self, val):
   15:         '''
   16:         Add a new node to the tree with value. Respond based on Set semantics
   17:         '''
-  18:         if val <= self.value:
+  18:         if val >= self.value:
   19:             self.left = self.addToSubTree(self.left, val)
   20:         elif val > self.value:
   21:             self.right = self.addToSubTree(self.right, val)
   22:     
--------------------------------------------------------------------------------
[0.13888 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_0

def test_case_0():
        bool_0 = True
        bool_1 = False
        binary_node_0 = module_0.BinaryNode(bool_1)
        var_0 = binary_node_0.add(bool_0)
>       assert f'{type(binary_node_0.right).__module__}.{type(binary_node_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:11: AssertionError
   - [#  87] ROR binarySearchTree1: 
--------------------------------------------------------------------------------
   14:     def add(self, val):
   15:         '''
   16:         Add a new node to the tree with value. Respond based on Set semantics
   17:         '''
-  18:         if val <= self.value:
+  18:         if val < self.value:
   19:             self.left = self.addToSubTree(self.left, val)
   20:         elif val > self.value:
   21:             self.right = self.addToSubTree(self.right, val)
   22:     
--------------------------------------------------------------------------------
[0.10591 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_1

def test_case_1():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
>       assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:17: AssertionError
   - [#  88] ROR binarySearchTree1: 
--------------------------------------------------------------------------------
   16:         Add a new node to the tree with value. Respond based on Set semantics
   17:         '''
   18:         if val <= self.value:
   19:             self.left = self.addToSubTree(self.left, val)
-  20:         elif val > self.value:
+  20:         elif val < self.value:
   21:             self.right = self.addToSubTree(self.right, val)
   22:     
   23:     def addToSubTree(self, parent, val):
   24:         '''Add val to parent subtree (if exists) and return root of that subtree.'''
--------------------------------------------------------------------------------
[0.10486 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_0

def test_case_0():
        bool_0 = True
        bool_1 = False
        binary_node_0 = module_0.BinaryNode(bool_1)
        var_0 = binary_node_0.add(bool_0)
>       assert f'{type(binary_node_0.right).__module__}.{type(binary_node_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:11: AssertionError
   - [#  89] ROR binarySearchTree1: 
--------------------------------------------------------------------------------
   16:         Add a new node to the tree with value. Respond based on Set semantics
   17:         '''
   18:         if val <= self.value:
   19:             self.left = self.addToSubTree(self.left, val)
-  20:         elif val > self.value:
+  20:         elif val >= self.value:
   21:             self.right = self.addToSubTree(self.right, val)
   22:     
   23:     def addToSubTree(self, parent, val):
   24:         '''Add val to parent subtree (if exists) and return root of that subtree.'''
--------------------------------------------------------------------------------
[0.12803 s] survived
   - [#  90] ROR binarySearchTree1: 
--------------------------------------------------------------------------------
   31:     def remove(self, val):
   32:         '''
   33:          Remove val of self from BinaryTree. 
   34:         '''
-  35:         if val < self.value:
+  35:         if val > self.value:
   36:             self.left = self.removeFromParent(self.left, val)
   37:         elif val > self.value:
   38:             self.right = self.removeFromParent(self.right, val)
   39:         else:
--------------------------------------------------------------------------------
[0.10583 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_5

def test_case_5():
        str_0 = 'X>'
        str_1 = 'qkr(Szzyf\t'
        binary_node_0 = module_0.BinaryNode(str_1)
        var_0 = binary_node_0.remove(str_0)
>       assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'binarySearchTree1.BinaryNode'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:54: AssertionError
   - [#  91] ROR binarySearchTree1: 
--------------------------------------------------------------------------------
   31:     def remove(self, val):
   32:         '''
   33:          Remove val of self from BinaryTree. 
   34:         '''
-  35:         if val < self.value:
+  35:         if val <= self.value:
   36:             self.left = self.removeFromParent(self.left, val)
   37:         elif val > self.value:
   38:             self.right = self.removeFromParent(self.right, val)
   39:         else:
--------------------------------------------------------------------------------
[0.15800 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_4

def test_case_4():
        bool_0 = True
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = var_0.removeFromParent(binary_node_0, bool_0)
>       assert binary_node_0.left is None
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:42: AssertionError
   - [#  92] ROR binarySearchTree1: 
--------------------------------------------------------------------------------
   33:          Remove val of self from BinaryTree. 
   34:         '''
   35:         if val < self.value:
   36:             self.left = self.removeFromParent(self.left, val)
-  37:         elif val > self.value:
+  37:         elif val < self.value:
   38:             self.right = self.removeFromParent(self.right, val)
   39:         else:
   40:             if self.left is None:
   41:                 return self.right
--------------------------------------------------------------------------------
[0.10371 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_2

def test_case_2():
        bool_0 = True
        bool_1 = False
        binary_node_0 = module_0.BinaryNode(bool_1)
        var_0 = binary_node_0.remove(bool_0)
>       assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'binarySearchTree1.BinaryNode'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:25: AssertionError
   - [#  93] ROR binarySearchTree1: 
--------------------------------------------------------------------------------
   33:          Remove val of self from BinaryTree. 
   34:         '''
   35:         if val < self.value:
   36:             self.left = self.removeFromParent(self.left, val)
-  37:         elif val > self.value:
+  37:         elif val >= self.value:
   38:             self.right = self.removeFromParent(self.right, val)
   39:         else:
   40:             if self.left is None:
   41:                 return self.right
--------------------------------------------------------------------------------
[0.09464 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_4

def test_case_4():
        bool_0 = True
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = var_0.removeFromParent(binary_node_0, bool_0)
>       assert binary_node_0.left is None
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:42: AssertionError
   - [#  94] ROR binarySearchTree1: 
--------------------------------------------------------------------------------
  101:         '''Returns minimum value.'''
  102:         if self.root is None:
  103:             raise ValueError('Binary Tree is empty')
  104:         n = self.root
- 105:         while n.left != None:
+ 105:         while n.left == None:
  106:             n = n.left
  107:         return n.value
  108:     
  109:     def getMax(self):
--------------------------------------------------------------------------------
[0.11558 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_16

def test_case_16():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.add(binary_tree_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_1 = binary_tree_0.getMin()

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[RecursionError('maximum recursion depth exceeded while getting the str of an object') raised in repr()] BinaryTree object at 0x7fa5253665f0>

>   ???
E   AttributeError: 'NoneType' object has no attribute 'left'

binarySearchTree1:105: AttributeError
   - [#  95] ROR binarySearchTree1: 
--------------------------------------------------------------------------------
  110:         '''Returns maximum value.'''
  111:         if self.root is None:
  112:             raise ValueError('Binary Tree is empty')
  113:         n = self.root
- 114:         while n.right != None:
+ 114:         while n.right == None:
  115:             n = n.right
  116:         return n.value
  117:     
  118:     def __contains__(self, target):
--------------------------------------------------------------------------------
[0.10053 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_18

def test_case_18():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.add(binary_tree_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_1 = binary_tree_0.getMax()

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[RecursionError('maximum recursion depth exceeded while getting the str of an object') raised in repr()] BinaryTree object at 0x7fa525158760>

>   ???
E   AttributeError: 'NoneType' object has no attribute 'right'

binarySearchTree1:114: AttributeError
   - [#  96] ROR binarySearchTree1: 
--------------------------------------------------------------------------------
  118:     def __contains__(self, target):
  119:         '''Check whether BST contains target value.'''
  120:         node = self.root
  121:         while node:
- 122:             if target < node.value:
+ 122:             if target > node.value:
  123:                 node = node.left
  124:             elif target > node.value:
  125:                 node = node.right
  126:             else:
--------------------------------------------------------------------------------
[0.10933 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_WHOLE_SUITE.py::test_case_13

def test_case_13():
        bool_0 = True
        binary_node_0 = module_0.BinaryNode(bool_0)
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.add(bool_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        none_type_0 = None
        bool_1 = False
        var_1 = binary_tree_0.__contains__(bool_1)
>       assert var_1 is False
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_WHOLE_SUITE.py:133: AssertionError
   - [#  97] ROR binarySearchTree1: 
--------------------------------------------------------------------------------
  118:     def __contains__(self, target):
  119:         '''Check whether BST contains target value.'''
  120:         node = self.root
  121:         while node:
- 122:             if target < node.value:
+ 122:             if target <= node.value:
  123:                 node = node.left
  124:             elif target > node.value:
  125:                 node = node.right
  126:             else:
--------------------------------------------------------------------------------
[0.16510 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_20

def test_case_20():
        binary_tree_0 = module_0.BinaryTree()
        set_0 = {binary_tree_0}
        var_0 = binary_tree_0.add(set_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_tree_0.__contains__(set_0)
>       assert var_1 is True
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:177: AssertionError
   - [#  98] ROR binarySearchTree1: 
--------------------------------------------------------------------------------
  120:         node = self.root
  121:         while node:
  122:             if target < node.value:
  123:                 node = node.left
- 124:             elif target > node.value:
+ 124:             elif target < node.value:
  125:                 node = node.right
  126:             else:
  127:                 return True
  128:         
--------------------------------------------------------------------------------
[0.17688 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py::test_case_17

def test_case_17():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.__contains__(binary_tree_0)
        assert var_0 is False
        var_1 = binary_tree_0.add(var_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_2 = binary_tree_0.__contains__(var_0)
        assert var_2 is True
        var_3 = binary_tree_0.getMax()
        assert var_3 is False
        var_4 = var_1.__repr__()
        var_5 = binary_tree_0.__contains__(var_2)
>       assert var_5 is False
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py:170: AssertionError
   - [#  99] ROR binarySearchTree1: 
--------------------------------------------------------------------------------
  120:         node = self.root
  121:         while node:
  122:             if target < node.value:
  123:                 node = node.left
- 124:             elif target > node.value:
+ 124:             elif target >= node.value:
  125:                 node = node.right
  126:             else:
  127:                 return True
  128:         
--------------------------------------------------------------------------------
[0.10362 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_20

def test_case_20():
        binary_tree_0 = module_0.BinaryTree()
        set_0 = {binary_tree_0}
        var_0 = binary_tree_0.add(set_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_tree_0.__contains__(set_0)
>       assert var_1 is True
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:177: AssertionError
   - [# 100] ROR binarySearchTree1: 
--------------------------------------------------------------------------------
  138:         
  139:         best = node = self.root
  140:         distance = abs(self.root.value - target)
  141:         while node:
- 142:             if abs(node.value - target) < distance:
+ 142:             if abs(node.value - target) > distance:
  143:                 distance = abs(node.value - target)
  144:                 best = node
  145:             if target < node.value:
  146:                 node = node.left
--------------------------------------------------------------------------------
[0.11404 s] survived
   - [# 101] ROR binarySearchTree1: 
--------------------------------------------------------------------------------
  138:         
  139:         best = node = self.root
  140:         distance = abs(self.root.value - target)
  141:         while node:
- 142:             if abs(node.value - target) < distance:
+ 142:             if abs(node.value - target) <= distance:
  143:                 distance = abs(node.value - target)
  144:                 best = node
  145:             if target < node.value:
  146:                 node = node.left
--------------------------------------------------------------------------------
[0.11113 s] survived
   - [# 102] ROR binarySearchTree1: 
--------------------------------------------------------------------------------
  141:         while node:
  142:             if abs(node.value - target) < distance:
  143:                 distance = abs(node.value - target)
  144:                 best = node
- 145:             if target < node.value:
+ 145:             if target > node.value:
  146:                 node = node.left
  147:             elif target > node.value:
  148:                 node = node.right
  149:             else:
--------------------------------------------------------------------------------
[0.16089 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_WHOLE_SUITE.py::test_case_13

def test_case_13():
        bool_0 = True
        binary_node_0 = module_0.BinaryNode(bool_0)
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.add(bool_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        none_type_0 = None
        bool_1 = False
        var_1 = binary_tree_0.__contains__(bool_1)
        assert var_1 is False
        bool_2 = False
        set_0 = {bool_2}
        var_2 = binary_tree_0.getMax()
        assert var_2 is True
        var_3 = binary_tree_0.closest(bool_2)
>       assert var_3 is True
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_WHOLE_SUITE.py:139: AssertionError
   - [# 103] ROR binarySearchTree1: 
--------------------------------------------------------------------------------
  141:         while node:
  142:             if abs(node.value - target) < distance:
  143:                 distance = abs(node.value - target)
  144:                 best = node
- 145:             if target < node.value:
+ 145:             if target <= node.value:
  146:                 node = node.left
  147:             elif target > node.value:
  148:                 node = node.right
  149:             else:
--------------------------------------------------------------------------------
[0.11070 s] survived
   - [# 104] ROR binarySearchTree1: 
--------------------------------------------------------------------------------
  143:                 distance = abs(node.value - target)
  144:                 best = node
  145:             if target < node.value:
  146:                 node = node.left
- 147:             elif target > node.value:
+ 147:             elif target < node.value:
  148:                 node = node.right
  149:             else:
  150:                 return target
  151:         
--------------------------------------------------------------------------------
[0.12203 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_WHOLE_SUITE.py::test_case_18

def test_case_18():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.__contains__(binary_tree_0)
        assert var_0 is False
        var_1 = binary_tree_0.add(var_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_2 = binary_tree_0.__contains__(var_0)
        assert var_2 is True
        binary_node_0 = module_0.BinaryNode(var_0)
        var_3 = binary_tree_0.getMin()
        assert var_3 is False
        var_4 = binary_tree_0.closest(var_2)
>       assert var_4 is False
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_WHOLE_SUITE.py:203: AssertionError
   - [# 105] ROR binarySearchTree1: 
--------------------------------------------------------------------------------
  143:                 distance = abs(node.value - target)
  144:                 best = node
  145:             if target < node.value:
  146:                 node = node.left
- 147:             elif target > node.value:
+ 147:             elif target >= node.value:
  148:                 node = node.right
  149:             else:
  150:                 return target
  151:         
--------------------------------------------------------------------------------
[0.11096 s] survived
   - [# 106] SDI binarySearchTree1: 
--------------------------------------------------------------------------------
    4:     Author: George Heineman    
    5: '''
    6: class BinaryNode:
    7:     
-   8:     def __init__(self, value):
-   9:         '''Create binary node.'''
-  10:         self.value = value
-  11:         self.left = None
-  12:         self.right = None
-  13:     
+   8:     @staticmethod
+   9:     def __init__(self, value):
+  10:         '''Create binary node.'''
+  11:         self.value = value
+  12:         self.left = None
+  13:         self.right = None
   14:     def add(self, val):
   15:         '''
   16:         Add a new node to the tree with value. Respond based on Set semantics
   17:         '''
--------------------------------------------------------------------------------
[0.09821 s] incompetent

TypeError: /home/auri/temp/lucca/python_experiments/binarySearchTree1/DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:9: TypeError: BinaryNode.__init__() missing 1 required positional argument: 'value'

   - [# 107] SDI binarySearchTree1: 
--------------------------------------------------------------------------------
   10:         self.value = value
   11:         self.left = None
   12:         self.right = None
   13:     
-  14:     def add(self, val):
-  15:         '''
-  16:         Add a new node to the tree with value. Respond based on Set semantics
-  17:         '''
-  18:         if val <= self.value:
-  19:             self.left = self.addToSubTree(self.left, val)
-  20:         elif val > self.value:
-  21:             self.right = self.addToSubTree(self.right, val)
-  22:     
+  14:     @staticmethod
+  15:     def add(self, val):
+  16:         '''
+  17:         Add a new node to the tree with value. Respond based on Set semantics
+  18:         '''
+  19:         if val <= self.value:
+  20:             self.left = self.addToSubTree(self.left, val)
+  21:         elif val > self.value:
+  22:             self.right = self.addToSubTree(self.right, val)
   23:     def addToSubTree(self, parent, val):
   24:         '''Add val to parent subtree (if exists) and return root of that subtree.'''
   25:         if parent is None:
   26:             return BinaryNode(val)
--------------------------------------------------------------------------------
[0.13427 s] incompetent

TypeError: /home/auri/temp/lucca/python_experiments/binarySearchTree1/DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:10: TypeError: BinaryNode.add() missing 1 required positional argument: 'val'

   - [# 108] SDI binarySearchTree1: 
--------------------------------------------------------------------------------
   19:             self.left = self.addToSubTree(self.left, val)
   20:         elif val > self.value:
   21:             self.right = self.addToSubTree(self.right, val)
   22:     
-  23:     def addToSubTree(self, parent, val):
-  24:         '''Add val to parent subtree (if exists) and return root of that subtree.'''
-  25:         if parent is None:
-  26:             return BinaryNode(val)
-  27:         
-  28:         parent.add(val)
-  29:         return parent
-  30:     
+  23:     @staticmethod
+  24:     def addToSubTree(self, parent, val):
+  25:         '''Add val to parent subtree (if exists) and return root of that subtree.'''
+  26:         if parent is None:
+  27:             return BinaryNode(val)
+  28:         
+  29:         parent.add(val)
+  30:         return parent
   31:     def remove(self, val):
   32:         '''
   33:          Remove val of self from BinaryTree. 
   34:         '''
--------------------------------------------------------------------------------
[0.10461 s] incompetent

TypeError: binarySearchTree1:21: TypeError: BinaryNode.addToSubTree() missing 1 required positional argument: 'val'

   - [# 109] SDI binarySearchTree1: 
--------------------------------------------------------------------------------
   27:         
   28:         parent.add(val)
   29:         return parent
   30:     
-  31:     def remove(self, val):
-  32:         '''
-  33:          Remove val of self from BinaryTree. 
-  34:         '''
-  35:         if val < self.value:
-  36:             self.left = self.removeFromParent(self.left, val)
-  37:         elif val > self.value:
-  38:             self.right = self.removeFromParent(self.right, val)
-  39:         else:
-  40:             if self.left is None:
-  41:                 return self.right
-  42:             
-  43:             child = self.left
-  44:             while child.right:
-  45:                 child = child.right
-  46:             
-  47:             childKey = child.value
-  48:             self.left = self.removeFromParent(self.left, childKey)
-  49:             self.value = childKey
-  50:         
-  51:         return self
-  52:     
+  31:     @staticmethod
+  32:     def remove(self, val):
+  33:         '''
+  34:          Remove val of self from BinaryTree. 
+  35:         '''
+  36:         if val < self.value:
+  37:             self.left = self.removeFromParent(self.left, val)
+  38:         elif val > self.value:
+  39:             self.right = self.removeFromParent(self.right, val)
+  40:         else:
+  41:             if self.left is None:
+  42:                 return self.right
+  43:             
+  44:             child = self.left
+  45:             while child.right:
+  46:                 child = child.right
+  47:             
+  48:             childKey = child.value
+  49:             self.left = self.removeFromParent(self.left, childKey)
+  50:             self.value = childKey
+  51:         
+  52:         return self
   53:     def removeFromParent(self, parent, val):
   54:         '''Helper method for remove. Ensures proper behavior when removing node that 
   55:         has children.'''
   56:         if parent:
--------------------------------------------------------------------------------
[0.09526 s] incompetent

TypeError: /home/auri/temp/lucca/python_experiments/binarySearchTree1/DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:24: TypeError: BinaryNode.remove() missing 1 required positional argument: 'val'

   - [# 110] SDI binarySearchTree1: 
--------------------------------------------------------------------------------
   49:             self.value = childKey
   50:         
   51:         return self
   52:     
-  53:     def removeFromParent(self, parent, val):
-  54:         '''Helper method for remove. Ensures proper behavior when removing node that 
-  55:         has children.'''
-  56:         if parent:
-  57:             return parent.remove(val)
-  58:         return None
-  59:     
+  53:     @staticmethod
+  54:     def removeFromParent(self, parent, val):
+  55:         '''Helper method for remove. Ensures proper behavior when removing node that 
+  56:         has children.'''
+  57:         if parent:
+  58:             return parent.remove(val)
+  59:         return None
   60:     def __repr__(self):
   61:         '''Useful debugging function to produce linear tree representation.'''
   62:         leftS = ''
   63:         rightS = ''
--------------------------------------------------------------------------------
[0.14063 s] incompetent

TypeError: binarySearchTree1:38: TypeError: BinaryNode.removeFromParent() missing 1 required positional argument: 'val'

   - [# 111] SDI binarySearchTree1: 
--------------------------------------------------------------------------------
   56:         if parent:
   57:             return parent.remove(val)
   58:         return None
   59:     
-  60:     def __repr__(self):
-  61:         '''Useful debugging function to produce linear tree representation.'''
-  62:         leftS = ''
-  63:         rightS = ''
-  64:         if self.left:
-  65:             leftS = str(self.left)
-  66:         if self.right:
-  67:             rightS = str(self.right)
-  68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
-  69:     
+  60:     @staticmethod
+  61:     def __repr__(self):
+  62:         '''Useful debugging function to produce linear tree representation.'''
+  63:         leftS = ''
+  64:         rightS = ''
+  65:         if self.left:
+  66:             leftS = str(self.left)
+  67:         if self.right:
+  68:             rightS = str(self.right)
+  69:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
   70:     def inorder(self):
   71:         '''In order traversal generator of tree rooted at given node.'''
   72:         if self.left:
   73:             for v in self.left.inorder():
--------------------------------------------------------------------------------
[0.10152 s] incompetent

TypeError: /home/auri/temp/lucca/python_experiments/binarySearchTree1/DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:88: TypeError: BinaryNode.__repr__() missing 1 required positional argument: 'self'

   - [# 112] SDI binarySearchTree1: 
--------------------------------------------------------------------------------
   66:         if self.right:
   67:             rightS = str(self.right)
   68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
   69:     
-  70:     def inorder(self):
-  71:         '''In order traversal generator of tree rooted at given node.'''
-  72:         if self.left:
-  73:             for v in self.left.inorder():
-  74:                 yield v
-  75:         
-  76:         yield self.value
-  77:         
-  78:         if self.right:
-  79:             for v in self.right.inorder():
-  80:                 yield v
-  81: 
+  70:     @staticmethod
+  71:     def inorder(self):
+  72:         '''In order traversal generator of tree rooted at given node.'''
+  73:         if self.left:
+  74:             for v in self.left.inorder():
+  75:                 yield v
+  76:         
+  77:         yield self.value
+  78:         
+  79:         if self.right:
+  80:             for v in self.right.inorder():
+  81:                 yield v
   82: class BinaryTree:
   83:     
   84:     def __init__(self):
   85:         '''Create empty binary tree.'''
--------------------------------------------------------------------------------
[0.16211 s] incompetent

TypeError: /home/auri/temp/lucca/python_experiments/binarySearchTree1/DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_WHOLE_SUITE.py:59: TypeError: BinaryNode.inorder() missing 1 required positional argument: 'self'

   - [# 113] SDI binarySearchTree1: 
--------------------------------------------------------------------------------
   80:                 yield v
   81: 
   82: class BinaryTree:
   83:     
-  84:     def __init__(self):
-  85:         '''Create empty binary tree.'''
-  86:         self.root = None
-  87:     
+  84:     @staticmethod
+  85:     def __init__(self):
+  86:         '''Create empty binary tree.'''
+  87:         self.root = None
   88:     def add(self, value):
   89:         '''Insert value into proper location in Binary Tree.'''
   90:         if self.root is None:
   91:             self.root = BinaryNode(value)
--------------------------------------------------------------------------------
[0.10256 s] incompetent

TypeError: /home/auri/temp/lucca/python_experiments/binarySearchTree1/DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:80: TypeError: BinaryTree.__init__() missing 1 required positional argument: 'self'

   - [# 114] SDI binarySearchTree1: 
--------------------------------------------------------------------------------
   84:     def __init__(self):
   85:         '''Create empty binary tree.'''
   86:         self.root = None
   87:     
-  88:     def add(self, value):
-  89:         '''Insert value into proper location in Binary Tree.'''
-  90:         if self.root is None:
-  91:             self.root = BinaryNode(value)
-  92:         else:
-  93:             self.root.add(value)
-  94:     
+  88:     @staticmethod
+  89:     def add(self, value):
+  90:         '''Insert value into proper location in Binary Tree.'''
+  91:         if self.root is None:
+  92:             self.root = BinaryNode(value)
+  93:         else:
+  94:             self.root.add(value)
   95:     def remove(self, val):
   96:         '''Remove value from tree.'''
   97:         if self.root:
   98:             self.root = self.root.remove(val)
--------------------------------------------------------------------------------
[0.11969 s] incompetent

TypeError: /home/auri/temp/lucca/python_experiments/binarySearchTree1/DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:110: TypeError: BinaryTree.add() missing 1 required positional argument: 'value'

   - [# 115] SDI binarySearchTree1: 
--------------------------------------------------------------------------------
   91:             self.root = BinaryNode(value)
   92:         else:
   93:             self.root.add(value)
   94:     
-  95:     def remove(self, val):
-  96:         '''Remove value from tree.'''
-  97:         if self.root:
-  98:             self.root = self.root.remove(val)
-  99:     
+  95:     @staticmethod
+  96:     def remove(self, val):
+  97:         '''Remove value from tree.'''
+  98:         if self.root:
+  99:             self.root = self.root.remove(val)
  100:     def getMin(self):
  101:         '''Returns minimum value.'''
  102:         if self.root is None:
  103:             raise ValueError('Binary Tree is empty')
--------------------------------------------------------------------------------
[0.11319 s] incompetent

TypeError: /home/auri/temp/lucca/python_experiments/binarySearchTree1/DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:130: TypeError: BinaryTree.remove() missing 1 required positional argument: 'val'

   - [# 116] SDI binarySearchTree1: 
--------------------------------------------------------------------------------
   96:         '''Remove value from tree.'''
   97:         if self.root:
   98:             self.root = self.root.remove(val)
   99:     
- 100:     def getMin(self):
- 101:         '''Returns minimum value.'''
- 102:         if self.root is None:
- 103:             raise ValueError('Binary Tree is empty')
- 104:         n = self.root
- 105:         while n.left != None:
- 106:             n = n.left
- 107:         return n.value
- 108:     
+ 100:     @staticmethod
+ 101:     def getMin(self):
+ 102:         '''Returns minimum value.'''
+ 103:         if self.root is None:
+ 104:             raise ValueError('Binary Tree is empty')
+ 105:         n = self.root
+ 106:         while n.left != None:
+ 107:             n = n.left
+ 108:         return n.value
  109:     def getMax(self):
  110:         '''Returns maximum value.'''
  111:         if self.root is None:
  112:             raise ValueError('Binary Tree is empty')
--------------------------------------------------------------------------------
[0.10606 s] incompetent

TypeError: /home/auri/temp/lucca/python_experiments/binarySearchTree1/DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:142: TypeError: BinaryTree.getMin() missing 1 required positional argument: 'self'

   - [# 117] SDI binarySearchTree1: 
--------------------------------------------------------------------------------
  105:         while n.left != None:
  106:             n = n.left
  107:         return n.value
  108:     
- 109:     def getMax(self):
- 110:         '''Returns maximum value.'''
- 111:         if self.root is None:
- 112:             raise ValueError('Binary Tree is empty')
- 113:         n = self.root
- 114:         while n.right != None:
- 115:             n = n.right
- 116:         return n.value
- 117:     
+ 109:     @staticmethod
+ 110:     def getMax(self):
+ 111:         '''Returns maximum value.'''
+ 112:         if self.root is None:
+ 113:             raise ValueError('Binary Tree is empty')
+ 114:         n = self.root
+ 115:         while n.right != None:
+ 116:             n = n.right
+ 117:         return n.value
  118:     def __contains__(self, target):
  119:         '''Check whether BST contains target value.'''
  120:         node = self.root
  121:         while node:
--------------------------------------------------------------------------------
[0.16479 s] incompetent

TypeError: /home/auri/temp/lucca/python_experiments/binarySearchTree1/DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:162: TypeError: BinaryTree.getMax() missing 1 required positional argument: 'self'

   - [# 118] SDI binarySearchTree1: 
--------------------------------------------------------------------------------
  114:         while n.right != None:
  115:             n = n.right
  116:         return n.value
  117:     
- 118:     def __contains__(self, target):
- 119:         '''Check whether BST contains target value.'''
- 120:         node = self.root
- 121:         while node:
- 122:             if target < node.value:
- 123:                 node = node.left
- 124:             elif target > node.value:
- 125:                 node = node.right
- 126:             else:
- 127:                 return True
- 128:         
- 129:         return False
- 130:     
+ 118:     @staticmethod
+ 119:     def __contains__(self, target):
+ 120:         '''Check whether BST contains target value.'''
+ 121:         node = self.root
+ 122:         while node:
+ 123:             if target < node.value:
+ 124:                 node = node.left
+ 125:             elif target > node.value:
+ 126:                 node = node.right
+ 127:             else:
+ 128:                 return True
+ 129:         
+ 130:         return False
  131:     def closest(self, target):
  132:         '''
  133:         Return value closest to target. If there are several, then
  134:         return one of them.
--------------------------------------------------------------------------------
[0.09879 s] incompetent

TypeError: /home/auri/temp/lucca/python_experiments/binarySearchTree1/DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:176: TypeError: BinaryTree.__contains__() missing 1 required positional argument: 'target'

   - [# 119] SDI binarySearchTree1: 
--------------------------------------------------------------------------------
  127:                 return True
  128:         
  129:         return False
  130:     
- 131:     def closest(self, target):
- 132:         '''
- 133:         Return value closest to target. If there are several, then
- 134:         return one of them.
- 135:         '''
- 136:         if self.root is None:
- 137:             return None
- 138:         
- 139:         best = node = self.root
- 140:         distance = abs(self.root.value - target)
- 141:         while node:
- 142:             if abs(node.value - target) < distance:
- 143:                 distance = abs(node.value - target)
- 144:                 best = node
- 145:             if target < node.value:
- 146:                 node = node.left
- 147:             elif target > node.value:
- 148:                 node = node.right
- 149:             else:
- 150:                 return target
- 151:         
- 152:         return best.value
- 153:     
+ 131:     @staticmethod
+ 132:     def closest(self, target):
+ 133:         '''
+ 134:         Return value closest to target. If there are several, then
+ 135:         return one of them.
+ 136:         '''
+ 137:         if self.root is None:
+ 138:             return None
+ 139:         
+ 140:         best = node = self.root
+ 141:         distance = abs(self.root.value - target)
+ 142:         while node:
+ 143:             if abs(node.value - target) < distance:
+ 144:                 distance = abs(node.value - target)
+ 145:                 best = node
+ 146:             if target < node.value:
+ 147:                 node = node.left
+ 148:             elif target > node.value:
+ 149:                 node = node.right
+ 150:             else:
+ 151:                 return target
+ 152:         
+ 153:         return best.value
  154:     def __iter__(self):
  155:         '''In order traversal of elements in the tree.'''
  156:         if self.root:
  157:             for e in self.root.inorder():
--------------------------------------------------------------------------------
[0.10472 s] incompetent

TypeError: /home/auri/temp/lucca/python_experiments/binarySearchTree1/DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:194: TypeError: BinaryTree.closest() missing 1 required positional argument: 'target'

   - [# 120] SDI binarySearchTree1: 
--------------------------------------------------------------------------------
  150:                 return target
  151:         
  152:         return best.value
  153:     
- 154:     def __iter__(self):
- 155:         '''In order traversal of elements in the tree.'''
- 156:         if self.root:
- 157:             for e in self.root.inorder():
- 158:                 yield e
- 159:     
+ 154:     @staticmethod
+ 155:     def __iter__(self):
+ 156:         '''In order traversal of elements in the tree.'''
+ 157:         if self.root:
+ 158:             for e in self.root.inorder():
+ 159:                 yield e
  160:     def __repr__(self):
  161:         if self.root is None:
  162:             return 'binary:()'
  163:         return 'binary:' + str(self.root)
--------------------------------------------------------------------------------
[0.09394 s] incompetent

TypeError: /home/auri/temp/lucca/python_experiments/binarySearchTree1/DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:140: TypeError: BinaryTree.__iter__() missing 1 required positional argument: 'self'

   - [# 121] SDI binarySearchTree1: 
--------------------------------------------------------------------------------
  156:         if self.root:
  157:             for e in self.root.inorder():
  158:                 yield e
  159:     
- 160:     def __repr__(self):
- 161:         if self.root is None:
- 162:             return 'binary:()'
- 163:         return 'binary:' + str(self.root)
- 164: 
+ 160:     @staticmethod
+ 161:     def __repr__(self):
+ 162:         if self.root is None:
+ 163:             return 'binary:()'
+ 164:         return 'binary:' + str(self.root)
  165: '''
  166: Change Log:
  167: -----------
  168: 
--------------------------------------------------------------------------------
[0.11996 s] incompetent

TypeError: /home/auri/temp/lucca/python_experiments/binarySearchTree1/DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:135: TypeError: BinaryTree.__repr__() missing 1 required positional argument: 'self'

   - [# 122] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
    6: class BinaryNode:
    7:     
    8:     def __init__(self, value):
    9:         '''Create binary node.'''
-  10:         self.value = value
+  10:         pass
   11:         self.left = None
   12:         self.right = None
   13:     
   14:     def add(self, val):
--------------------------------------------------------------------------------
[0.10319 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_0

def test_case_0():
        bool_0 = True
        bool_1 = False
        binary_node_0 = module_0.BinaryNode(bool_1)
>       var_0 = binary_node_0.add(bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:10: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'BinaryNode' object has no attribute 'value'") raised in repr()] BinaryNode object at 0x7fa525349780>
val = True

>   ???
E   AttributeError: 'BinaryNode' object has no attribute 'value'

binarySearchTree1:18: AttributeError
   - [# 123] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
    7:     
    8:     def __init__(self, value):
    9:         '''Create binary node.'''
   10:         self.value = value
-  11:         self.left = None
+  11:         pass
   12:         self.right = None
   13:     
   14:     def add(self, val):
   15:         '''
--------------------------------------------------------------------------------
[0.09596 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_1

def test_case_1():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
>       var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree1:28: in addToSubTree
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'BinaryNode' object has no attribute 'left'") raised in repr()] BinaryNode object at 0x7fa524ff8730>
val = False

>   ???
E   AttributeError: 'BinaryNode' object has no attribute 'left'

binarySearchTree1:19: AttributeError
   - [# 124] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
    8:     def __init__(self, value):
    9:         '''Create binary node.'''
   10:         self.value = value
   11:         self.left = None
-  12:         self.right = None
+  12:         pass
   13:     
   14:     def add(self, val):
   15:         '''
   16:         Add a new node to the tree with value. Respond based on Set semantics
--------------------------------------------------------------------------------
[0.11930 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_0

def test_case_0():
        bool_0 = True
        bool_1 = False
        binary_node_0 = module_0.BinaryNode(bool_1)
>       var_0 = binary_node_0.add(bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:10: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'BinaryNode' object has no attribute 'right'") raised in repr()] BinaryNode object at 0x7fa5252f3070>
val = True

>   ???
E   AttributeError: 'BinaryNode' object has no attribute 'right'

binarySearchTree1:21: AttributeError
   - [# 125] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   15:         '''
   16:         Add a new node to the tree with value. Respond based on Set semantics
   17:         '''
   18:         if val <= self.value:
-  19:             self.left = self.addToSubTree(self.left, val)
+  19:             pass
   20:         elif val > self.value:
   21:             self.right = self.addToSubTree(self.right, val)
   22:     
   23:     def addToSubTree(self, parent, val):
--------------------------------------------------------------------------------
[0.09705 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_1

def test_case_1():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
>       assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:17: AssertionError
   - [# 126] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   17:         '''
   18:         if val <= self.value:
   19:             self.left = self.addToSubTree(self.left, val)
   20:         elif val > self.value:
-  21:             self.right = self.addToSubTree(self.right, val)
+  21:             pass
   22:     
   23:     def addToSubTree(self, parent, val):
   24:         '''Add val to parent subtree (if exists) and return root of that subtree.'''
   25:         if parent is None:
--------------------------------------------------------------------------------
[0.08988 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_0

def test_case_0():
        bool_0 = True
        bool_1 = False
        binary_node_0 = module_0.BinaryNode(bool_1)
        var_0 = binary_node_0.add(bool_0)
>       assert f'{type(binary_node_0.right).__module__}.{type(binary_node_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:11: AssertionError
   - [# 127] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   22:     
   23:     def addToSubTree(self, parent, val):
   24:         '''Add val to parent subtree (if exists) and return root of that subtree.'''
   25:         if parent is None:
-  26:             return BinaryNode(val)
+  26:             pass
   27:         
   28:         parent.add(val)
   29:         return parent
   30:     
--------------------------------------------------------------------------------
[0.12285 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_0

def test_case_0():
        bool_0 = True
        bool_1 = False
        binary_node_0 = module_0.BinaryNode(bool_1)
>       var_0 = binary_node_0.add(bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:10: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree1:21: in add
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (L: False R:), parent = None, val = True

>   ???
E   AttributeError: 'NoneType' object has no attribute 'add'

binarySearchTree1:28: AttributeError
   - [# 128] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   24:         '''Add val to parent subtree (if exists) and return root of that subtree.'''
   25:         if parent is None:
   26:             return BinaryNode(val)
   27:         
-  28:         parent.add(val)
+  28:         pass
   29:         return parent
   30:     
   31:     def remove(self, val):
   32:         '''
--------------------------------------------------------------------------------
[0.09777 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_1

def test_case_1():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
>       assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:17: AssertionError
   - [# 129] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   25:         if parent is None:
   26:             return BinaryNode(val)
   27:         
   28:         parent.add(val)
-  29:         return parent
+  29:         pass
   30:     
   31:     def remove(self, val):
   32:         '''
   33:          Remove val of self from BinaryTree. 
--------------------------------------------------------------------------------
[0.11448 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_1

def test_case_1():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
E       AttributeError: 'NoneType' object has no attribute 'left'

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:18: AttributeError
   - [# 130] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   32:         '''
   33:          Remove val of self from BinaryTree. 
   34:         '''
   35:         if val < self.value:
-  36:             self.left = self.removeFromParent(self.left, val)
+  36:             pass
   37:         elif val > self.value:
   38:             self.right = self.removeFromParent(self.right, val)
   39:         else:
   40:             if self.left is None:
--------------------------------------------------------------------------------
[0.11540 s] survived
   - [# 131] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   34:         '''
   35:         if val < self.value:
   36:             self.left = self.removeFromParent(self.left, val)
   37:         elif val > self.value:
-  38:             self.right = self.removeFromParent(self.right, val)
+  38:             pass
   39:         else:
   40:             if self.left is None:
   41:                 return self.right
   42:             
--------------------------------------------------------------------------------
[0.15504 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py::test_case_28

def test_case_28():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.closest(binary_tree_0)
        var_1 = binary_tree_0.__contains__(var_0)
        assert var_1 is False
        int_0 = 3380
        var_2 = binary_tree_0.add(int_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = binary_tree_0.add(var_1)
        var_4 = binary_tree_0.__contains__(var_1)
        assert var_4 is True
        var_5 = binary_tree_0.add(var_4)
        var_6 = binary_tree_0.getMax()
        assert var_6 == 3380
        var_7 = binary_tree_0.closest(var_6)
        var_8 = var_3.__repr__()
        var_9 = binary_tree_0.add(var_7)
        var_10 = binary_tree_0.remove(var_7)
        var_11 = binary_tree_0.__repr__()
>       assert var_11 == 'binary:(L:(L: False R:(L: True R:)) 3380 R:)'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py:357: AssertionError
   - [# 132] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   37:         elif val > self.value:
   38:             self.right = self.removeFromParent(self.right, val)
   39:         else:
   40:             if self.left is None:
-  41:                 return self.right
+  41:                 pass
   42:             
   43:             child = self.left
   44:             while child.right:
   45:                 child = child.right
--------------------------------------------------------------------------------
[0.10686 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_3

def test_case_3():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
>       var_0 = binary_node_0.removeFromParent(binary_node_0, bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree1:57: in removeFromParent
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (L: False R:), val = False

>   ???
E   AttributeError: 'NoneType' object has no attribute 'right'

binarySearchTree1:44: AttributeError
   - [# 133] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   39:         else:
   40:             if self.left is None:
   41:                 return self.right
   42:             
-  43:             child = self.left
+  43:             pass
   44:             while child.right:
   45:                 child = child.right
   46:             
   47:             childKey = child.value
--------------------------------------------------------------------------------
[0.11128 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_4

def test_case_4():
        bool_0 = True
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_1 = var_0.removeFromParent(binary_node_0, bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree1:57: in removeFromParent
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (L:(L: True R:) True R:), val = True

>   ???
E   UnboundLocalError: local variable 'child' referenced before assignment

binarySearchTree1:44: UnboundLocalError
   - [# 134] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   41:                 return self.right
   42:             
   43:             child = self.left
   44:             while child.right:
-  45:                 child = child.right
+  45:                 pass
   46:             
   47:             childKey = child.value
   48:             self.left = self.removeFromParent(self.left, childKey)
   49:             self.value = childKey
--------------------------------------------------------------------------------
[5.00651 s] timeout
   - [# 135] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   43:             child = self.left
   44:             while child.right:
   45:                 child = child.right
   46:             
-  47:             childKey = child.value
+  47:             pass
   48:             self.left = self.removeFromParent(self.left, childKey)
   49:             self.value = childKey
   50:         
   51:         return self
--------------------------------------------------------------------------------
[0.08983 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_4

def test_case_4():
        bool_0 = True
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_1 = var_0.removeFromParent(binary_node_0, bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree1:57: in removeFromParent
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (L:(L: True R:) True R:), val = True

>   ???
E   NameError: name 'childKey' is not defined

binarySearchTree1:48: NameError
   - [# 136] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   44:             while child.right:
   45:                 child = child.right
   46:             
   47:             childKey = child.value
-  48:             self.left = self.removeFromParent(self.left, childKey)
+  48:             pass
   49:             self.value = childKey
   50:         
   51:         return self
   52:     
--------------------------------------------------------------------------------
[0.09264 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_4

def test_case_4():
        bool_0 = True
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = var_0.removeFromParent(binary_node_0, bool_0)
>       assert binary_node_0.left is None
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:42: AssertionError
   - [# 137] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   45:                 child = child.right
   46:             
   47:             childKey = child.value
   48:             self.left = self.removeFromParent(self.left, childKey)
-  49:             self.value = childKey
+  49:             pass
   50:         
   51:         return self
   52:     
   53:     def removeFromParent(self, parent, val):
--------------------------------------------------------------------------------
[0.13233 s] survived
   - [# 138] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   47:             childKey = child.value
   48:             self.left = self.removeFromParent(self.left, childKey)
   49:             self.value = childKey
   50:         
-  51:         return self
+  51:         pass
   52:     
   53:     def removeFromParent(self, parent, val):
   54:         '''Helper method for remove. Ensures proper behavior when removing node that 
   55:         has children.'''
--------------------------------------------------------------------------------
[0.09934 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_2

def test_case_2():
        bool_0 = True
        bool_1 = False
        binary_node_0 = module_0.BinaryNode(bool_1)
        var_0 = binary_node_0.remove(bool_0)
>       assert f'{type(var_0).__module__}.{type(var_0).__qualname__}' == 'binarySearchTree1.BinaryNode'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:25: AssertionError
   - [# 139] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   53:     def removeFromParent(self, parent, val):
   54:         '''Helper method for remove. Ensures proper behavior when removing node that 
   55:         has children.'''
   56:         if parent:
-  57:             return parent.remove(val)
+  57:             pass
   58:         return None
   59:     
   60:     def __repr__(self):
   61:         '''Useful debugging function to produce linear tree representation.'''
--------------------------------------------------------------------------------
[0.08811 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_4

def test_case_4():
        bool_0 = True
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = var_0.removeFromParent(binary_node_0, bool_0)
>       assert binary_node_0.left is None
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:42: AssertionError
   - [# 140] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   54:         '''Helper method for remove. Ensures proper behavior when removing node that 
   55:         has children.'''
   56:         if parent:
   57:             return parent.remove(val)
-  58:         return None
+  58:         pass
   59:     
   60:     def __repr__(self):
   61:         '''Useful debugging function to produce linear tree representation.'''
   62:         leftS = ''
--------------------------------------------------------------------------------
[0.10733 s] survived
   - [# 141] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   58:         return None
   59:     
   60:     def __repr__(self):
   61:         '''Useful debugging function to produce linear tree representation.'''
-  62:         leftS = ''
+  62:         pass
   63:         rightS = ''
   64:         if self.left:
   65:             leftS = str(self.left)
   66:         if self.right:
--------------------------------------------------------------------------------
[0.08924 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_7

def test_case_7():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_node_0.removeFromParent(binary_node_0, bool_0)
        assert binary_node_0.left is None
        assert var_0.left is None
        assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_1.value is False
        assert var_1.left is None
        assert var_1.right is None
        bool_1 = True
        binary_tree_0 = module_0.BinaryTree()
        var_2 = var_0.addToSubTree(var_0, bool_1)
        assert f'{type(binary_node_0.right).__module__}.{type(binary_node_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.right).__module__}.{type(var_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_1.right).__module__}.{type(var_1.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_2.value is False
        assert var_2.left is None
        assert f'{type(var_2.right).__module__}.{type(var_2.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_3 = var_0.__repr__()

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree1:67: in __repr__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[UnboundLocalError("local variable 'leftS' referenced before assignment") raised in repr()] BinaryNode object at 0x7fa525152b30>

>   ???
E   UnboundLocalError: local variable 'leftS' referenced before assignment

binarySearchTree1:68: UnboundLocalError
   - [# 142] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   59:     
   60:     def __repr__(self):
   61:         '''Useful debugging function to produce linear tree representation.'''
   62:         leftS = ''
-  63:         rightS = ''
+  63:         pass
   64:         if self.left:
   65:             leftS = str(self.left)
   66:         if self.right:
   67:             rightS = str(self.right)
--------------------------------------------------------------------------------
[0.09370 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_7

def test_case_7():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_node_0.removeFromParent(binary_node_0, bool_0)
        assert binary_node_0.left is None
        assert var_0.left is None
        assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_1.value is False
        assert var_1.left is None
        assert var_1.right is None
        bool_1 = True
        binary_tree_0 = module_0.BinaryTree()
        var_2 = var_0.addToSubTree(var_0, bool_1)
        assert f'{type(binary_node_0.right).__module__}.{type(binary_node_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.right).__module__}.{type(var_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_1.right).__module__}.{type(var_1.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_2.value is False
        assert var_2.left is None
        assert f'{type(var_2.right).__module__}.{type(var_2.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_3 = var_0.__repr__()

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree1:67: in __repr__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[UnboundLocalError("local variable 'rightS' referenced before assignment") raised in repr()] BinaryNode object at 0x7fa525085060>

>   ???
E   UnboundLocalError: local variable 'rightS' referenced before assignment

binarySearchTree1:68: UnboundLocalError
   - [# 143] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   61:         '''Useful debugging function to produce linear tree representation.'''
   62:         leftS = ''
   63:         rightS = ''
   64:         if self.left:
-  65:             leftS = str(self.left)
+  65:             pass
   66:         if self.right:
   67:             rightS = str(self.right)
   68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
   69:     
--------------------------------------------------------------------------------
[0.09474 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_9

def test_case_9():
        bool_0 = True
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = var_0.__repr__()
>       assert var_1 == '(L:(L: True R:) True R:)'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:106: AssertionError
   - [# 144] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   63:         rightS = ''
   64:         if self.left:
   65:             leftS = str(self.left)
   66:         if self.right:
-  67:             rightS = str(self.right)
+  67:             pass
   68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
   69:     
   70:     def inorder(self):
   71:         '''In order traversal generator of tree rooted at given node.'''
--------------------------------------------------------------------------------
[0.10064 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_7

def test_case_7():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_node_0.removeFromParent(binary_node_0, bool_0)
        assert binary_node_0.left is None
        assert var_0.left is None
        assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_1.value is False
        assert var_1.left is None
        assert var_1.right is None
        bool_1 = True
        binary_tree_0 = module_0.BinaryTree()
        var_2 = var_0.addToSubTree(var_0, bool_1)
        assert f'{type(binary_node_0.right).__module__}.{type(binary_node_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.right).__module__}.{type(var_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_1.right).__module__}.{type(var_1.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_2.value is False
        assert var_2.left is None
        assert f'{type(var_2.right).__module__}.{type(var_2.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = var_0.__repr__()
>       assert var_3 == '(L: False R:(L: True R:))'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:89: AssertionError
   - [# 145] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   64:         if self.left:
   65:             leftS = str(self.left)
   66:         if self.right:
   67:             rightS = str(self.right)
-  68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
+  68:         pass
   69:     
   70:     def inorder(self):
   71:         '''In order traversal generator of tree rooted at given node.'''
   72:         if self.left:
--------------------------------------------------------------------------------
[0.09581 s] incompetent

TypeError: binarySearchTree1:67: TypeError: __str__ returned non-string (type NoneType)

   - [# 146] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   70:     def inorder(self):
   71:         '''In order traversal generator of tree rooted at given node.'''
   72:         if self.left:
   73:             for v in self.left.inorder():
-  74:                 yield v
+  74:                 pass
   75:         
   76:         yield self.value
   77:         
   78:         if self.right:
--------------------------------------------------------------------------------
[0.14868 s] survived
   - [# 147] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   72:         if self.left:
   73:             for v in self.left.inorder():
   74:                 yield v
   75:         
-  76:         yield self.value
+  76:         pass
   77:         
   78:         if self.right:
   79:             for v in self.right.inorder():
   80:                 yield v
--------------------------------------------------------------------------------
[0.11146 s] survived
   - [# 148] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   76:         yield self.value
   77:         
   78:         if self.right:
   79:             for v in self.right.inorder():
-  80:                 yield v
+  80:                 pass
   81: 
   82: class BinaryTree:
   83:     
   84:     def __init__(self):
--------------------------------------------------------------------------------
[0.11449 s] survived
   - [# 149] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   82: class BinaryTree:
   83:     
   84:     def __init__(self):
   85:         '''Create empty binary tree.'''
-  86:         self.root = None
+  86:         pass
   87:     
   88:     def add(self, value):
   89:         '''Insert value into proper location in Binary Tree.'''
   90:         if self.root is None:
--------------------------------------------------------------------------------
[0.09623 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_10

def test_case_10():
        binary_tree_0 = module_0.BinaryTree()
>       var_0 = binary_tree_0.add(binary_tree_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:110: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'BinaryTree' object has no attribute 'root'") raised in repr()] BinaryTree object at 0x7fa524f97f10>
value = <[AttributeError("'BinaryTree' object has no attribute 'root'") raised in repr()] BinaryTree object at 0x7fa524f97f10>

>   ???
E   AttributeError: 'BinaryTree' object has no attribute 'root'

binarySearchTree1:90: AttributeError
   - [# 150] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   87:     
   88:     def add(self, value):
   89:         '''Insert value into proper location in Binary Tree.'''
   90:         if self.root is None:
-  91:             self.root = BinaryNode(value)
+  91:             pass
   92:         else:
   93:             self.root.add(value)
   94:     
   95:     def remove(self, val):
--------------------------------------------------------------------------------
[0.12459 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_10

def test_case_10():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.add(binary_tree_0)
>       assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:111: AssertionError
   - [# 151] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   89:         '''Insert value into proper location in Binary Tree.'''
   90:         if self.root is None:
   91:             self.root = BinaryNode(value)
   92:         else:
-  93:             self.root.add(value)
+  93:             pass
   94:     
   95:     def remove(self, val):
   96:         '''Remove value from tree.'''
   97:         if self.root:
--------------------------------------------------------------------------------
[0.13247 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py::test_case_9

def test_case_9():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.remove(binary_tree_0)
        var_1 = binary_tree_0.__contains__(var_0)
        assert var_1 is False
        var_2 = binary_tree_0.add(var_1)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = binary_tree_0.add(var_1)
        var_4 = binary_tree_0.__repr__()
>       assert var_4 == 'binary:(L:(L: False R:) False R:)'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py:77: AssertionError
   - [# 152] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
   94:     
   95:     def remove(self, val):
   96:         '''Remove value from tree.'''
   97:         if self.root:
-  98:             self.root = self.root.remove(val)
+  98:             pass
   99:     
  100:     def getMin(self):
  101:         '''Returns minimum value.'''
  102:         if self.root is None:
--------------------------------------------------------------------------------
[0.16652 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py::test_case_17

def test_case_17():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.__contains__(binary_tree_0)
        assert var_0 is False
        var_1 = binary_tree_0.add(var_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_2 = binary_tree_0.__contains__(var_0)
        assert var_2 is True
        var_3 = binary_tree_0.getMax()
        assert var_3 is False
        var_4 = var_1.__repr__()
        var_5 = binary_tree_0.__contains__(var_2)
        assert var_5 is False
        var_6 = binary_tree_0.add(var_5)
        var_7 = binary_tree_0.remove(var_3)
        var_8 = binary_tree_0.__repr__()
>       assert var_8 == 'binary:(L: False R:)'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py:174: AssertionError
   - [# 153] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
  100:     def getMin(self):
  101:         '''Returns minimum value.'''
  102:         if self.root is None:
  103:             raise ValueError('Binary Tree is empty')
- 104:         n = self.root
+ 104:         pass
  105:         while n.left != None:
  106:             n = n.left
  107:         return n.value
  108:     
--------------------------------------------------------------------------------
[0.10103 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_15

def test_case_15():
        binary_tree_0 = module_0.BinaryTree()
        binary_tree_1 = module_0.BinaryTree()
        var_0 = binary_tree_0.__repr__()
        assert var_0 == 'binary:()'
        var_1 = binary_tree_0.add(var_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_2 = binary_tree_0.add(var_0)
        var_3 = binary_tree_0.__iter__()
        var_4 = var_3.__repr__()
>       var_5 = binary_tree_0.getMin()

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = binary:(L:(L: binary:() R:) binary:() R:)

>   ???
E   UnboundLocalError: local variable 'n' referenced before assignment

binarySearchTree1:105: UnboundLocalError
   - [# 154] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
  102:         if self.root is None:
  103:             raise ValueError('Binary Tree is empty')
  104:         n = self.root
  105:         while n.left != None:
- 106:             n = n.left
+ 106:             pass
  107:         return n.value
  108:     
  109:     def getMax(self):
  110:         '''Returns maximum value.'''
--------------------------------------------------------------------------------
[5.00643 s] timeout
   - [# 155] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
  103:             raise ValueError('Binary Tree is empty')
  104:         n = self.root
  105:         while n.left != None:
  106:             n = n.left
- 107:         return n.value
+ 107:         pass
  108:     
  109:     def getMax(self):
  110:         '''Returns maximum value.'''
  111:         if self.root is None:
--------------------------------------------------------------------------------
[0.09655 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_15

def test_case_15():
        binary_tree_0 = module_0.BinaryTree()
        binary_tree_1 = module_0.BinaryTree()
        var_0 = binary_tree_0.__repr__()
        assert var_0 == 'binary:()'
        var_1 = binary_tree_0.add(var_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_2 = binary_tree_0.add(var_0)
        var_3 = binary_tree_0.__iter__()
        var_4 = var_3.__repr__()
        var_5 = binary_tree_0.getMin()
>       assert var_5 == 'binary:()'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:143: AssertionError
   - [# 156] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
  109:     def getMax(self):
  110:         '''Returns maximum value.'''
  111:         if self.root is None:
  112:             raise ValueError('Binary Tree is empty')
- 113:         n = self.root
+ 113:         pass
  114:         while n.right != None:
  115:             n = n.right
  116:         return n.value
  117:     
--------------------------------------------------------------------------------
[0.10013 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_18

def test_case_18():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.add(binary_tree_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_1 = binary_tree_0.getMax()

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[RecursionError('maximum recursion depth exceeded while getting the str of an object') raised in repr()] BinaryTree object at 0x7fa524eb1690>

>   ???
E   UnboundLocalError: local variable 'n' referenced before assignment

binarySearchTree1:114: UnboundLocalError
   - [# 157] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
  111:         if self.root is None:
  112:             raise ValueError('Binary Tree is empty')
  113:         n = self.root
  114:         while n.right != None:
- 115:             n = n.right
+ 115:             pass
  116:         return n.value
  117:     
  118:     def __contains__(self, target):
  119:         '''Check whether BST contains target value.'''
--------------------------------------------------------------------------------
[5.00562 s] timeout
   - [# 158] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
  112:             raise ValueError('Binary Tree is empty')
  113:         n = self.root
  114:         while n.right != None:
  115:             n = n.right
- 116:         return n.value
+ 116:         pass
  117:     
  118:     def __contains__(self, target):
  119:         '''Check whether BST contains target value.'''
  120:         node = self.root
--------------------------------------------------------------------------------
[0.13242 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_18

def test_case_18():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.add(binary_tree_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_tree_0.getMax()
>       assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'binarySearchTree1.BinaryTree'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:163: AssertionError
   - [# 159] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
  116:         return n.value
  117:     
  118:     def __contains__(self, target):
  119:         '''Check whether BST contains target value.'''
- 120:         node = self.root
+ 120:         pass
  121:         while node:
  122:             if target < node.value:
  123:                 node = node.left
  124:             elif target > node.value:
--------------------------------------------------------------------------------
[0.10718 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_20

def test_case_20():
        binary_tree_0 = module_0.BinaryTree()
        set_0 = {binary_tree_0}
        var_0 = binary_tree_0.add(set_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_1 = binary_tree_0.__contains__(set_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = binary:(L: {binary:(L: set(...) R:)} R:)
target = {binary:(L: {binary:(L: set(...) R:)} R:)}

>   ???
E   UnboundLocalError: local variable 'node' referenced before assignment

binarySearchTree1:121: UnboundLocalError
   - [# 160] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
  119:         '''Check whether BST contains target value.'''
  120:         node = self.root
  121:         while node:
  122:             if target < node.value:
- 123:                 node = node.left
+ 123:                 pass
  124:             elif target > node.value:
  125:                 node = node.right
  126:             else:
  127:                 return True
--------------------------------------------------------------------------------
[5.00648 s] timeout
   - [# 161] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
  121:         while node:
  122:             if target < node.value:
  123:                 node = node.left
  124:             elif target > node.value:
- 125:                 node = node.right
+ 125:                 pass
  126:             else:
  127:                 return True
  128:         
  129:         return False
--------------------------------------------------------------------------------
[5.00344 s] timeout
   - [# 162] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
  123:                 node = node.left
  124:             elif target > node.value:
  125:                 node = node.right
  126:             else:
- 127:                 return True
+ 127:                 pass
  128:         
  129:         return False
  130:     
  131:     def closest(self, target):
--------------------------------------------------------------------------------
[5.00379 s] timeout
   - [# 163] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
  125:                 node = node.right
  126:             else:
  127:                 return True
  128:         
- 129:         return False
+ 129:         pass
  130:     
  131:     def closest(self, target):
  132:         '''
  133:         Return value closest to target. If there are several, then
--------------------------------------------------------------------------------
[0.11286 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_22

def test_case_22():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.__contains__(binary_tree_0)
>       assert var_0 is False
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:187: AssertionError
   - [# 164] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
  133:         Return value closest to target. If there are several, then
  134:         return one of them.
  135:         '''
  136:         if self.root is None:
- 137:             return None
+ 137:             pass
  138:         
  139:         best = node = self.root
  140:         distance = abs(self.root.value - target)
  141:         while node:
--------------------------------------------------------------------------------
[0.10938 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_24

def test_case_24():
        binary_tree_0 = module_0.BinaryTree()
>       var_0 = binary_tree_0.closest(binary_tree_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = binary:(), target = binary:()

>   ???
E   AttributeError: 'NoneType' object has no attribute 'value'

binarySearchTree1:140: AttributeError
   - [# 165] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
  135:         '''
  136:         if self.root is None:
  137:             return None
  138:         
- 139:         best = node = self.root
+ 139:         pass
  140:         distance = abs(self.root.value - target)
  141:         while node:
  142:             if abs(node.value - target) < distance:
  143:                 distance = abs(node.value - target)
--------------------------------------------------------------------------------
[0.13045 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_23

def test_case_23():
        bool_0 = True
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.add(bool_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_1 = binary_tree_0.closest(bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = binary:(L: True R:), target = True

>   ???
E   UnboundLocalError: local variable 'node' referenced before assignment

binarySearchTree1:141: UnboundLocalError
   - [# 166] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
  136:         if self.root is None:
  137:             return None
  138:         
  139:         best = node = self.root
- 140:         distance = abs(self.root.value - target)
+ 140:         pass
  141:         while node:
  142:             if abs(node.value - target) < distance:
  143:                 distance = abs(node.value - target)
  144:                 best = node
--------------------------------------------------------------------------------
[0.12830 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_23

def test_case_23():
        bool_0 = True
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.add(bool_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_1 = binary_tree_0.closest(bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = binary:(L: True R:), target = True

>   ???
E   UnboundLocalError: local variable 'distance' referenced before assignment

binarySearchTree1:142: UnboundLocalError
   - [# 167] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
  139:         best = node = self.root
  140:         distance = abs(self.root.value - target)
  141:         while node:
  142:             if abs(node.value - target) < distance:
- 143:                 distance = abs(node.value - target)
+ 143:                 pass
  144:                 best = node
  145:             if target < node.value:
  146:                 node = node.left
  147:             elif target > node.value:
--------------------------------------------------------------------------------
[0.11323 s] survived
   - [# 168] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
  140:         distance = abs(self.root.value - target)
  141:         while node:
  142:             if abs(node.value - target) < distance:
  143:                 distance = abs(node.value - target)
- 144:                 best = node
+ 144:                 pass
  145:             if target < node.value:
  146:                 node = node.left
  147:             elif target > node.value:
  148:                 node = node.right
--------------------------------------------------------------------------------
[0.11243 s] survived
   - [# 169] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
  142:             if abs(node.value - target) < distance:
  143:                 distance = abs(node.value - target)
  144:                 best = node
  145:             if target < node.value:
- 146:                 node = node.left
+ 146:                 pass
  147:             elif target > node.value:
  148:                 node = node.right
  149:             else:
  150:                 return target
--------------------------------------------------------------------------------
[5.00366 s] timeout
   - [# 170] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
  144:                 best = node
  145:             if target < node.value:
  146:                 node = node.left
  147:             elif target > node.value:
- 148:                 node = node.right
+ 148:                 pass
  149:             else:
  150:                 return target
  151:         
  152:         return best.value
--------------------------------------------------------------------------------
[5.00656 s] timeout
   - [# 171] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
  146:                 node = node.left
  147:             elif target > node.value:
  148:                 node = node.right
  149:             else:
- 150:                 return target
+ 150:                 pass
  151:         
  152:         return best.value
  153:     
  154:     def __iter__(self):
--------------------------------------------------------------------------------
[5.00644 s] timeout
   - [# 172] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
  148:                 node = node.right
  149:             else:
  150:                 return target
  151:         
- 152:         return best.value
+ 152:         pass
  153:     
  154:     def __iter__(self):
  155:         '''In order traversal of elements in the tree.'''
  156:         if self.root:
--------------------------------------------------------------------------------
[0.11602 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_WHOLE_SUITE.py::test_case_13

def test_case_13():
        bool_0 = True
        binary_node_0 = module_0.BinaryNode(bool_0)
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.add(bool_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        none_type_0 = None
        bool_1 = False
        var_1 = binary_tree_0.__contains__(bool_1)
        assert var_1 is False
        bool_2 = False
        set_0 = {bool_2}
        var_2 = binary_tree_0.getMax()
        assert var_2 is True
        var_3 = binary_tree_0.closest(bool_2)
>       assert var_3 is True
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_WHOLE_SUITE.py:139: AssertionError
   - [# 173] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
  154:     def __iter__(self):
  155:         '''In order traversal of elements in the tree.'''
  156:         if self.root:
  157:             for e in self.root.inorder():
- 158:                 yield e
+ 158:                 pass
  159:     
  160:     def __repr__(self):
  161:         if self.root is None:
  162:             return 'binary:()'
--------------------------------------------------------------------------------
[0.10390 s] incompetent

TypeError: /home/auri/temp/lucca/python_experiments/binarySearchTree1/DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:208: TypeError: iter() returned non-iterator of type 'NoneType'

   - [# 174] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
  158:                 yield e
  159:     
  160:     def __repr__(self):
  161:         if self.root is None:
- 162:             return 'binary:()'
+ 162:             pass
  163:         return 'binary:' + str(self.root)
  164: 
  165: '''
  166: Change Log:
--------------------------------------------------------------------------------
[0.09152 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_15

def test_case_15():
        binary_tree_0 = module_0.BinaryTree()
        binary_tree_1 = module_0.BinaryTree()
        var_0 = binary_tree_0.__repr__()
>       assert var_0 == 'binary:()'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:136: AssertionError
   - [# 175] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
  159:     
  160:     def __repr__(self):
  161:         if self.root is None:
  162:             return 'binary:()'
- 163:         return 'binary:' + str(self.root)
+ 163:         pass
  164: 
  165: '''
  166: Change Log:
  167: -----------
--------------------------------------------------------------------------------
[0.12673 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py::test_case_9

def test_case_9():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.remove(binary_tree_0)
        var_1 = binary_tree_0.__contains__(var_0)
        assert var_1 is False
        var_2 = binary_tree_0.add(var_1)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = binary_tree_0.add(var_1)
        var_4 = binary_tree_0.__repr__()
>       assert var_4 == 'binary:(L:(L: False R:) False R:)'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py:77: AssertionError
   - [# 176] SDL binarySearchTree1: 
--------------------------------------------------------------------------------
  161:         if self.root is None:
  162:             return 'binary:()'
  163:         return 'binary:' + str(self.root)
  164: 
- 165: '''
- 166: Change Log:
- 167: -----------
- 168: 
- 169: '''
+ 165: pass
--------------------------------------------------------------------------------
[0.11756 s] survived
   - [# 177] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
    6: class BinaryNode:
    7:     
    8:     def __init__(self, value):
    9:         '''Create binary node.'''
-  10:         self.value = value
+  10:         value = value
   11:         self.left = None
   12:         self.right = None
   13:     
   14:     def add(self, val):
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 178] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
    7:     
    8:     def __init__(self, value):
    9:         '''Create binary node.'''
   10:         self.value = value
-  11:         self.left = None
+  11:         left = None
   12:         self.right = None
   13:     
   14:     def add(self, val):
   15:         '''
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 179] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
    8:     def __init__(self, value):
    9:         '''Create binary node.'''
   10:         self.value = value
   11:         self.left = None
-  12:         self.right = None
+  12:         right = None
   13:     
   14:     def add(self, val):
   15:         '''
   16:         Add a new node to the tree with value. Respond based on Set semantics
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 180] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   14:     def add(self, val):
   15:         '''
   16:         Add a new node to the tree with value. Respond based on Set semantics
   17:         '''
-  18:         if val <= self.value:
+  18:         if val <= value:
   19:             self.left = self.addToSubTree(self.left, val)
   20:         elif val > self.value:
   21:             self.right = self.addToSubTree(self.right, val)
   22:     
--------------------------------------------------------------------------------
[0.08722 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_0

def test_case_0():
        bool_0 = True
        bool_1 = False
        binary_node_0 = module_0.BinaryNode(bool_1)
>       var_0 = binary_node_0.add(bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:10: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (L: False R:), val = True

>   ???
E   NameError: name 'value' is not defined

binarySearchTree1:18: NameError
   - [# 181] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   15:         '''
   16:         Add a new node to the tree with value. Respond based on Set semantics
   17:         '''
   18:         if val <= self.value:
-  19:             self.left = self.addToSubTree(self.left, val)
+  19:             left = self.addToSubTree(self.left, val)
   20:         elif val > self.value:
   21:             self.right = self.addToSubTree(self.right, val)
   22:     
   23:     def addToSubTree(self, parent, val):
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 182] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   15:         '''
   16:         Add a new node to the tree with value. Respond based on Set semantics
   17:         '''
   18:         if val <= self.value:
-  19:             self.left = self.addToSubTree(self.left, val)
+  19:             self.left = addToSubTree(self.left, val)
   20:         elif val > self.value:
   21:             self.right = self.addToSubTree(self.right, val)
   22:     
   23:     def addToSubTree(self, parent, val):
--------------------------------------------------------------------------------
[0.08783 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_1

def test_case_1():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
>       var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree1:28: in addToSubTree
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (L: False R:), val = False

>   ???
E   NameError: name 'addToSubTree' is not defined

binarySearchTree1:19: NameError
   - [# 183] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   15:         '''
   16:         Add a new node to the tree with value. Respond based on Set semantics
   17:         '''
   18:         if val <= self.value:
-  19:             self.left = self.addToSubTree(self.left, val)
+  19:             self.left = self.addToSubTree(left, val)
   20:         elif val > self.value:
   21:             self.right = self.addToSubTree(self.right, val)
   22:     
   23:     def addToSubTree(self, parent, val):
--------------------------------------------------------------------------------
[0.08556 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_1

def test_case_1():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
>       var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree1:28: in addToSubTree
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (L: False R:), val = False

>   ???
E   NameError: name 'left' is not defined

binarySearchTree1:19: NameError
   - [# 184] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   16:         Add a new node to the tree with value. Respond based on Set semantics
   17:         '''
   18:         if val <= self.value:
   19:             self.left = self.addToSubTree(self.left, val)
-  20:         elif val > self.value:
+  20:         elif val > value:
   21:             self.right = self.addToSubTree(self.right, val)
   22:     
   23:     def addToSubTree(self, parent, val):
   24:         '''Add val to parent subtree (if exists) and return root of that subtree.'''
--------------------------------------------------------------------------------
[0.08648 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_0

def test_case_0():
        bool_0 = True
        bool_1 = False
        binary_node_0 = module_0.BinaryNode(bool_1)
>       var_0 = binary_node_0.add(bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:10: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (L: False R:), val = True

>   ???
E   NameError: name 'value' is not defined

binarySearchTree1:20: NameError
   - [# 185] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   17:         '''
   18:         if val <= self.value:
   19:             self.left = self.addToSubTree(self.left, val)
   20:         elif val > self.value:
-  21:             self.right = self.addToSubTree(self.right, val)
+  21:             right = self.addToSubTree(self.right, val)
   22:     
   23:     def addToSubTree(self, parent, val):
   24:         '''Add val to parent subtree (if exists) and return root of that subtree.'''
   25:         if parent is None:
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 186] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   17:         '''
   18:         if val <= self.value:
   19:             self.left = self.addToSubTree(self.left, val)
   20:         elif val > self.value:
-  21:             self.right = self.addToSubTree(self.right, val)
+  21:             self.right = addToSubTree(self.right, val)
   22:     
   23:     def addToSubTree(self, parent, val):
   24:         '''Add val to parent subtree (if exists) and return root of that subtree.'''
   25:         if parent is None:
--------------------------------------------------------------------------------
[0.08700 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_0

def test_case_0():
        bool_0 = True
        bool_1 = False
        binary_node_0 = module_0.BinaryNode(bool_1)
>       var_0 = binary_node_0.add(bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:10: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (L: False R:), val = True

>   ???
E   NameError: name 'addToSubTree' is not defined

binarySearchTree1:21: NameError
   - [# 187] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   17:         '''
   18:         if val <= self.value:
   19:             self.left = self.addToSubTree(self.left, val)
   20:         elif val > self.value:
-  21:             self.right = self.addToSubTree(self.right, val)
+  21:             self.right = self.addToSubTree(right, val)
   22:     
   23:     def addToSubTree(self, parent, val):
   24:         '''Add val to parent subtree (if exists) and return root of that subtree.'''
   25:         if parent is None:
--------------------------------------------------------------------------------
[0.08525 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_0

def test_case_0():
        bool_0 = True
        bool_1 = False
        binary_node_0 = module_0.BinaryNode(bool_1)
>       var_0 = binary_node_0.add(bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:10: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (L: False R:), val = True

>   ???
E   NameError: name 'right' is not defined

binarySearchTree1:21: NameError
   - [# 188] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   31:     def remove(self, val):
   32:         '''
   33:          Remove val of self from BinaryTree. 
   34:         '''
-  35:         if val < self.value:
+  35:         if val < value:
   36:             self.left = self.removeFromParent(self.left, val)
   37:         elif val > self.value:
   38:             self.right = self.removeFromParent(self.right, val)
   39:         else:
--------------------------------------------------------------------------------
[0.09051 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_2

def test_case_2():
        bool_0 = True
        bool_1 = False
        binary_node_0 = module_0.BinaryNode(bool_1)
>       var_0 = binary_node_0.remove(bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (L: False R:), val = True

>   ???
E   NameError: name 'value' is not defined

binarySearchTree1:35: NameError
   - [# 189] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   32:         '''
   33:          Remove val of self from BinaryTree. 
   34:         '''
   35:         if val < self.value:
-  36:             self.left = self.removeFromParent(self.left, val)
+  36:             left = self.removeFromParent(self.left, val)
   37:         elif val > self.value:
   38:             self.right = self.removeFromParent(self.right, val)
   39:         else:
   40:             if self.left is None:
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 190] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   32:         '''
   33:          Remove val of self from BinaryTree. 
   34:         '''
   35:         if val < self.value:
-  36:             self.left = self.removeFromParent(self.left, val)
+  36:             self.left = removeFromParent(self.left, val)
   37:         elif val > self.value:
   38:             self.right = self.removeFromParent(self.right, val)
   39:         else:
   40:             if self.left is None:
--------------------------------------------------------------------------------
[0.11144 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_5

def test_case_5():
        str_0 = 'X>'
        str_1 = 'qkr(Szzyf\t'
        binary_node_0 = module_0.BinaryNode(str_1)
>       var_0 = binary_node_0.remove(str_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (L: qkr(Szzyf	 R:), val = 'X>'

>   ???
E   NameError: name 'removeFromParent' is not defined

binarySearchTree1:36: NameError
   - [# 191] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   32:         '''
   33:          Remove val of self from BinaryTree. 
   34:         '''
   35:         if val < self.value:
-  36:             self.left = self.removeFromParent(self.left, val)
+  36:             self.left = self.removeFromParent(left, val)
   37:         elif val > self.value:
   38:             self.right = self.removeFromParent(self.right, val)
   39:         else:
   40:             if self.left is None:
--------------------------------------------------------------------------------
[0.08749 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_5

def test_case_5():
        str_0 = 'X>'
        str_1 = 'qkr(Szzyf\t'
        binary_node_0 = module_0.BinaryNode(str_1)
>       var_0 = binary_node_0.remove(str_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (L: qkr(Szzyf	 R:), val = 'X>'

>   ???
E   NameError: name 'left' is not defined

binarySearchTree1:36: NameError
   - [# 192] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   33:          Remove val of self from BinaryTree. 
   34:         '''
   35:         if val < self.value:
   36:             self.left = self.removeFromParent(self.left, val)
-  37:         elif val > self.value:
+  37:         elif val > value:
   38:             self.right = self.removeFromParent(self.right, val)
   39:         else:
   40:             if self.left is None:
   41:                 return self.right
--------------------------------------------------------------------------------
[0.08914 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_2

def test_case_2():
        bool_0 = True
        bool_1 = False
        binary_node_0 = module_0.BinaryNode(bool_1)
>       var_0 = binary_node_0.remove(bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (L: False R:), val = True

>   ???
E   NameError: name 'value' is not defined

binarySearchTree1:37: NameError
   - [# 193] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   34:         '''
   35:         if val < self.value:
   36:             self.left = self.removeFromParent(self.left, val)
   37:         elif val > self.value:
-  38:             self.right = self.removeFromParent(self.right, val)
+  38:             right = self.removeFromParent(self.right, val)
   39:         else:
   40:             if self.left is None:
   41:                 return self.right
   42:             
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 194] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   34:         '''
   35:         if val < self.value:
   36:             self.left = self.removeFromParent(self.left, val)
   37:         elif val > self.value:
-  38:             self.right = self.removeFromParent(self.right, val)
+  38:             self.right = removeFromParent(self.right, val)
   39:         else:
   40:             if self.left is None:
   41:                 return self.right
   42:             
--------------------------------------------------------------------------------
[0.08668 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_2

def test_case_2():
        bool_0 = True
        bool_1 = False
        binary_node_0 = module_0.BinaryNode(bool_1)
>       var_0 = binary_node_0.remove(bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (L: False R:), val = True

>   ???
E   NameError: name 'removeFromParent' is not defined

binarySearchTree1:38: NameError
   - [# 195] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   34:         '''
   35:         if val < self.value:
   36:             self.left = self.removeFromParent(self.left, val)
   37:         elif val > self.value:
-  38:             self.right = self.removeFromParent(self.right, val)
+  38:             self.right = self.removeFromParent(right, val)
   39:         else:
   40:             if self.left is None:
   41:                 return self.right
   42:             
--------------------------------------------------------------------------------
[0.08710 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_2

def test_case_2():
        bool_0 = True
        bool_1 = False
        binary_node_0 = module_0.BinaryNode(bool_1)
>       var_0 = binary_node_0.remove(bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (L: False R:), val = True

>   ???
E   NameError: name 'right' is not defined

binarySearchTree1:38: NameError
   - [# 196] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   36:             self.left = self.removeFromParent(self.left, val)
   37:         elif val > self.value:
   38:             self.right = self.removeFromParent(self.right, val)
   39:         else:
-  40:             if self.left is None:
+  40:             if left is None:
   41:                 return self.right
   42:             
   43:             child = self.left
   44:             while child.right:
--------------------------------------------------------------------------------
[0.09332 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_3

def test_case_3():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
>       var_0 = binary_node_0.removeFromParent(binary_node_0, bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree1:57: in removeFromParent
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (L: False R:), val = False

>   ???
E   NameError: name 'left' is not defined

binarySearchTree1:40: NameError
   - [# 197] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   37:         elif val > self.value:
   38:             self.right = self.removeFromParent(self.right, val)
   39:         else:
   40:             if self.left is None:
-  41:                 return self.right
+  41:                 return right
   42:             
   43:             child = self.left
   44:             while child.right:
   45:                 child = child.right
--------------------------------------------------------------------------------
[0.11506 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_3

def test_case_3():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
>       var_0 = binary_node_0.removeFromParent(binary_node_0, bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree1:57: in removeFromParent
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (L: False R:), val = False

>   ???
E   NameError: name 'right' is not defined

binarySearchTree1:41: NameError
   - [# 198] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   39:         else:
   40:             if self.left is None:
   41:                 return self.right
   42:             
-  43:             child = self.left
+  43:             child = left
   44:             while child.right:
   45:                 child = child.right
   46:             
   47:             childKey = child.value
--------------------------------------------------------------------------------
[0.08819 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_4

def test_case_4():
        bool_0 = True
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_1 = var_0.removeFromParent(binary_node_0, bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree1:57: in removeFromParent
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (L:(L: True R:) True R:), val = True

>   ???
E   NameError: name 'left' is not defined

binarySearchTree1:43: NameError
   - [# 199] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   44:             while child.right:
   45:                 child = child.right
   46:             
   47:             childKey = child.value
-  48:             self.left = self.removeFromParent(self.left, childKey)
+  48:             left = self.removeFromParent(self.left, childKey)
   49:             self.value = childKey
   50:         
   51:         return self
   52:     
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 200] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   44:             while child.right:
   45:                 child = child.right
   46:             
   47:             childKey = child.value
-  48:             self.left = self.removeFromParent(self.left, childKey)
+  48:             self.left = removeFromParent(self.left, childKey)
   49:             self.value = childKey
   50:         
   51:         return self
   52:     
--------------------------------------------------------------------------------
[0.09979 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_4

def test_case_4():
        bool_0 = True
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_1 = var_0.removeFromParent(binary_node_0, bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree1:57: in removeFromParent
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (L:(L: True R:) True R:), val = True

>   ???
E   NameError: name 'removeFromParent' is not defined

binarySearchTree1:48: NameError
   - [# 201] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   44:             while child.right:
   45:                 child = child.right
   46:             
   47:             childKey = child.value
-  48:             self.left = self.removeFromParent(self.left, childKey)
+  48:             self.left = self.removeFromParent(left, childKey)
   49:             self.value = childKey
   50:         
   51:         return self
   52:     
--------------------------------------------------------------------------------
[0.09200 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_4

def test_case_4():
        bool_0 = True
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_1 = var_0.removeFromParent(binary_node_0, bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree1:57: in removeFromParent
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = (L:(L: True R:) True R:), val = True

>   ???
E   NameError: name 'left' is not defined

binarySearchTree1:48: NameError
   - [# 202] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   45:                 child = child.right
   46:             
   47:             childKey = child.value
   48:             self.left = self.removeFromParent(self.left, childKey)
-  49:             self.value = childKey
+  49:             value = childKey
   50:         
   51:         return self
   52:     
   53:     def removeFromParent(self, parent, val):
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 203] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   60:     def __repr__(self):
   61:         '''Useful debugging function to produce linear tree representation.'''
   62:         leftS = ''
   63:         rightS = ''
-  64:         if self.left:
+  64:         if left:
   65:             leftS = str(self.left)
   66:         if self.right:
   67:             rightS = str(self.right)
   68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
--------------------------------------------------------------------------------
[0.09433 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_7

def test_case_7():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_node_0.removeFromParent(binary_node_0, bool_0)
        assert binary_node_0.left is None
        assert var_0.left is None
        assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_1.value is False
        assert var_1.left is None
        assert var_1.right is None
        bool_1 = True
        binary_tree_0 = module_0.BinaryTree()
        var_2 = var_0.addToSubTree(var_0, bool_1)
        assert f'{type(binary_node_0.right).__module__}.{type(binary_node_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.right).__module__}.{type(var_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_1.right).__module__}.{type(var_1.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_2.value is False
        assert var_2.left is None
        assert f'{type(var_2.right).__module__}.{type(var_2.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_3 = var_0.__repr__()

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[NameError("name 'left' is not defined") raised in repr()] BinaryNode object at 0x7fa524dea1d0>

>   ???
E   NameError: name 'left' is not defined

binarySearchTree1:64: NameError
   - [# 204] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   61:         '''Useful debugging function to produce linear tree representation.'''
   62:         leftS = ''
   63:         rightS = ''
   64:         if self.left:
-  65:             leftS = str(self.left)
+  65:             leftS = str(left)
   66:         if self.right:
   67:             rightS = str(self.right)
   68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
   69:     
--------------------------------------------------------------------------------
[0.10092 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_9

def test_case_9():
        bool_0 = True
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_1 = var_0.__repr__()

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[NameError("name 'left' is not defined") raised in repr()] BinaryNode object at 0x7fa525055030>

>   ???
E   NameError: name 'left' is not defined

binarySearchTree1:65: NameError
   - [# 205] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   62:         leftS = ''
   63:         rightS = ''
   64:         if self.left:
   65:             leftS = str(self.left)
-  66:         if self.right:
+  66:         if right:
   67:             rightS = str(self.right)
   68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
   69:     
   70:     def inorder(self):
--------------------------------------------------------------------------------
[0.10154 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_7

def test_case_7():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_node_0.removeFromParent(binary_node_0, bool_0)
        assert binary_node_0.left is None
        assert var_0.left is None
        assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_1.value is False
        assert var_1.left is None
        assert var_1.right is None
        bool_1 = True
        binary_tree_0 = module_0.BinaryTree()
        var_2 = var_0.addToSubTree(var_0, bool_1)
        assert f'{type(binary_node_0.right).__module__}.{type(binary_node_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.right).__module__}.{type(var_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_1.right).__module__}.{type(var_1.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_2.value is False
        assert var_2.left is None
        assert f'{type(var_2.right).__module__}.{type(var_2.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_3 = var_0.__repr__()

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[NameError("name 'right' is not defined") raised in repr()] BinaryNode object at 0x7fa525360580>

>   ???
E   NameError: name 'right' is not defined

binarySearchTree1:66: NameError
   - [# 206] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   63:         rightS = ''
   64:         if self.left:
   65:             leftS = str(self.left)
   66:         if self.right:
-  67:             rightS = str(self.right)
+  67:             rightS = str(right)
   68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
   69:     
   70:     def inorder(self):
   71:         '''In order traversal generator of tree rooted at given node.'''
--------------------------------------------------------------------------------
[0.08891 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_7

def test_case_7():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_node_0.removeFromParent(binary_node_0, bool_0)
        assert binary_node_0.left is None
        assert var_0.left is None
        assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_1.value is False
        assert var_1.left is None
        assert var_1.right is None
        bool_1 = True
        binary_tree_0 = module_0.BinaryTree()
        var_2 = var_0.addToSubTree(var_0, bool_1)
        assert f'{type(binary_node_0.right).__module__}.{type(binary_node_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.right).__module__}.{type(var_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_1.right).__module__}.{type(var_1.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_2.value is False
        assert var_2.left is None
        assert f'{type(var_2.right).__module__}.{type(var_2.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_3 = var_0.__repr__()

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[NameError("name 'right' is not defined") raised in repr()] BinaryNode object at 0x7fa5251a7100>

>   ???
E   NameError: name 'right' is not defined

binarySearchTree1:67: NameError
   - [# 207] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   64:         if self.left:
   65:             leftS = str(self.left)
   66:         if self.right:
   67:             rightS = str(self.right)
-  68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
+  68:         return ((((('(L:' + leftS) + ' ') + str(value)) + ' R:') + rightS) + ')'
   69:     
   70:     def inorder(self):
   71:         '''In order traversal generator of tree rooted at given node.'''
   72:         if self.left:
--------------------------------------------------------------------------------
[0.09600 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_7

def test_case_7():
        bool_0 = False
        binary_node_0 = module_0.BinaryNode(bool_0)
        var_0 = binary_node_0.addToSubTree(binary_node_0, bool_0)
        assert f'{type(binary_node_0.left).__module__}.{type(binary_node_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.left).__module__}.{type(var_0.left).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_node_0.removeFromParent(binary_node_0, bool_0)
        assert binary_node_0.left is None
        assert var_0.left is None
        assert f'{type(var_1).__module__}.{type(var_1).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_1.value is False
        assert var_1.left is None
        assert var_1.right is None
        bool_1 = True
        binary_tree_0 = module_0.BinaryTree()
        var_2 = var_0.addToSubTree(var_0, bool_1)
        assert f'{type(binary_node_0.right).__module__}.{type(binary_node_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_0.right).__module__}.{type(var_0.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert f'{type(var_1.right).__module__}.{type(var_1.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
        assert var_2.value is False
        assert var_2.left is None
        assert f'{type(var_2.right).__module__}.{type(var_2.right).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_3 = var_0.__repr__()

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
binarySearchTree1:67: in __repr__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[NameError("name 'value' is not defined") raised in repr()] BinaryNode object at 0x7fa52516c730>

>   ???
E   NameError: name 'value' is not defined

binarySearchTree1:68: NameError
   - [# 208] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   68:         return ((((('(L:' + leftS) + ' ') + str(self.value)) + ' R:') + rightS) + ')'
   69:     
   70:     def inorder(self):
   71:         '''In order traversal generator of tree rooted at given node.'''
-  72:         if self.left:
+  72:         if left:
   73:             for v in self.left.inorder():
   74:                 yield v
   75:         
   76:         yield self.value
--------------------------------------------------------------------------------
[0.10881 s] survived
   - [# 209] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   69:     
   70:     def inorder(self):
   71:         '''In order traversal generator of tree rooted at given node.'''
   72:         if self.left:
-  73:             for v in self.left.inorder():
+  73:             for v in left.inorder():
   74:                 yield v
   75:         
   76:         yield self.value
   77:         
--------------------------------------------------------------------------------
[0.13078 s] survived
   - [# 210] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   72:         if self.left:
   73:             for v in self.left.inorder():
   74:                 yield v
   75:         
-  76:         yield self.value
+  76:         yield value
   77:         
   78:         if self.right:
   79:             for v in self.right.inorder():
   80:                 yield v
--------------------------------------------------------------------------------
[0.12559 s] survived
   - [# 211] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   74:                 yield v
   75:         
   76:         yield self.value
   77:         
-  78:         if self.right:
+  78:         if right:
   79:             for v in self.right.inorder():
   80:                 yield v
   81: 
   82: class BinaryTree:
--------------------------------------------------------------------------------
[0.11383 s] survived
   - [# 212] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   75:         
   76:         yield self.value
   77:         
   78:         if self.right:
-  79:             for v in self.right.inorder():
+  79:             for v in right.inorder():
   80:                 yield v
   81: 
   82: class BinaryTree:
   83:     
--------------------------------------------------------------------------------
[0.10695 s] survived
   - [# 213] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   82: class BinaryTree:
   83:     
   84:     def __init__(self):
   85:         '''Create empty binary tree.'''
-  86:         self.root = None
+  86:         root = None
   87:     
   88:     def add(self, value):
   89:         '''Insert value into proper location in Binary Tree.'''
   90:         if self.root is None:
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 214] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   86:         self.root = None
   87:     
   88:     def add(self, value):
   89:         '''Insert value into proper location in Binary Tree.'''
-  90:         if self.root is None:
+  90:         if root is None:
   91:             self.root = BinaryNode(value)
   92:         else:
   93:             self.root.add(value)
   94:     
--------------------------------------------------------------------------------
[0.09545 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_10

def test_case_10():
        binary_tree_0 = module_0.BinaryTree()
>       var_0 = binary_tree_0.add(binary_tree_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:110: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = binary:(), value = binary:()

>   ???
E   NameError: name 'root' is not defined

binarySearchTree1:90: NameError
   - [# 215] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   87:     
   88:     def add(self, value):
   89:         '''Insert value into proper location in Binary Tree.'''
   90:         if self.root is None:
-  91:             self.root = BinaryNode(value)
+  91:             root = BinaryNode(value)
   92:         else:
   93:             self.root.add(value)
   94:     
   95:     def remove(self, val):
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 216] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   89:         '''Insert value into proper location in Binary Tree.'''
   90:         if self.root is None:
   91:             self.root = BinaryNode(value)
   92:         else:
-  93:             self.root.add(value)
+  93:             root.add(value)
   94:     
   95:     def remove(self, val):
   96:         '''Remove value from tree.'''
   97:         if self.root:
--------------------------------------------------------------------------------
[0.10056 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_15

def test_case_15():
        binary_tree_0 = module_0.BinaryTree()
        binary_tree_1 = module_0.BinaryTree()
        var_0 = binary_tree_0.__repr__()
        assert var_0 == 'binary:()'
        var_1 = binary_tree_0.add(var_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_2 = binary_tree_0.add(var_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = binary:(L: binary:() R:), value = 'binary:()'

>   ???
E   NameError: name 'root' is not defined

binarySearchTree1:93: NameError
   - [# 217] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   93:             self.root.add(value)
   94:     
   95:     def remove(self, val):
   96:         '''Remove value from tree.'''
-  97:         if self.root:
+  97:         if root:
   98:             self.root = self.root.remove(val)
   99:     
  100:     def getMin(self):
  101:         '''Returns minimum value.'''
--------------------------------------------------------------------------------
[0.17346 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_14

def test_case_14():
        binary_tree_0 = module_0.BinaryTree()
>       var_0 = binary_tree_0.remove(binary_tree_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = binary:(), val = binary:()

>   ???
E   NameError: name 'root' is not defined

binarySearchTree1:97: NameError
   - [# 218] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   94:     
   95:     def remove(self, val):
   96:         '''Remove value from tree.'''
   97:         if self.root:
-  98:             self.root = self.root.remove(val)
+  98:             root = self.root.remove(val)
   99:     
  100:     def getMin(self):
  101:         '''Returns minimum value.'''
  102:         if self.root is None:
--------------------------------------------------------------------------------
[0.00000 s] incompetent

ValueError: expression must have Store context but has Load instead

   - [# 219] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   94:     
   95:     def remove(self, val):
   96:         '''Remove value from tree.'''
   97:         if self.root:
-  98:             self.root = self.root.remove(val)
+  98:             self.root = root.remove(val)
   99:     
  100:     def getMin(self):
  101:         '''Returns minimum value.'''
  102:         if self.root is None:
--------------------------------------------------------------------------------
[0.12885 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py::test_case_2

def test_case_2():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.remove(binary_tree_0)
        var_1 = binary_tree_0.__contains__(var_0)
        assert var_1 is False
        var_2 = binary_tree_0.add(var_1)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = binary_tree_0.add(var_1)
>       var_4 = binary_tree_0.remove(var_1)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = binary:(L:(L: False R:) False R:), val = False

>   ???
E   NameError: name 'root' is not defined

binarySearchTree1:98: NameError
   - [# 220] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
   98:             self.root = self.root.remove(val)
   99:     
  100:     def getMin(self):
  101:         '''Returns minimum value.'''
- 102:         if self.root is None:
+ 102:         if root is None:
  103:             raise ValueError('Binary Tree is empty')
  104:         n = self.root
  105:         while n.left != None:
  106:             n = n.left
--------------------------------------------------------------------------------
[0.09596 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_15

def test_case_15():
        binary_tree_0 = module_0.BinaryTree()
        binary_tree_1 = module_0.BinaryTree()
        var_0 = binary_tree_0.__repr__()
        assert var_0 == 'binary:()'
        var_1 = binary_tree_0.add(var_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_2 = binary_tree_0.add(var_0)
        var_3 = binary_tree_0.__iter__()
        var_4 = var_3.__repr__()
>       var_5 = binary_tree_0.getMin()

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = binary:(L:(L: binary:() R:) binary:() R:)

>   ???
E   NameError: name 'root' is not defined

binarySearchTree1:102: NameError
   - [# 221] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
  100:     def getMin(self):
  101:         '''Returns minimum value.'''
  102:         if self.root is None:
  103:             raise ValueError('Binary Tree is empty')
- 104:         n = self.root
+ 104:         n = root
  105:         while n.left != None:
  106:             n = n.left
  107:         return n.value
  108:     
--------------------------------------------------------------------------------
[0.09354 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_15

def test_case_15():
        binary_tree_0 = module_0.BinaryTree()
        binary_tree_1 = module_0.BinaryTree()
        var_0 = binary_tree_0.__repr__()
        assert var_0 == 'binary:()'
        var_1 = binary_tree_0.add(var_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_2 = binary_tree_0.add(var_0)
        var_3 = binary_tree_0.__iter__()
        var_4 = var_3.__repr__()
>       var_5 = binary_tree_0.getMin()

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = binary:(L:(L: binary:() R:) binary:() R:)

>   ???
E   NameError: name 'root' is not defined

binarySearchTree1:104: NameError
   - [# 222] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
  107:         return n.value
  108:     
  109:     def getMax(self):
  110:         '''Returns maximum value.'''
- 111:         if self.root is None:
+ 111:         if root is None:
  112:             raise ValueError('Binary Tree is empty')
  113:         n = self.root
  114:         while n.right != None:
  115:             n = n.right
--------------------------------------------------------------------------------
[0.09718 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_18

def test_case_18():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.add(binary_tree_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_1 = binary_tree_0.getMax()

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[RecursionError('maximum recursion depth exceeded while getting the str of an object') raised in repr()] BinaryTree object at 0x7fa524e613c0>

>   ???
E   NameError: name 'root' is not defined

binarySearchTree1:111: NameError
   - [# 223] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
  109:     def getMax(self):
  110:         '''Returns maximum value.'''
  111:         if self.root is None:
  112:             raise ValueError('Binary Tree is empty')
- 113:         n = self.root
+ 113:         n = root
  114:         while n.right != None:
  115:             n = n.right
  116:         return n.value
  117:     
--------------------------------------------------------------------------------
[0.11139 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_18

def test_case_18():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.add(binary_tree_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_1 = binary_tree_0.getMax()

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[RecursionError('maximum recursion depth exceeded while getting the str of an object') raised in repr()] BinaryTree object at 0x7fa524ee0c10>

>   ???
E   NameError: name 'root' is not defined

binarySearchTree1:113: NameError
   - [# 224] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
  116:         return n.value
  117:     
  118:     def __contains__(self, target):
  119:         '''Check whether BST contains target value.'''
- 120:         node = self.root
+ 120:         node = root
  121:         while node:
  122:             if target < node.value:
  123:                 node = node.left
  124:             elif target > node.value:
--------------------------------------------------------------------------------
[0.13200 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_20

def test_case_20():
        binary_tree_0 = module_0.BinaryTree()
        set_0 = {binary_tree_0}
        var_0 = binary_tree_0.add(set_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_1 = binary_tree_0.__contains__(set_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = binary:(L: {binary:(L: set(...) R:)} R:)
target = {binary:(L: {binary:(L: set(...) R:)} R:)}

>   ???
E   NameError: name 'root' is not defined

binarySearchTree1:120: NameError
   - [# 225] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
  132:         '''
  133:         Return value closest to target. If there are several, then
  134:         return one of them.
  135:         '''
- 136:         if self.root is None:
+ 136:         if root is None:
  137:             return None
  138:         
  139:         best = node = self.root
  140:         distance = abs(self.root.value - target)
--------------------------------------------------------------------------------
[0.10144 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_23

def test_case_23():
        bool_0 = True
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.add(bool_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_1 = binary_tree_0.closest(bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = binary:(L: True R:), target = True

>   ???
E   NameError: name 'root' is not defined

binarySearchTree1:136: NameError
   - [# 226] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
  135:         '''
  136:         if self.root is None:
  137:             return None
  138:         
- 139:         best = node = self.root
+ 139:         best = node = root
  140:         distance = abs(self.root.value - target)
  141:         while node:
  142:             if abs(node.value - target) < distance:
  143:                 distance = abs(node.value - target)
--------------------------------------------------------------------------------
[0.09707 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_23

def test_case_23():
        bool_0 = True
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.add(bool_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_1 = binary_tree_0.closest(bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = binary:(L: True R:), target = True

>   ???
E   NameError: name 'root' is not defined

binarySearchTree1:139: NameError
   - [# 227] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
  136:         if self.root is None:
  137:             return None
  138:         
  139:         best = node = self.root
- 140:         distance = abs(self.root.value - target)
+ 140:         distance = abs(root.value - target)
  141:         while node:
  142:             if abs(node.value - target) < distance:
  143:                 distance = abs(node.value - target)
  144:                 best = node
--------------------------------------------------------------------------------
[0.10357 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_23

def test_case_23():
        bool_0 = True
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.add(bool_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
>       var_1 = binary_tree_0.closest(bool_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = binary:(L: True R:), target = True

>   ???
E   NameError: name 'root' is not defined

binarySearchTree1:140: NameError
   - [# 228] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
  152:         return best.value
  153:     
  154:     def __iter__(self):
  155:         '''In order traversal of elements in the tree.'''
- 156:         if self.root:
+ 156:         if root:
  157:             for e in self.root.inorder():
  158:                 yield e
  159:     
  160:     def __repr__(self):
--------------------------------------------------------------------------------
[0.10454 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_26

def test_case_26():
        binary_tree_0 = module_0.BinaryTree()
>       object_0 = module_1.object(*binary_tree_0)

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = binary:()

>   ???
E   NameError: name 'root' is not defined

binarySearchTree1:156: NameError
   - [# 229] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
  153:     
  154:     def __iter__(self):
  155:         '''In order traversal of elements in the tree.'''
  156:         if self.root:
- 157:             for e in self.root.inorder():
+ 157:             for e in root.inorder():
  158:                 yield e
  159:     
  160:     def __repr__(self):
  161:         if self.root is None:
--------------------------------------------------------------------------------
[0.11182 s] survived
   - [# 230] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
  157:             for e in self.root.inorder():
  158:                 yield e
  159:     
  160:     def __repr__(self):
- 161:         if self.root is None:
+ 161:         if root is None:
  162:             return 'binary:()'
  163:         return 'binary:' + str(self.root)
  164: 
  165: '''
--------------------------------------------------------------------------------
[0.11828 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_15

def test_case_15():
        binary_tree_0 = module_0.BinaryTree()
        binary_tree_1 = module_0.BinaryTree()
>       var_0 = binary_tree_0.__repr__()

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[NameError("name 'root' is not defined") raised in repr()] BinaryTree object at 0x7fa524f01390>

>   ???
E   NameError: name 'root' is not defined

binarySearchTree1:161: NameError
   - [# 231] SVD binarySearchTree1: 
--------------------------------------------------------------------------------
  159:     
  160:     def __repr__(self):
  161:         if self.root is None:
  162:             return 'binary:()'
- 163:         return 'binary:' + str(self.root)
+ 163:         return 'binary:' + str(root)
  164: 
  165: '''
  166: Change Log:
  167: -----------
--------------------------------------------------------------------------------
[0.18333 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py::test_case_9

def test_case_9():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.remove(binary_tree_0)
        var_1 = binary_tree_0.__contains__(var_0)
        assert var_1 is False
        var_2 = binary_tree_0.add(var_1)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = binary_tree_0.add(var_1)
>       var_4 = binary_tree_0.__repr__()

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[NameError("name 'root' is not defined") raised in repr()] BinaryTree object at 0x7fa5255a5720>

>   ???
E   NameError: name 'root' is not defined

binarySearchTree1:163: NameError
   - [# 232] ZIL binarySearchTree1: 
--------------------------------------------------------------------------------
   41:                 return self.right
   42:             
   43:             child = self.left
   44:             while child.right:
-  45:                 child = child.right
+  45:                 break
   46:             
   47:             childKey = child.value
   48:             self.left = self.removeFromParent(self.left, childKey)
   49:             self.value = childKey
--------------------------------------------------------------------------------
[0.15754 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py::test_case_28

def test_case_28():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.closest(binary_tree_0)
        var_1 = binary_tree_0.__contains__(var_0)
        assert var_1 is False
        int_0 = 3380
        var_2 = binary_tree_0.add(int_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = binary_tree_0.add(var_1)
        var_4 = binary_tree_0.__contains__(var_1)
        assert var_4 is True
        var_5 = binary_tree_0.add(var_4)
        var_6 = binary_tree_0.getMax()
        assert var_6 == 3380
        var_7 = binary_tree_0.closest(var_6)
        var_8 = var_3.__repr__()
        var_9 = binary_tree_0.add(var_7)
        var_10 = binary_tree_0.remove(var_7)
        var_11 = binary_tree_0.__repr__()
>       assert var_11 == 'binary:(L:(L: False R:(L: True R:)) 3380 R:)'
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py:357: AssertionError
   - [# 233] ZIL binarySearchTree1: 
--------------------------------------------------------------------------------
   70:     def inorder(self):
   71:         '''In order traversal generator of tree rooted at given node.'''
   72:         if self.left:
   73:             for v in self.left.inorder():
-  74:                 yield v
+  74:                 break
   75:         
   76:         yield self.value
   77:         
   78:         if self.right:
--------------------------------------------------------------------------------
[0.10559 s] survived
   - [# 234] ZIL binarySearchTree1: 
--------------------------------------------------------------------------------
   76:         yield self.value
   77:         
   78:         if self.right:
   79:             for v in self.right.inorder():
-  80:                 yield v
+  80:                 break
   81: 
   82: class BinaryTree:
   83:     
   84:     def __init__(self):
--------------------------------------------------------------------------------
[0.11090 s] survived
   - [# 235] ZIL binarySearchTree1: 
--------------------------------------------------------------------------------
  102:         if self.root is None:
  103:             raise ValueError('Binary Tree is empty')
  104:         n = self.root
  105:         while n.left != None:
- 106:             n = n.left
+ 106:             break
  107:         return n.value
  108:     
  109:     def getMax(self):
  110:         '''Returns maximum value.'''
--------------------------------------------------------------------------------
[0.10736 s] survived
   - [# 236] ZIL binarySearchTree1: 
--------------------------------------------------------------------------------
  111:         if self.root is None:
  112:             raise ValueError('Binary Tree is empty')
  113:         n = self.root
  114:         while n.right != None:
- 115:             n = n.right
+ 115:             break
  116:         return n.value
  117:     
  118:     def __contains__(self, target):
  119:         '''Check whether BST contains target value.'''
--------------------------------------------------------------------------------
[0.15958 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py::test_case_19

def test_case_19():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.closest(binary_tree_0)
        var_1 = binary_tree_0.__contains__(var_0)
        assert var_1 is False
        var_2 = binary_tree_0.add(var_1)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = binary_tree_0.__contains__(var_1)
        assert var_3 is True
        var_4 = binary_tree_0.add(var_3)
        var_5 = binary_tree_0.getMax()
>       assert var_5 is True
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py:196: AssertionError
   - [# 237] ZIL binarySearchTree1: 
--------------------------------------------------------------------------------
  118:     def __contains__(self, target):
  119:         '''Check whether BST contains target value.'''
  120:         node = self.root
  121:         while node:
- 122:             if target < node.value:
- 123:                 node = node.left
- 124:             elif target > node.value:
- 125:                 node = node.right
- 126:             else:
- 127:                 return True
+ 122:             break
+ 123:         
+ 124:         
+ 125:         
+ 126:         
+ 127:         
  128:         
  129:         return False
  130:     
  131:     def closest(self, target):
--------------------------------------------------------------------------------
[0.12446 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py::test_case_20

def test_case_20():
        binary_tree_0 = module_0.BinaryTree()
        set_0 = {binary_tree_0}
        var_0 = binary_tree_0.add(set_0)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_1 = binary_tree_0.__contains__(set_0)
>       assert var_1 is True
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:177: AssertionError
   - [# 238] ZIL binarySearchTree1: 
--------------------------------------------------------------------------------
  138:         
  139:         best = node = self.root
  140:         distance = abs(self.root.value - target)
  141:         while node:
- 142:             if abs(node.value - target) < distance:
- 143:                 distance = abs(node.value - target)
- 144:                 best = node
- 145:             if target < node.value:
- 146:                 node = node.left
- 147:             elif target > node.value:
- 148:                 node = node.right
- 149:             else:
- 150:                 return target
+ 142:             break
+ 143:         
+ 144:         
+ 145:         
+ 146:         
+ 147:         
+ 148:         
+ 149:         
+ 150:         
  151:         
  152:         return best.value
  153:     
  154:     def __iter__(self):
--------------------------------------------------------------------------------
[0.13495 s] killed by DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py::test_case_22

def test_case_22():
        binary_tree_0 = module_0.BinaryTree()
        var_0 = binary_tree_0.closest(binary_tree_0)
        var_1 = binary_tree_0.__contains__(var_0)
        assert var_1 is False
        var_2 = binary_tree_0.add(var_1)
        assert f'{type(binary_tree_0.root).__module__}.{type(binary_tree_0.root).__qualname__}' == 'binarySearchTree1.BinaryNode'
        var_3 = binary_tree_0.__contains__(var_1)
        assert var_3 is True
        var_4 = binary_tree_0.add(var_3)
        var_5 = binary_tree_0.getMax()
        assert var_5 is True
        var_6 = binary_tree_0.closest(var_5)
>       assert var_6 is True
E       AssertionError

DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_DYNAMOSA.py:251: AssertionError
   - [# 239] ZIL binarySearchTree1: 
--------------------------------------------------------------------------------
  154:     def __iter__(self):
  155:         '''In order traversal of elements in the tree.'''
  156:         if self.root:
  157:             for e in self.root.inorder():
- 158:                 yield e
+ 158:                 break
  159:     
  160:     def __repr__(self):
  161:         if self.root is None:
  162:             return 'binary:()'
--------------------------------------------------------------------------------
[0.10759 s] incompetent

TypeError: /home/auri/temp/lucca/python_experiments/binarySearchTree1/DYNAMOSA-MIO-WHOLE_SUITE/test_binarySearchTree1_MIO.py:208: TypeError: iter() returned non-iterator of type 'NoneType'

[*] Mutation score [91.33724 s]: 77.0%
   - all: 239
   - killed: 145 (60.7%)
   - survived: 46 (19.2%)
   - incompetent: 39 (16.3%)
   - timeout: 9 (3.8%)
